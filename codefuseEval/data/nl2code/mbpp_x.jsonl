{"prompt": "Write a python function to remove first and last occurrence of a given character from the string.", "canonical_solution": "def remove_Occ(s,ch): \r\n    for i in range(len(s)): \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    for i in range(len(s) - 1,-1,-1):  \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    return s ", "task_id": "Python/11", "test_setup": "", "test": ["assert remove_Occ(\"hello\",\"l\") == \"heo\"", "assert remove_Occ(\"abcda\",\"a\") == \"bcd\"", "assert remove_Occ(\"PHP\",\"P\") == \"H\""], "challenge_test_list": ["assert remove_Occ(\"hellolloll\",\"l\") == \"helollol\"", "assert remove_Occ(\"\",\"l\") == \"\""], "func_title": "def remove_Occ(s,ch): \r", "prompt_text_chinese": "写一个Python函数，从字符串中删除第一个和最后一个出现的字符。", "code_comment": "定义函数，输入参数为字符串s和字符ch\n遍历字符串s中的每一个字符\n如果当前字符等于要删除的字符ch\n则将该字符从字符串中删除\n并跳出循环，只删除第一个匹配到的字符\n反向遍历字符串s中的每一个字符，从后向前删除字符\n并跳出循环，只删除最后一个匹配到的字符\n返回删除字符后的字符串s\n"}
{"prompt": "Write a function to sort a given matrix in ascending order according to the sum of its rows.", "canonical_solution": "def sort_matrix(M):\r\n    result = sorted(M, key=sum)\r\n    return result", "task_id": "Python/12", "test_setup": "", "test": ["assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]", "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]", "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"], "challenge_test_list": [], "func_title": "def sort_matrix(M):\r", "prompt_text_chinese": "写一个函数，根据行的总和，将给定的矩阵按升序排序。", "code_comment": "定义函数，输入参数为矩阵M\n对矩阵M中的每一行，按照行元素的和进行排序，返回排序后的结果赋值给result\n返回排序后的矩阵result\n"}
{"prompt": "Write a function to count the most common words in a dictionary.", "canonical_solution": "from collections import Counter\r\ndef count_common(words):\r\n  word_counts = Counter(words)\r\n  top_four = word_counts.most_common(4)\r\n  return (top_four)\r\n", "task_id": "Python/13", "test_setup": "", "test": ["assert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',\"black\",'pink','green','green','pink','green','pink','white','orange',\"orange\",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]", "assert count_common(['one', 'two', 'three', 'four', 'five', 'one', 'two', 'one', 'three', 'one']) == [('one', 4), ('two', 2), ('three', 2), ('four', 1)]", "assert count_common(['Facebook', 'Apple', 'Amazon', 'Netflix', 'Google', 'Apple', 'Netflix', 'Amazon']) == [('Apple', 2), ('Amazon', 2), ('Netflix', 2), ('Facebook', 1)]"], "challenge_test_list": [], "func_title": "def count_common(words):\r", "prompt_text_chinese": "写一个函数来计算字典中最常用的单词。", "code_comment": "导入Counter类\n定义函数，输入参数为字符串列表words\n使用Counter类对字符串列表words中的元素进行计数\n获取出现次数最多的前4个元素及其出现次数，返回结果保存在top_four变量中\n返回出现次数最多的前4个元素及其出现次数\n"}
{"prompt": "Write a python function to find the volume of a triangular prism.", "canonical_solution": "def find_Volume(l,b,h) : \r\n    return ((l * b * h) / 2) ", "task_id": "Python/14", "test_setup": "", "test": ["assert find_Volume(10,8,6) == 240", "assert find_Volume(3,2,2) == 6", "assert find_Volume(1,2,1) == 1"], "challenge_test_list": [], "func_title": "def find_Volume(l,b,h) : \r", "prompt_text_chinese": "写一个Python函数来求一个三角棱柱的体积。", "code_comment": "定义函数，输入参数为长l、宽b、高h\n计算长方体的体积，并除以2，返回结果\n"}
{"prompt": "Write a function to split a string at lowercase letters.", "canonical_solution": "import re\r\ndef split_lowerstring(text):\r\n return (re.findall('[a-z][^a-z]*', text))", "task_id": "Python/15", "test_setup": "", "test": ["assert split_lowerstring(\"AbCd\")==['bC','d']", "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']", "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"], "challenge_test_list": [], "func_title": "def split_lowerstring(text):\r", "prompt_text_chinese": "写一个函数，在小写字母处分割一个字符串。", "code_comment": "导入正则表达式模块re\n定义函数，输入参数为字符串text\n将字符串text中的连续小写字母与后面的非小写字母部分分开，返回结果保存在列表中\n"}
{"prompt": "Write a function to find sequences of lowercase letters joined with an underscore.", "canonical_solution": "import re\r\ndef text_lowercase_underscore(text):\r\n        patterns = '^[a-z]+_[a-z]+$'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')", "task_id": "Python/16", "test_setup": "", "test": ["assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')", "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')", "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"], "challenge_test_list": ["assert text_lowercase_underscore(\"aab-cbbbc\")==('Not matched!')"], "func_title": "def text_lowercase_underscore(text):\r", "prompt_text_chinese": "写一个函数来查找用下划线连接的小写字母的序列。", "code_comment": "导入正则表达式模块\n定义一个函数，将文本转换为小写并将其中的空格替换为下划线\n定义正则表达式模式，该模式匹配以小写字母开头，中间有一个下划线，最后以小写字母结尾的字符串\n使用正则表达式模式匹配传入的文本\n如果匹配成功，返回“Found a match！”\n如果匹配失败，返回“Not matched！”"}
{"prompt": "Write a function to find the perimeter of a square.", "canonical_solution": "def square_perimeter(a):\r\n  perimeter=4*a\r\n  return perimeter", "task_id": "Python/17", "test_setup": "", "test": ["assert square_perimeter(10)==40", "assert square_perimeter(5)==20", "assert square_perimeter(4)==16"], "challenge_test_list": [], "func_title": "def square_perimeter(a):\r", "prompt_text_chinese": "写一个函数来寻找一个正方形的周长。", "code_comment": "定义一个计算正方形周长的函数，参数为正方形的边长\n周长等于正方形的边长乘以4\n返回计算出来的周长\n"}
{"prompt": "Write a function to remove characters from the first string which are present in the second string.", "canonical_solution": "NO_OF_CHARS = 256\r\ndef str_to_list(string): \r\n\ttemp = [] \r\n\tfor x in string: \r\n\t\ttemp.append(x) \r\n\treturn temp \r\ndef lst_to_string(List): \r\n\treturn ''.join(List) \r\ndef get_char_count_array(string): \r\n\tcount = [0] * NO_OF_CHARS \r\n\tfor i in string: \r\n\t\tcount[ord(i)] += 1\r\n\treturn count \r\ndef remove_dirty_chars(string, second_string): \r\n\tcount = get_char_count_array(second_string) \r\n\tip_ind = 0\r\n\tres_ind = 0\r\n\ttemp = '' \r\n\tstr_list = str_to_list(string) \r\n\twhile ip_ind != len(str_list): \r\n\t\ttemp = str_list[ip_ind] \r\n\t\tif count[ord(temp)] == 0: \r\n\t\t\tstr_list[res_ind] = str_list[ip_ind] \r\n\t\t\tres_ind += 1\r\n\t\tip_ind+=1\r\n\treturn lst_to_string(str_list[0:res_ind]) ", "task_id": "Python/18", "test_setup": "", "test": ["assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'", "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'", "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "], "challenge_test_list": [], "func_title": "def str_to_list(string): \r", "prompt_text_chinese": "写一个函数，从第一个字符串中删除存在于第二个字符串中的字符。", "code_comment": "定义常量NO_OF_CHARS为256\n将字符串转换为列表\n将列表转换为字符串\n获取字符计数数组\n移除字符串中的脏字符\n返回移除脏字符后的字符串"}
{"prompt": "Write a function to find whether a given array of integers contains any duplicate element.", "canonical_solution": "def test_duplicate(arraynums):\r\n    nums_set = set(arraynums)    \r\n    return len(arraynums) != len(nums_set)     ", "task_id": "Python/19", "test_setup": "", "test": ["assert test_duplicate(([1,2,3,4,5]))==False", "assert test_duplicate(([1,2,3,4, 4]))==True", "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"], "challenge_test_list": [], "func_title": "def test_duplicate(arraynums):\r", "prompt_text_chinese": "写一个函数来查找一个给定的整数数组是否包含任何重复的元素。", "code_comment": "定义一个检查数组中是否有重复元素的函数，参数为待检查的数组\n将数组转化为set，去除重复元素\n如果原数组与set后的数组长度不一致，则说明存在重复元素，返回True，否则返回False\n"}
{"prompt": "Write a function to check if the given number is woodball or not.", "canonical_solution": "def is_woodall(x): \r\n\tif (x % 2 == 0): \r\n\t\treturn False\r\n\tif (x == 1): \r\n\t\treturn True\r\n\tx = x + 1 \r\n\tp = 0\r\n\twhile (x % 2 == 0): \r\n\t\tx = x/2\r\n\t\tp = p + 1\r\n\t\tif (p == x): \r\n\t\t\treturn True\r\n\treturn False", "task_id": "Python/20", "test_setup": "", "test": ["assert is_woodall(383) == True", "assert is_woodall(254) == False", "assert is_woodall(200) == False"], "challenge_test_list": ["assert is_woodall(32212254719) == True", "assert is_woodall(32212254718) == False", "assert is_woodall(159) == True"], "func_title": "def is_woodall(x): \r", "prompt_text_chinese": "写一个函数来检查给定的数字是否是木球。", "code_comment": "定义一个判断一个数是否为Woodall数的函数，参数为待判断的数x\n如果x为偶数，则不是Woodall数，直接返回False\n如果x为1，则是Woodall数，直接返回True\n对x进行加1操作\n如果x是2的幂次方，则p加1，x除以2，继续进行循环，直到x不是2的幂次方为止\n如果p等于x，则说明x是Woodall数，返回True\n如果上述条件都不满足，则返回False\n"}
{"prompt": "Write a function to find m number of multiples of n.", "canonical_solution": "def multiples_of_num(m,n): \r\n    multiples_of_num= list(range(n,(m+1)*n, n)) \r\n    return list(multiples_of_num)", "task_id": "Python/21", "test_setup": "", "test": ["assert multiples_of_num(4,3)== [3,6,9,12]", "assert multiples_of_num(2,5)== [5,10]", "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]"], "challenge_test_list": [], "func_title": "def multiples_of_num(m,n): \r", "prompt_text_chinese": "写一个函数来寻找n的倍数的m数。", "code_comment": "定义一个求n的倍数的函数，参数为倍数n和最大数m\n从n开始，每次加n，生成一个列表，列表中元素都是n的倍数\n返回生成的倍数列表\n"}
{"prompt": "Write a function to find the first duplicate element in a given array of integers.", "canonical_solution": "def find_first_duplicate(nums):\r\n    num_set = set()\r\n    no_duplicate = -1\r\n\r\n    for i in range(len(nums)):\r\n\r\n        if nums[i] in num_set:\r\n            return nums[i]\r\n        else:\r\n            num_set.add(nums[i])\r\n\r\n    return no_duplicate", "task_id": "Python/22", "test_setup": "", "test": ["assert find_first_duplicate(([1, 2, 3, 4, 4, 5]))==4", "assert find_first_duplicate([1, 2, 3, 4])==-1", "assert find_first_duplicate([1, 1, 2, 3, 3, 2, 2])==1"], "challenge_test_list": [], "func_title": "def find_first_duplicate(nums):\r", "prompt_text_chinese": "写一个函数，在给定的整数阵列中找到第一个重复的元素。", "code_comment": "定义一个用于查找数组中第一个重复元素的函数，参数为待查找的数组nums\n定义一个空集合，用于存储已经遍历过的元素\n定义一个标记，表示数组中没有重复元素\n遍历数组中的每一个元素\n如果当前元素已经在集合中出现过，则说明找到了数组中的第一个重复元素，直接返回该元素\n如果当前元素没有出现过，则将其加入集合中\n如果遍历完整个数组，仍然没有找到重复元素，则返回标记，表示数组中没有重复元素"}
{"prompt": "Write a python function to find the maximum sum of elements of list in a list of lists.", "canonical_solution": "def maximum_Sum(list1): \r\n    maxi = -100000\r\n    for x in list1: \r\n        sum = 0 \r\n        for y in x: \r\n            sum+= y      \r\n        maxi = max(sum,maxi)     \r\n    return maxi ", "task_id": "Python/23", "test_setup": "", "test": ["assert maximum_Sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33", "assert maximum_Sum([[0,1,1],[1,1,2],[3,2,1]]) == 6", "assert maximum_Sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19"], "challenge_test_list": ["assert maximum_Sum([[0,-1,-1],[-1,-1,-2],[-3,-2,-1]]) == -2"], "func_title": "def maximum_Sum(list1): \r", "prompt_text_chinese": "写一个Python函数来寻找一个列表中的列表元素的最大和。", "code_comment": "定义一个求二维数组中所有子数组元素之和的最大值的函数，参数为待求解的二维数组list1\n定义一个起始值，保证结果的正确性\n遍历二维数组中的每一个一维数组\n定义一个变量，用于记录当前一维数组中所有元素之和\n遍历当前一维数组中的每一个元素\n将当前元素累加到sum中\n将当前一维数组中所有元素之和与maxi进行比较，将较大值保存在maxi中\n返回所有子数组元素之和的最大值"}
{"prompt": "Write a function to convert the given binary number to its decimal equivalent.", "canonical_solution": "def binary_to_decimal(binary): \r\n    binary1 = binary \r\n    decimal, i, n = 0, 0, 0\r\n    while(binary != 0): \r\n        dec = binary % 10\r\n        decimal = decimal + dec * pow(2, i) \r\n        binary = binary//10\r\n        i += 1\r\n    return (decimal)", "task_id": "Python/24", "test_setup": "", "test": ["assert binary_to_decimal(100) == 4", "assert binary_to_decimal(1011) == 11", "assert binary_to_decimal(1101101) == 109"], "challenge_test_list": [], "func_title": "def binary_to_decimal(binary): \r", "prompt_text_chinese": "写一个函数，将给定的二进制数转换为十进制数。", "code_comment": "定义一个二进制转十进制的函数，参数为待转换的二进制数binary\n备份输入的二进制数\n初始化十进制数decimal、指数i和位数n\n当二进制数不等于0时，进行循环\n取出二进制数的最后一位\n将取出的二进制数转换为十进制数，并加到decimal中\n将二进制数右移一位\n指数加1\n返回转换后的十进制数\n"}
{"prompt": "Write a python function to find the product of non-repeated elements in a given array.", "canonical_solution": "def find_Product(arr,n): \r\n    arr.sort() \r\n    prod = 1\r\n    for i in range(0,n,1): \r\n        if (arr[i - 1] != arr[i]): \r\n            prod = prod * arr[i] \r\n    return prod; ", "task_id": "Python/25", "test_setup": "", "test": ["assert find_Product([1,1,2,3],4) == 6", "assert find_Product([1,2,3,1,1],5) == 6", "assert find_Product([1,1,4,5,6],5) == 120"], "challenge_test_list": ["assert find_Product([1,1,4,5,6,5,7,1,1,3,4],11) == 2520"], "func_title": "def find_Product(arr,n): \r", "prompt_text_chinese": "写一个Python函数来查找给定数组中非重复元素的积。", "code_comment": "定义一个计算数组中不同元素之积的函数，参数为待计算的数组arr和数组长度n\n对数组进行排序\n初始化积为1\n遍历数组中的每一个元素\n如果当前元素与前一个元素不相等，则将当前元素乘到prod中\n返回不同元素之积"}
{"prompt": "Write a function to check if the given tuple list has all k elements.", "canonical_solution": "def check_k_elements(test_list, K):\r\n  res = True\r\n  for tup in test_list:\r\n    for ele in tup:\r\n      if ele != K:\r\n        res = False\r\n  return (res) ", "task_id": "Python/26", "test_setup": "", "test": ["assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True", "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True", "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False"], "challenge_test_list": ["assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 6, 4), (4, )], 4) == False"], "func_title": "def check_k_elements(test_list, K):\r", "prompt_text_chinese": "写一个函数来检查给定的元组列表是否有全部k个元素。", "code_comment": "定义一个检查二元组中元素是否全为K的函数，参数为待检查的二元组列表test_list和给定的K\n初始化标记res为True，表示所有元素都为K\n遍历二元组列表中的每一组二元组\n遍历当前二元组中的每一个元素\n如果当前元素不为K，则说明当前二元组中有元素不为K，将标记res设为False\n返回标记res"}
{"prompt": "Write a python function to remove all digits from a list of strings.", "canonical_solution": "import re  \r\ndef remove(list): \r\n    pattern = '[0-9]'\r\n    list = [re.sub(pattern, '', i) for i in list] \r\n    return list", "task_id": "Python/27", "test_setup": "", "test": ["assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']", "assert remove(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']", "assert remove(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']"], "challenge_test_list": [], "func_title": "def remove(list): \r", "prompt_text_chinese": "写一个Python函数，从一个字符串列表中删除所有数字。", "code_comment": "导入re模块\n定义一个去除列表中所有字符串中数字的函数，参数为待处理的列表list\n定义一个正则表达式，匹配所有数字\n使用列表推导式，将列表中所有字符串中的数字替换为空字符串\n返回处理后的列表"}
{"prompt": "Write a python function to find binomial co-efficient.", "canonical_solution": "def binomial_Coeff(n,k): \r\n    if k > n : \r\n       return 0\r\n    if k==0 or k ==n : \r\n        return 1 \r\n    return binomial_Coeff(n-1,k-1) + binomial_Coeff(n-1,k) ", "task_id": "Python/28", "test_setup": "", "test": ["assert binomial_Coeff(5,2) == 10", "assert binomial_Coeff(4,3) == 4", "assert binomial_Coeff(3,2) == 3"], "challenge_test_list": ["assert binomial_Coeff(14,6) == 3003"], "func_title": "def binomial_Coeff(n,k): \r", "prompt_text_chinese": "写一个Python函数来查找二项式系数。", "code_comment": "定义一个求二项式系数的函数，参数为n和k\n如果k大于n，则返回0，因为计算无法进行\n如果k等于0或n，则返回1，因为其对应的二项式系数为1\n如果k既不等于0也不等于n，则递归调用binomial_Coeff(n-1,k-1)和binomial_Coeff(n-1,k)计算二项式系数\n"}
{"prompt": "Write a python function to find the element occurring odd number of times.", "canonical_solution": "def get_Odd_Occurrence(arr,arr_size):   \r\n    for i in range(0,arr_size): \r\n        count = 0\r\n        for j in range(0,arr_size): \r\n            if arr[i] == arr[j]: \r\n                count+=1     \r\n        if (count % 2 != 0): \r\n            return arr[i]     \r\n    return -1", "task_id": "Python/29", "test_setup": "", "test": ["assert get_Odd_Occurrence([1,2,3,1,2,3,1],7) == 1", "assert get_Odd_Occurrence([1,2,3,2,3,1,3],7) == 3", "assert get_Odd_Occurrence([2,3,5,4,5,2,4,3,5,2,4,4,2],13) == 5"], "challenge_test_list": [], "func_title": "def get_Odd_Occurrence(arr,arr_size):   \r", "prompt_text_chinese": "写一个Python函数来寻找出现次数为奇数的元素。", "code_comment": "定义一个获取数组中出现奇数次的元素的函数，参数为待处理的数组arr和数组长度arr_size\n遍历数组中的每一个元素\n初始化计数器count为0\n遍历数组中的每一个元素，并将与当前元素相等的元素个数加到count中\n如果有元素出现奇数次，则返回该元素\n如果所有元素都出现偶数次，则返回-1"}
{"prompt": "Write a python function to count all the substrings starting and ending with same characters.", "canonical_solution": "def check_Equality(s): \r\n    return (ord(s[0]) == ord(s[len(s) - 1])); \r\ndef count_Substring_With_Equal_Ends(s): \r\n    result = 0; \r\n    n = len(s); \r\n    for i in range(n): \r\n        for j in range(1,n-i+1):  \r\n            if (check_Equality(s[i:i+j])): \r\n                result+=1; \r\n    return result; ", "task_id": "Python/30", "test_setup": "", "test": ["assert count_Substring_With_Equal_Ends(\"abc\") == 3", "assert count_Substring_With_Equal_Ends(\"abcda\") == 6", "assert count_Substring_With_Equal_Ends(\"ab\") == 2"], "challenge_test_list": [], "func_title": "def check_Equality(s): \r", "prompt_text_chinese": "写一个Python函数来计算所有以相同字符开始和结束的子字符串。", "code_comment": "定义一个检查字符串首尾字符是否相等的函数，参数为待检查的字符串s\n返回首尾字符是否相等的判断结果\n定义一个计算所有字串中首尾字符相等的数量的函数，参数为待计算的字符串s\n初始化计数器为0\n获取字符串长度n\n遍历字符串中的每一个字符\n遍历以i为起点的所有子串\n如果当前子串的首尾字符相等，则将计数器加1\n返回所有字串中首尾字符相等的数量\n"}
{"prompt": "Write a function to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.", "canonical_solution": "def func(nums, k):\r\n    import collections\r\n    d = collections.defaultdict(int)\r\n    for row in nums:\r\n        for i in row:\r\n            d[i] += 1\r\n    temp = []\r\n    import heapq\r\n    for key, v in d.items():\r\n        if len(temp) < k:\r\n            temp.append((v, key))\r\n            if len(temp) == k:\r\n                heapq.heapify(temp)\r\n        else:\r\n            if v > temp[0][0]:\r\n                heapq.heappop(temp)\r\n                heapq.heappush(temp, (v, key))\r\n    result = []\r\n    while temp:\r\n        v, key = heapq.heappop(temp)\r\n        result.append(key)\r\n    return result", "task_id": "Python/31", "test_setup": "", "test": ["assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]", "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],1)==[1]", "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],5)==[6, 5, 7, 8, 1]"], "challenge_test_list": [], "func_title": "def func(nums, k):\r", "prompt_text_chinese": "写一个函数，使用堆队列算法，从给定的分类和不同的整数列表中找出出现频率最高的k个整数。", "code_comment": "定义一个取二维数组中出现次数最多的前k个元素的函数，参数为待处理的二维数组nums和需要返回的元素个数k\n创建一个默认值为0的字典d\n遍历二维数组中的每一行\n遍历当前行中的每一个元素\n将当前元素的出现次数加1\n定义一个用于保存前k个出现次数最多的元素的列表\n遍历字典中的每一个键值对\n如果当前已经找到的元素个数小于k，则将当前元素加入temp中\n如果temp已满，则将temp中的元素转化为小根堆\n如果当前元素的出现次数大于temp中最小的元素的出现次数，则将temp中的最小元素弹出，并将当前元素加入temp中\n定义一个用于保存结果的列表\n遍历temp中的所有元素\n弹出temp中的最小元素\n将弹出的元素的键加入结果列表中\n返回前k个出现次数最多的元素的键组成的列表"}
{"prompt": "Write a python function to find the largest prime factor of a given number.", "canonical_solution": "import math \r\ndef max_Prime_Factors (n): \r\n    maxPrime = -1 \r\n    while n%2 == 0: \r\n        maxPrime = 2\r\n        n >>= 1    \r\n    for i in range(3,int(math.sqrt(n))+1,2): \r\n        while n % i == 0: \r\n            maxPrime = i \r\n            n = n / i \r\n    if n > 2: \r\n        maxPrime = n  \r\n    return int(maxPrime)", "task_id": "Python/32", "test_setup": "", "test": ["assert max_Prime_Factors(15) == 5", "assert max_Prime_Factors(6) == 3", "assert max_Prime_Factors(2) == 2"], "challenge_test_list": [], "func_title": "def max_Prime_Factors (n): \r", "prompt_text_chinese": "写一个python函数来寻找一个给定数字的最大质因数。", "code_comment": "导入math模块\n定义一个求给定数的最大质因子的函数，参数为待求解的数n\n初始化最大质因子为-1\n如果n是2的倍数，则不断将其除以2，并将2赋值给maxPrime\n从3到int(math.sqrt(n)) + 1的范围内遍历所有奇数i\n如果n是i的倍数，则不断将其除以i，并将i赋值给maxPrime\n如果n大于2，则将n赋值给maxPrime\n返回最大质因子"}
{"prompt": "Write a python function to convert a decimal number to binary number.", "canonical_solution": "def decimal_To_Binary(N): \r\n    B_Number = 0\r\n    cnt = 0\r\n    while (N != 0): \r\n        rem = N % 2\r\n        c = pow(10,cnt)  \r\n        B_Number += rem*c  \r\n        N //= 2 \r\n        cnt += 1\r\n    return B_Number  ", "task_id": "Python/33", "test_setup": "", "test": ["assert decimal_To_Binary(10) == 1010", "assert decimal_To_Binary(1) == 1", "assert decimal_To_Binary(20) == 10100"], "challenge_test_list": [], "func_title": "def decimal_To_Binary(N): \r", "prompt_text_chinese": "编写一个Python函数，将十进制数转换成二进制数。", "code_comment": "定义一个将十进制数转换为二进制数的函数，参数为待转换的十进制数N\n初始化二进制数为0\n初始化指数为0\n当N不等于0时，进行循环\n取N除以2的余数\n计算10的cnt次方\n将余数乘以10的cnt次方，加到B_Number上\n将N整除以2\n指数加1\n返回二进制数"}
{"prompt": "Write a python function to find the missing number in a sorted array.", "canonical_solution": "def find_missing(ar,N): \r\n    l = 0\r\n    r = N - 1\r\n    while (l <= r):  \r\n        mid = (l + r) / 2\r\n        mid= int (mid) \r\n        if (ar[mid] != mid + 1 and ar[mid - 1] == mid): \r\n            return (mid + 1)  \r\n        elif (ar[mid] != mid + 1): \r\n            r = mid - 1 \r\n        else: \r\n            l = mid + 1\r\n    return (-1) ", "task_id": "Python/34", "test_setup": "", "test": ["assert find_missing([1,2,3,5],4) == 4", "assert find_missing([1,3,4,5],4) == 2", "assert find_missing([1,2,3,5,6,7],5) == 4"], "challenge_test_list": [], "func_title": "def find_missing(ar,N): \r", "prompt_text_chinese": "写一个Python函数来查找一个排序数组中缺少的数字。", "code_comment": "定义一个在有序数组中查找缺失元素的函数，参数为有序数组ar和数组长度N\n初始化左指针为0\n初始化右指针为N-1\n当左指针小于等于右指针时进行循环\n计算中间位置\n将mid转化为整数\n如果当前元素不等于其下标加1，且前一个元素等于其下标，则说明当前元素是缺失的元素\n如果当前元素不等于其下标加1，则说明缺失的元素在左半部分\n如果当前元素等于其下标加1，则说明缺失的元素在右半部分\n如果整个数组都被检查过了，仍然没有找到缺失的元素，则返回-1"}
{"prompt": "Write a function to find the n-th rectangular number.", "canonical_solution": "def find_rect_num(n):\r\n  return n*(n + 1) ", "task_id": "Python/35", "test_setup": "", "test": ["assert find_rect_num(4) == 20", "assert find_rect_num(5) == 30", "assert find_rect_num(6) == 42"], "challenge_test_list": [], "func_title": "def find_rect_num(n):\r", "prompt_text_chinese": "写一个函数来寻找第n个长方形数字。", "code_comment": "定义一个计算n阶矩阵中子矩阵数量的函数，参数为矩阵的阶数n\n返回子矩阵数量"}
{"prompt": "Write a python function to find the nth digit in the proper fraction of two given numbers.", "canonical_solution": "def find_Nth_Digit(p,q,N) :  \r\n    while (N > 0) : \r\n        N -= 1;  \r\n        p *= 10;  \r\n        res = p // q;  \r\n        p %= q;  \r\n    return res;  ", "task_id": "Python/36", "test_setup": "", "test": ["assert find_Nth_Digit(1,2,1) == 5", "assert find_Nth_Digit(3,5,1) == 6", "assert find_Nth_Digit(5,6,5) == 3"], "challenge_test_list": [], "func_title": "def find_Nth_Digit(p,q,N) :  \r", "prompt_text_chinese": "写一个Python函数，找出两个给定数字的适当分数中的第n个数字。", "code_comment": "定义一个查找p/q的小数表示中第N位数字的函数，参数为分数p/q和需要查找的位数N\n当需要查找的位数大于0时进行循环\n将需要查找的位数减1\n将分子乘以10，以便进行整除\n将分子整除以分母，得到商\n将分子对分母取余数\n返回查找到的数字"}
{"prompt": "Write a function to sort a given mixed list of integers and strings.", "canonical_solution": "def sort_mixed_list(mixed_list):\r\n    int_part = sorted([i for i in mixed_list if type(i) is int])\r\n    str_part = sorted([i for i in mixed_list if type(i) is str])\r\n    return int_part + str_part", "task_id": "Python/37", "test_setup": "", "test": ["assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']", "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']", "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']"], "challenge_test_list": [], "func_title": "def sort_mixed_list(mixed_list):\r", "prompt_text_chinese": "写一个函数，对给定的整数和字符串的混合列表进行排序。", "code_comment": "定义一个将混合类型列表中的整数部分和字符串部分分别排序，并将它们合并为一个新列表的函数，参数为混合类型列表mixed_list\n将mixed_list中类型为整数的元素提取出来，并进行排序\n将mixed_list中类型为字符串的元素提取出来，并进行排序\n返回排序后的整数部分和字符串部分组成的新列表"}
{"prompt": "Write a function to find the division of first even and odd number of a given list.", "canonical_solution": "def div_even_odd(list1):\r\n    first_even = next((el for el in list1 if el%2==0),-1)\r\n    first_odd = next((el for el in list1 if el%2!=0),-1)\r\n    return (first_even/first_odd)", "task_id": "Python/38", "test_setup": "", "test": ["assert div_even_odd([1,3,5,7,4,1,6,8])==4", "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2", "assert div_even_odd([1,5,7,9,10])==10"], "challenge_test_list": [], "func_title": "def div_even_odd(list1):\r", "prompt_text_chinese": "写一个函数，找出给定列表中第一个偶数和奇数的除数。", "code_comment": "定义一个计算列表中第一个偶数和第一个奇数商的函数，参数为待处理的列表list1\n从list1中查找第一个偶数\n从list1中查找第一个奇数\n返回第一个偶数和第一个奇数的商"}
{"prompt": "Write a function to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.", "canonical_solution": "import heapq\r\nfrom collections import Counter\r\ndef rearange_string(S):\r\n    ctr = Counter(S)\r\n    heap = [(-value, key) for key, value in ctr.items()]\r\n    heapq.heapify(heap)\r\n    if (-heap[0][0]) * 2 > len(S) + 1: \r\n        return \"\"\r\n    ans = []\r\n    while len(heap) >= 2:\r\n        nct1, char1 = heapq.heappop(heap)\r\n        nct2, char2 = heapq.heappop(heap)\r\n        ans.extend([char1, char2])\r\n        if nct1 + 1: heapq.heappush(heap, (nct1 + 1, char1))\r\n        if nct2 + 1: heapq.heappush(heap, (nct2 + 1, char2))\r\n    return \"\".join(ans) + (heap[0][1] if heap else \"\")", "task_id": "Python/39", "test_setup": "", "test": ["assert rearange_string(\"aab\")==('aba')", "assert rearange_string(\"aabb\")==('abab')", "assert rearange_string(\"abccdd\")==('cdabcd')"], "challenge_test_list": [], "func_title": "def rearange_string(S):\r", "prompt_text_chinese": "写一个函数，检查给定字符串的字母是否可以重新排列，使相邻的两个字符不同。", "code_comment": "导入heapq和Counter模块\n定义一个重排字符串的函数，参数为待重排的字符串S\n统计S中每个字符出现的次数\n将统计结果转化为一个元组列表，并将每个元组的第一个元素取相反数\n将元组列表转化为小根堆\n如果堆顶元素的出现次数超过S的长度的一半加1，则无法重排\n定义一个用于保存重排后字符的列表\n当堆中元素的数量大于等于2时进行循环\n弹出堆中出现次数最大的字符\n弹出堆中出现次数次大的字符\n将这两个字符交替添加到结果列表中\n如果第一个字符没有被添加完，则将其重新加入堆中\n如果第二个字符没有被添加完，则将其重新加入堆中\n将结果列表中的字符组成字符串，并将堆中剩余的字符添加在其后面，最后返回新的字符串"}
{"prompt": "Write a function to find frequency of the elements in a given list of lists using collections module.", "canonical_solution": "from collections import Counter\r\nfrom itertools import chain\r\ndef freq_element(nums):\r\n  result = Counter(chain.from_iterable(nums))\r\n  return result", "task_id": "Python/40", "test_setup": "", "test": ["assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})", "assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})", "assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})"], "challenge_test_list": [], "func_title": "def freq_element(nums):\r", "prompt_text_chinese": "写一个函数，使用集合模块查找给定列表中元素的频率。", "code_comment": "定义一个过滤列表中偶数的函数，参数为待过滤的列表nums\n使用filter函数和lambda表达式从nums中筛选出偶数，并将它们添加到一个新的列表even_nums中\n返回过滤后的偶数列表\n"}
{"prompt": "Write a function to filter even numbers using lambda function.", "canonical_solution": "def filter_evennumbers(nums):\r\n even_nums = list(filter(lambda x: x%2 == 0, nums))\r\n return even_nums", "task_id": "Python/41", "test_setup": "", "test": ["assert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[2, 4, 6, 8, 10]", "assert filter_evennumbers([10,20,45,67,84,93])==[10,20,84]", "assert filter_evennumbers([5,7,9,8,6,4,3])==[8,6,4]"], "challenge_test_list": [], "func_title": "def filter_evennumbers(nums):\r", "prompt_text_chinese": "用lambda函数写一个过滤偶数的函数。", "code_comment": "定义一个过滤列表中偶数的函数，参数为待过滤的列表nums\n使用filter函数和lambda表达式从nums中筛选出偶数，并将它们添加到一个新的列表even_nums中\n返回过滤后的偶数列表\n"}
{"prompt": "Write a python function to find the sum of repeated elements in a given array.", "canonical_solution": "def find_Sum(arr,n): \r\n    return sum([x for x in arr if arr.count(x) > 1])", "task_id": "Python/42", "test_setup": "", "test": ["assert find_Sum([1,2,3,1,1,4,5,6],8) == 3", "assert find_Sum([1,2,3,1,1],5) == 3", "assert find_Sum([1,1,2],3) == 2"], "challenge_test_list": ["assert find_Sum([1,1,2,3,4,5,6,3,5],9) == 18"], "func_title": "def find_Sum(arr,n): \r", "prompt_text_chinese": "写一个Python函数来寻找给定数组中重复元素的总和。", "code_comment": "定义一个查找列表中重复数字之和的函数，参数为待处理的列表arr和列表长度n\n使用列表推导式筛选出在arr中出现次数大于1的数字，并将它们求和"}
{"prompt": "Write a function to find sequences of lowercase letters joined with an underscore using regex.", "canonical_solution": "import re\r\ndef text_match(text):\r\n  patterns = '^[a-z]+_[a-z]+$'\r\n  if re.search(patterns,  text):\r\n    return ('Found a match!')\r\n  else:\r\n    return ('Not matched!')", "task_id": "Python/43", "test_setup": "", "test": ["assert text_match(\"aab_cbbbc\") == 'Found a match!'", "assert text_match(\"aab_Abbbc\") == 'Not matched!'", "assert text_match(\"Aaab_abbbc\") == 'Not matched!'"], "challenge_test_list": ["assert text_match(\"aab-cbbbc\") == 'Not matched!'"], "func_title": "def text_match(text):\r", "prompt_text_chinese": "写一个函数，使用regex查找与下划线相连的小写字母序列。", "code_comment": ""}
{"prompt": "Write a function that matches a word at the beginning of a string.", "canonical_solution": "import re\r\ndef text_match_string(text):\r\n        patterns = '^\\w+'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return 'Not matched!'", "task_id": "Python/44", "test_setup": "", "test": ["assert text_match_string(\" python\")==('Not matched!')", "assert text_match_string(\"python\")==('Found a match!')", "assert text_match_string(\"  lang\")==('Not matched!')"], "challenge_test_list": ["assert text_match_string(\"foo\")==('Found a match!')"], "func_title": "def text_match_string(text):\r", "prompt_text_chinese": "写一个函数，在一个字符串的开头匹配一个单词。", "code_comment": "导入re模块；\n定义一个名为text_match_string的函数，参数为待检查的字符串text；\n定义一个正则表达式模式，用于匹配以单词开头的字符串；\n使用re.search函数检查text是否符合patterns的模式；\n如果符合，则返回字符串\"Found a match!\"；\n如果不符合，则返回字符串\"Not matched!\"。"}
{"prompt": "Write a function to find the gcd of the given array elements.", "canonical_solution": "def find_gcd(x, y): \r\n\twhile(y): \r\n\t\tx, y = y, x % y \r\n\treturn x \r\ndef get_gcd(l):\r\n  num1 = l[0]\r\n  num2 = l[1]\r\n  gcd = find_gcd(num1, num2)\r\n  for i in range(2, len(l)):\r\n    gcd = find_gcd(gcd, l[i])\r\n  return gcd", "task_id": "Python/45", "test_setup": "", "test": ["assert get_gcd([2, 4, 6, 8, 16]) == 2", "assert get_gcd([1, 2, 3]) == 1", "assert get_gcd([2, 4, 6, 8]) == 2 "], "challenge_test_list": [], "func_title": "def find_gcd(x, y): \r", "prompt_text_chinese": "写一个函数来寻找给定数组元素的gcd。", "code_comment": "定义一个求两个数最大公约数的函数，参数为两个待求最大公约数的整数x和y\n使用辗转相除法求出x和y的最大公约数\n定义一个求多个数最大公约数的函数，参数为包含多个整数的列表l\n从列表中取出第一个数\n从列表中取出第二个数\n使用find_gcd函数求出num1和num2的最大公约数\n循环遍历列表中的其它数\n使用find_gcd函数求出当前数和已求出的最大公约数的最大公约数\n返回列表中所有数的最大公约数"}
{"prompt": "Write a python function to determine whether all the numbers are different from each other are not.", "canonical_solution": "def test_distinct(data):\r\n  if len(data) == len(set(data)):\r\n    return True\r\n  else:\r\n    return False;", "task_id": "Python/46", "test_setup": "", "test": ["assert test_distinct([1,5,7,9]) == True", "assert test_distinct([2,4,5,5,7,9]) == False", "assert test_distinct([1,2,3]) == True"], "challenge_test_list": [], "func_title": "def test_distinct(data):\r", "prompt_text_chinese": "写一个python函数来确定所有的数字是否彼此不同。", "code_comment": "定义一个名为test_distinct的函数，参数为data\n如果data中元素的个数等于去重后的元素个数\n返回True\n否则返回False\n"}
{"prompt": "Write a python function to find the last digit when factorial of a divides factorial of b.", "canonical_solution": "def compute_Last_Digit(A,B): \r\n    variable = 1\r\n    if (A == B): \r\n        return 1\r\n    elif ((B - A) >= 5):  \r\n        return 0\r\n    else:   \r\n        for i in range(A + 1,B + 1): \r\n            variable = (variable * (i % 10)) % 10\r\n        return variable % 10", "task_id": "Python/47", "test_setup": "", "test": ["assert compute_Last_Digit(2,4) == 2", "assert compute_Last_Digit(6,8) == 6", "assert compute_Last_Digit(1,2) == 2"], "challenge_test_list": ["assert compute_Last_Digit(3,7) == 0", "assert compute_Last_Digit(20,23) == 6", "assert compute_Last_Digit(1021,1024) == 4"], "func_title": "def compute_Last_Digit(A,B): \r", "prompt_text_chinese": "写一个python函数，当a的阶乘除以b的阶乘时，找出最后一位数字。", "code_comment": "定义一个名为compute_Last_Digit的函数，参数为A和B\n定义一个变量variable，并初始化为1\n如果A等于B\n返回1\n如果B减A大于等于5\n返回0\n循环从A+1到B+1\n将变量variable乘上当前i对10的余数，再对10取余\n最后将variable对10取余并返回\n"}
{"prompt": "Write a python function to set all odd bits of a given number.", "canonical_solution": "def odd_bit_set_number(n):\r\n    count = 0;res = 0;temp = n\r\n    while temp > 0:\r\n        if count % 2 == 0:\r\n            res |= (1 << count)\r\n        count += 1\r\n        temp >>= 1\r\n    return (n | res)", "task_id": "Python/48", "test_setup": "", "test": ["assert odd_bit_set_number(10) == 15", "assert odd_bit_set_number(20) == 21", "assert odd_bit_set_number(30) == 31"], "challenge_test_list": [], "func_title": "def odd_bit_set_number(n):\r", "prompt_text_chinese": "写一个Python函数来设置一个给定数字的所有奇数位。", "code_comment": "定义一个名为odd_bit_set_number的函数，参数为n\n定义count、res、temp三个变量，并初始化count和res为0，temp为n\n循环，当temp大于0时\n如果count是偶数\n将res的第count位设置为1\ncount加1\n将temp右移1位，相当于temp除以2\n返回n和res的按位或操作结果\n"}
{"prompt": "Write a function to extract every first or specified element from a given two-dimensional list.", "canonical_solution": "def specified_element(nums, N):\r\n    result = [i[N] for i in nums]\r\n    return result\r\n    ", "task_id": "Python/49", "test_setup": "", "test": ["assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]", "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]", "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],1)==[2,5,1]"], "challenge_test_list": [], "func_title": "def specified_element(nums, N):\r", "prompt_text_chinese": "写一个函数，从一个给定的二维列表中提取每个第一或指定的元素。", "code_comment": "定义一个名为specified_element的函数，参数为nums和N\n定义一个列表result，使用列表推导式从nums中每个子列表的第N个元素中获取值并添加到result中\n返回result\n"}
{"prompt": "Write a function to find the list with minimum length using lambda function.", "canonical_solution": "def min_length_list(input_list):\r\n    min_length = min(len(x) for x in input_list )  \r\n    min_list = min(input_list, key = lambda i: len(i))\r\n    return(min_length, min_list)", "task_id": "Python/50", "test_setup": "", "test": ["assert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(1, [0])", "assert min_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(1,[1])", "assert min_length_list([[3,4,5],[6,7,8,9],[10,11,12],[1,2]])==(2,[1,2])"], "challenge_test_list": [], "func_title": "def min_length_list(input_list):\r", "prompt_text_chinese": "写一个函数，用lambda函数找到长度最小的列表。", "code_comment": "定义一个名为min_length_list的函数，参数为input_list\n获取所有子列表中的最小长度\n获取长度最小的子列表\n返回最小长度和长度最小的子列表\n"}
{"prompt": "Write a function to print check if the triangle is equilateral or not.", "canonical_solution": "def check_equilateral(x,y,z):\r\n  if x == y == z:\r\n\t   return True\r\n  else:\r\n     return False", "task_id": "Python/51", "test_setup": "", "test": ["assert check_equilateral(6,8,12)==False ", "assert check_equilateral(6,6,12)==False", "assert check_equilateral(6,6,6)==True"], "challenge_test_list": [], "func_title": "def check_equilateral(x,y,z):\r", "prompt_text_chinese": "写一个函数来打印检查三角形是否为等边三角形。", "code_comment": "定义一个名为check_equilateral的函数，参数为x、y、z\n判断x、y、z是否都相等\n如果都相等，返回True\n如果不都相等，返回False\n"}
{"prompt": "Write a function to caluclate area of a parallelogram.", "canonical_solution": "def parallelogram_area(b,h):\r\n  area=b*h\r\n  return area", "task_id": "Python/52", "test_setup": "", "test": ["assert parallelogram_area(10,20)==200", "assert parallelogram_area(15,20)==300", "assert parallelogram_area(8,9)==72"], "challenge_test_list": [], "func_title": "def parallelogram_area(b,h):\r", "prompt_text_chinese": "写一个函数来计算平行四边形的面积。", "code_comment": "定义一个名为parallelogram_area的函数，参数为b、h\n计算平行四边形的面积\n返回面积\n"}
{"prompt": "Write a python function to check whether the first and last characters of a given string are equal or not.", "canonical_solution": "def check_Equality(str):\r\n  if (str[0] == str[-1]):  \r\n    return (\"Equal\") \r\n  else:  \r\n    return (\"Not Equal\") ", "task_id": "Python/53", "test_setup": "", "test": ["assert check_Equality(\"abcda\") == \"Equal\"", "assert check_Equality(\"ab\") == \"Not Equal\"", "assert check_Equality(\"mad\") == \"Not Equal\""], "challenge_test_list": [], "func_title": "def check_Equality(str):\r", "prompt_text_chinese": "写一个Python函数，检查给定字符串的第一个和最后一个字符是否相等。", "code_comment": "定义一个名为check_Equality的函数，参数为str\n判断字符串的第一个字符和最后一个字符是否相等\n如果相等，返回\"Equal\"\n如果不相等，返回\"Not Equal\"\n"}
{"prompt": "Write a function to sort the given array by using counting sort.", "canonical_solution": "def counting_sort(my_list):\r\n    max_value = 0\r\n    for i in range(len(my_list)):\r\n        if my_list[i] > max_value:\r\n            max_value = my_list[i]\r\n    buckets = [0] * (max_value + 1)\r\n    for i in my_list:\r\n        buckets[i] += 1\r\n    i = 0\r\n    for j in range(max_value + 1):\r\n         for a in range(buckets[j]):\r\n             my_list[i] = j\r\n             i += 1\r\n    return my_list", "task_id": "Python/54", "test_setup": "", "test": ["assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]", "assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]", "assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]"], "challenge_test_list": [], "func_title": "def counting_sort(my_list):\r", "prompt_text_chinese": "写一个函数，通过计数排序对给定数组进行排序。", "code_comment": "定义一个名为counting_sort的函数，参数为my_list\n找出my_list中的最大值\n创建桶buckets，长度为max_value+1，初始值都为0\n将my_list中每个元素出现的次数放入对应的桶中\n将排序后的元素放回原来的列表中\n返回排序后的列表\n"}
{"prompt": "Write a function to find t-nth term of geometric series.", "canonical_solution": "import math\r\ndef tn_gp(a,n,r):\r\n  tn = a * (math.pow(r, n - 1))\r\n  return tn", "task_id": "Python/55", "test_setup": "", "test": ["assert tn_gp(1,5,2)==16", "assert tn_gp(1,5,4)==256", "assert tn_gp(2,6,3)==486"], "challenge_test_list": [], "func_title": "def tn_gp(a,n,r):\r", "prompt_text_chinese": "写一个函数来寻找几何数列的第t-n项。", "code_comment": "导入math库\n定义一个名为tn_gp的函数，参数为a、n、r\n根据等比数列通项公式计算出第n项的值\n返回第n项的值\n"}
{"prompt": "Write a python function to check if a given number is one less than twice its reverse.", "canonical_solution": "def rev(num):    \r\n    rev_num = 0\r\n    while (num > 0):  \r\n        rev_num = (rev_num * 10 + num % 10) \r\n        num = num // 10  \r\n    return rev_num  \r\ndef check(n):    \r\n    return (2 * rev(n) == n + 1)  ", "task_id": "Python/56", "test_setup": "", "test": ["assert check(70) == False", "assert check(23) == False", "assert check(73) == True"], "challenge_test_list": [], "func_title": "def rev(num):    \r", "prompt_text_chinese": "写一个python函数来检查一个给定的数字是否比其反向的两倍少一个。", "code_comment": "定义一个名为rev的函数，参数为num\n定义一个变量rev_num并初始化为0\n循环，当num大于0时\n将rev_num乘以10加上num对10的余数，得到翻转后的结果\nnum整除10，相当于去掉num的个位数\n返回翻转后的结果\n定义一个名为check的函数，参数为n\n如果2倍翻转后的n等于n加1，返回True，否则返回False\n"}
{"prompt": "Write a python function to find the largest number that can be formed with the given digits.", "canonical_solution": "def find_Max_Num(arr,n) : \r\n    arr.sort(reverse = True) \r\n    num = arr[0] \r\n    for i in range(1,n) : \r\n        num = num * 10 + arr[i] \r\n    return num ", "task_id": "Python/57", "test_setup": "", "test": ["assert find_Max_Num([1,2,3],3) == 321", "assert find_Max_Num([4,5,6,1],4) == 6541", "assert find_Max_Num([1,2,3,9],4) == 9321"], "challenge_test_list": [], "func_title": "def find_Max_Num(arr,n) : \r", "prompt_text_chinese": "写一个Python函数，找出由给定数字组成的最大数字。", "code_comment": "定义一个名为find_Max_Num的函数，参数为arr和n\n对arr进行降序排序\n获取排序后的第一个数字\n将剩余数字按顺序加到num的末尾，得到最大的数字\n返回最大的数字\n"}
{"prompt": "Write a python function to check whether the given two integers have opposite sign or not.", "canonical_solution": "def opposite_Signs(x,y): \r\n    return ((x ^ y) < 0); ", "task_id": "Python/58", "test_setup": "", "test": ["assert opposite_Signs(1,-2) == True", "assert opposite_Signs(3,2) == False", "assert opposite_Signs(-10,-10) == False"], "challenge_test_list": [], "func_title": "def opposite_Signs(x,y): \r", "prompt_text_chinese": "写一个python函数来检查给定的两个整数是否有相反的符号。", "code_comment": "定义一个名为opposite_Signs的函数，参数为x和y\n判断x和y的符号是否相反，如果相反返回True，否则返回False\n"}
{"prompt": "Write a function to find the nth octagonal number.", "canonical_solution": "def is_octagonal(n): \r\n\treturn 3 * n * n - 2 * n ", "task_id": "Python/59", "test_setup": "", "test": ["assert is_octagonal(5) == 65", "assert is_octagonal(10) == 280", "assert is_octagonal(15) == 645"], "challenge_test_list": [], "func_title": "def is_octagonal(n): \r", "prompt_text_chinese": "写一个函数来寻找第n个八角形的数字。", "code_comment": "定义一个名为is_octagonal的函数，参数为n\n根据八边形数的公式判断n是否为八边形数，是就返回True，否则返回False\n"}
{"prompt": "Write a function to find the maximum length of the subsequence with difference between adjacent elements for the given array.", "canonical_solution": "def max_len_sub( arr, n): \r\n\tmls=[] \r\n\tmax = 0\r\n\tfor i in range(n): \r\n\t\tmls.append(1) \r\n\tfor i in range(n): \r\n\t\tfor j in range(i): \r\n\t\t\tif (abs(arr[i] - arr[j]) <= 1 and mls[i] < mls[j] + 1): \r\n\t\t\t\tmls[i] = mls[j] + 1\r\n\tfor i in range(n): \r\n\t\tif (max < mls[i]): \r\n\t\t\tmax = mls[i] \r\n\treturn max", "task_id": "Python/60", "test_setup": "", "test": ["assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5", "assert max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7) == 4", "assert max_len_sub([9, 11, 13, 15, 18], 5) == 1"], "challenge_test_list": [], "func_title": "def max_len_sub( arr, n): \r", "prompt_text_chinese": "写一个函数，找出给定数组中相邻元素之间的最大长度的子序列。", "code_comment": "定义一个名为max_len_sub的函数，参数为arr和n\n定义一个空列表mls以及一个变量max并初始化为0\n给mls列表赋初值1\n循环遍历i从0到n-1\n循环遍历j从0到i-1\n如果arr[i]和arr[j]之差的绝对值小于等于1，且mls[i]小于mls[j]+1\n将mls[i]赋值为mls[j]+1\n循环遍历i从0到n-1\n如果max小于mls[i]\n将max赋值为mls[i]\n返回max作为最大长度\n"}
{"prompt": "Write a python function to count number of substrings with the sum of digits equal to their length.", "canonical_solution": "from collections import defaultdict\r\ndef count_Substrings(s,n):\r\n    count,sum = 0,0\r\n    mp = defaultdict(lambda : 0)\r\n    mp[0] += 1\r\n    for i in range(n):\r\n        sum += ord(s[i]) - ord('0')\r\n        count += mp[sum - (i + 1)]\r\n        mp[sum - (i + 1)] += 1\r\n    return count", "task_id": "Python/61", "test_setup": "", "test": ["assert count_Substrings('112112',6) == 6", "assert count_Substrings('111',3) == 6", "assert count_Substrings('1101112',7) == 12"], "challenge_test_list": [], "func_title": "def count_Substrings(s,n):\r", "prompt_text_chinese": "写一个python函数来计算数字之和等于其长度的子串的数量。", "code_comment": "导入collections库中的defaultdict函数\n定义一个名为count_Substrings的函数，参数为s和n\n定义计数变量count和和变量sum并初始化为0\n定义一个默认值为0的字典mp\n将mp[0]的值加1\n循环遍历i从0到n-1\n将sum加上s[i]的ASCII码值减去'0'的ASCII码值\n计算出sum-(i+1)的值，即s[0:i+1]子串中1的个数减0的个数\n将mp[sum - (i + 1)]的值加1\n返回计数变量count作为子串中有多少个子串中0和1的数量相等\n"}
{"prompt": "Write a python function to find smallest number in a list.", "canonical_solution": "def smallest_num(xs):\n  return min(xs)\n", "task_id": "Python/62", "test_setup": "", "test": ["assert smallest_num([10, 20, 1, 45, 99]) == 1", "assert smallest_num([1, 2, 3]) == 1", "assert smallest_num([45, 46, 50, 60]) == 45"], "challenge_test_list": [], "func_title": "def smallest_num(xs):", "prompt_text_chinese": "写一个Python函数来查找列表中最小的数字。", "code_comment": "定义一个名为smallest_num的函数，参数为xs\n返回xs中的最小值\n"}
{"prompt": "Write a function to find the maximum difference between available pairs in the given tuple list.", "canonical_solution": "def max_difference(test_list):\r\n  temp = [abs(b - a) for a, b in test_list]\r\n  res = max(temp)\r\n  return (res) ", "task_id": "Python/63", "test_setup": "", "test": ["assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7", "assert max_difference([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15", "assert max_difference([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23"], "challenge_test_list": [], "func_title": "def max_difference(test_list):\r", "prompt_text_chinese": "写一个函数，在给定的元组列表中找到可用对之间的最大差异。", "code_comment": "定义一个名为max_difference的函数，参数为test_list\n将test_list中每个元素两两之间的差的绝对值存储到temp列表中\n找到temp中的最大值\n返回最大值res\n"}
{"prompt": "Write a function to sort a list of tuples using lambda.", "canonical_solution": "def subject_marks(subjectmarks):\r\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\r\n subjectmarks.sort(key = lambda x: x[1])\r\n return subjectmarks", "task_id": "Python/64", "test_setup": "", "test": ["assert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])==[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]", "assert subject_marks([('Telugu',49),('Hindhi',54),('Social',33)])==([('Social',33),('Telugu',49),('Hindhi',54)])", "assert subject_marks([('Physics',96),('Chemistry',97),('Biology',45)])==([('Biology',45),('Physics',96),('Chemistry',97)])"], "challenge_test_list": [], "func_title": "def subject_marks(subjectmarks):\r", "prompt_text_chinese": "写一个函数，用lambda对一个元组列表进行排序。", "code_comment": "定义一个名为subject_marks的函数，参数为subjectmarks\nsubject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n按元组的第二个元素即分数从小到大排序\n返回排序后的结果\n"}
{"prompt": "Write a function of recursion list sum.", "canonical_solution": "def recursive_list_sum(data_list):\r\n\ttotal = 0\r\n\tfor element in data_list:\r\n\t\tif type(element) == type([]):\r\n\t\t\ttotal = total + recursive_list_sum(element)\r\n\t\telse:\r\n\t\t\ttotal = total + element\r\n\treturn total", "task_id": "Python/65", "test_setup": "", "test": ["assert recursive_list_sum(([1, 2, [3,4],[5,6]]))==21", "assert recursive_list_sum(([7, 10, [15,14],[19,41]]))==106", "assert recursive_list_sum(([10, 20, [30,40],[50,60]]))==210"], "challenge_test_list": [], "func_title": "def recursive_list_sum(data_list):\r", "prompt_text_chinese": "写一个递归列表和的函数。", "code_comment": "定义一个名为recursive_list_sum的函数，参数为data_list\n定义并初始化total为0\n遍历data_list中的每个元素\n如果当前元素的类型是list\n递归调用函数自身，并将返回值累加到total中\n否则如果当前元素的类型不是list\n将当前元素的值累加到total中\n返回total，即data_list中所有元素的和\n"}
{"prompt": "Write a python function to count positive numbers in a list.", "canonical_solution": "def pos_count(list):\r\n  pos_count= 0\r\n  for num in list: \r\n    if num >= 0: \r\n      pos_count += 1\r\n  return pos_count ", "task_id": "Python/66", "test_setup": "", "test": ["assert pos_count([1,-2,3,-4]) == 2", "assert pos_count([3,4,5,-1]) == 3", "assert pos_count([1,2,3,4]) == 4"], "challenge_test_list": [], "func_title": "def pos_count(list):\r", "prompt_text_chinese": "写一个Python函数来计算一个列表中的正数。", "code_comment": "定义一个名为pos_count的函数，参数为list\n定义并初始化计数器pos_count为0\n循环遍历list中的每个元素\n如果当前元素的值大于等于0\n将计数器pos_count的值加1\n返回pos_count，即列表中大于等于0的元素的个数\n"}
{"prompt": "Write a function to find the number of ways to partition a set of bell numbers.", "canonical_solution": "def bell_number(n):   \r\n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \r\n    bell[0][0] = 1\r\n    for i in range(1, n+1): \r\n        bell[i][0] = bell[i-1][i-1]  \r\n        for j in range(1, i+1): \r\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \r\n    return bell[n][0] ", "task_id": "Python/67", "test_setup": "", "test": ["assert bell_number(2)==2", "assert bell_number(10)==115975", "assert bell_number(56)==6775685320645824322581483068371419745979053216268760300"], "challenge_test_list": [], "func_title": "def bell_number(n):   \r", "prompt_text_chinese": "写一个函数，找出划分一组钟形数字的方法。", "code_comment": "定义一个名为bell_number的函数，参数为n\n生成一个n+1*n+1的二维列表并初始化为0\n将bell[0][0]的值赋为1\n循环遍历i从1到n\n将bell[i][0]的值赋为bell[i-1][i-1]\n循环遍历j从1到i\n计算bell[i][j]的值，即上一个数（i-1）行，同一列（j-1）的值+上一行同一列（j）的值\n返回bell[n][0]，即Bell数\n"}
{"prompt": "Write a python function to check whether the given array is monotonic or not.", "canonical_solution": "def is_Monotonic(A): \r\n    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\r\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1))) ", "task_id": "Python/68", "test_setup": "", "test": ["assert is_Monotonic([6, 5, 4, 4]) == True", "assert is_Monotonic([1, 2, 2, 3]) == True", "assert is_Monotonic([1, 3, 2]) == False"], "challenge_test_list": [], "func_title": "def is_Monotonic(A): \r", "prompt_text_chinese": "写一个python函数来检查给定的数组是否是单调的。", "code_comment": "定义一个名为is_Monotonic的函数，参数为A\n检查A是否单调递增或单调递减，如果是则返回True，否则返回False\n"}
{"prompt": "Write a function to check whether a list contains the given sublist or not.", "canonical_solution": "def is_sublist(l, s):\r\n\tsub_set = False\r\n\tif s == []:\r\n\t\tsub_set = True\r\n\telif s == l:\r\n\t\tsub_set = True\r\n\telif len(s) > len(l):\r\n\t\tsub_set = False\r\n\telse:\r\n\t\tfor i in range(len(l)):\r\n\t\t\tif l[i] == s[0]:\r\n\t\t\t\tn = 1\r\n\t\t\t\twhile (n < len(s)) and (l[i+n] == s[n]):\r\n\t\t\t\t\tn += 1\t\t\t\t\r\n\t\t\t\tif n == len(s):\r\n\t\t\t\t\tsub_set = True\r\n\treturn sub_set", "task_id": "Python/69", "test_setup": "", "test": ["assert is_sublist([2,4,3,5,7],[3,7])==False", "assert is_sublist([2,4,3,5,7],[4,3])==True", "assert is_sublist([2,4,3,5,7],[1,6])==False"], "challenge_test_list": [], "func_title": "def is_sublist(l, s):\r", "prompt_text_chinese": "写一个函数来检查一个列表是否包含给定的子列表。", "code_comment": "定义一个名为find_equal_tuple的函数，参数为Input和k\n定义变量flag并初始化为1\n遍历Input中的每个元素\n如果当前元素的长度不等于k\n将flag设为0\n返回flag\n定义一个名为get_equal的函数，参数为Input和k\n如果Input中所有元素的长度都是k\n返回\"All tuples have same length\"\n否则返回\"All tuples do not have same length\"\n"}
{"prompt": "Write a function to find whether all the given tuples have equal length or not.", "canonical_solution": "def find_equal_tuple(Input, k):\r\n  flag = 1\r\n  for tuple in Input:\r\n    if len(tuple) != k:\r\n      flag = 0\r\n      break\r\n  return flag\r\ndef get_equal(Input, k):\r\n  if find_equal_tuple(Input, k) == 1:\r\n    return (\"All tuples have same length\")\r\n  else:\r\n    return (\"All tuples do not have same length\")", "task_id": "Python/70", "test_setup": "", "test": ["assert get_equal([(11, 22, 33), (44, 55, 66)], 3) == 'All tuples have same length'", "assert get_equal([(1, 2, 3), (4, 5, 6, 7)], 3) == 'All tuples do not have same length'", "assert get_equal([(1, 2), (3, 4)], 2) == 'All tuples have same length'"], "challenge_test_list": [], "func_title": "def find_equal_tuple(Input, k):\r", "prompt_text_chinese": "写一个函数来查找所有给定的图元是否具有相同的长度。", "code_comment": ""}
{"prompt": "Write a function to sort a list of elements using comb sort.", "canonical_solution": "def comb_sort(nums):\r\n    shrink_fact = 1.3\r\n    gaps = len(nums)\r\n    swapped = True\r\n    i = 0\r\n    while gaps > 1 or swapped:\r\n        gaps = int(float(gaps) / shrink_fact)\r\n        swapped = False\r\n        i = 0\r\n        while gaps + i < len(nums):\r\n            if nums[i] > nums[i+gaps]:\r\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\r\n                swapped = True\r\n            i += 1\r\n    return nums", "task_id": "Python/71", "test_setup": "", "test": ["assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]", "assert comb_sort([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]", "assert comb_sort([99, 15, 13, 47]) == [13, 15, 47, 99]"], "challenge_test_list": [], "func_title": "def comb_sort(nums):\r", "prompt_text_chinese": "写一个函数，用梳子对一个列表中的元素进行排序。", "code_comment": "定义一个名为comb_sort的函数，参数为nums\n定义变量shrink_fact为1.3\n定义变量gaps为nums的长度\n定义变量swapped为True\n初始化i为0\n当间隔大于1或者有交换时\n缩小间隔\n将swapped设为False\n初始化i为0\n当间隔加i小于nums的长度时\n如果nums[i]大于nums[i+gaps]\n交换nums[i]和nums[i+gaps]\n将swapped设为True\ni加1\n返回排序后的nums列表\n"}
{"prompt": "Write a python function to check whether the given number can be represented as difference of two squares or not.", "canonical_solution": "def dif_Square(n): \r\n    if (n % 4 != 2): \r\n        return True\r\n    return False", "task_id": "Python/72", "test_setup": "", "test": ["assert dif_Square(5) == True", "assert dif_Square(10) == False", "assert dif_Square(15) == True"], "challenge_test_list": [], "func_title": "def dif_Square(n): \r", "prompt_text_chinese": "写一个python函数来检查给定的数字是否可以表示为两个平方的差。", "code_comment": "定义一个名为dif_Square的函数，参数为n\n如果n模4的值不等于2\n返回True\n否则返回False\n"}
{"prompt": "Write a function to split the given string with multiple delimiters by using regex.", "canonical_solution": "import re\r\ndef multiple_split(text):\r\n  return (re.split('; |, |\\*|\\n',text))", "task_id": "Python/73", "test_setup": "", "test": ["assert multiple_split('Forces of the \\ndarkness*are coming into the play.') == ['Forces of the ', 'darkness', 'are coming into the play.']", "assert multiple_split('Mi Box runs on the \\n Latest android*which has google assistance and chromecast.') == ['Mi Box runs on the ', ' Latest android', 'which has google assistance and chromecast.']", "assert multiple_split('Certain services\\nare subjected to change*over the seperate subscriptions.') == ['Certain services', 'are subjected to change', 'over the seperate subscriptions.']"], "challenge_test_list": [], "func_title": "def multiple_split(text):\r", "prompt_text_chinese": "写一个函数，通过使用regex来分割给定的具有多个分隔符的字符串。", "code_comment": "导入re模块\n定义一个名为multiple_split的函数，参数为text\n使用正则表达式对text进行分割\n"}
{"prompt": "Write a function to check whether it follows the sequence given in the patterns array.", "canonical_solution": "def is_samepatterns(colors, patterns):    \r\n    if len(colors) != len(patterns):\r\n        return False    \r\n    sdict = {}\r\n    pset = set()\r\n    sset = set()    \r\n    for i in range(len(patterns)):\r\n        pset.add(patterns[i])\r\n        sset.add(colors[i])\r\n        if patterns[i] not in sdict.keys():\r\n            sdict[patterns[i]] = []\r\n\r\n        keys = sdict[patterns[i]]\r\n        keys.append(colors[i])\r\n        sdict[patterns[i]] = keys\r\n\r\n    if len(pset) != len(sset):\r\n        return False   \r\n\r\n    for values in sdict.values():\r\n\r\n        for i in range(len(values) - 1):\r\n            if values[i] != values[i+1]:\r\n                return False\r\n\r\n    return True", "task_id": "Python/74", "test_setup": "", "test": ["assert is_samepatterns([\"red\",\"green\",\"green\"], [\"a\", \"b\", \"b\"])==True ", "assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\",\"b\"])==False ", "assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\"])==False "], "challenge_test_list": [], "func_title": "def is_samepatterns(colors, patterns):    \r", "prompt_text_chinese": "写一个函数来检查它是否遵循模式数组中给定的序列。", "code_comment": "定义一个名为is_samepatterns的函数，参数为colors和patterns\n如果colors和patterns的长度不相等\n返回False\n初始化sdict为空字典，pset为空集合，sset为空集合\n循环遍历patterns中的每个元素\n将当前元素加入pset和sset中\n如果当前元素不在sdict的键中\n将当前元素加入sdict的键中，对应的值为空列表\n获取当前元素在sdict中对应的值\n将colors[i]加入对应的键值列表中\n如果pset和sset的长度不相等\n返回False\n遍历sdict的所有值\n遍历当前值的所有元素\n如果当前元素与下一个元素不相等\n返回False\n返回True\n"}
{"prompt": "Write a function to find tuples which have all elements divisible by k from the given list of tuples.", "canonical_solution": "def find_tuples(test_list, K):\r\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\r\n  return (str(res)) ", "task_id": "Python/75", "test_setup": "", "test": ["assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == '[(6, 24, 12)]'", "assert find_tuples([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == '[(5, 25, 30)]'", "assert find_tuples([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == '[(8, 16, 4)]'"], "challenge_test_list": [], "func_title": "def find_tuples(test_list, K):\r", "prompt_text_chinese": "写一个函数，从给定的图元列表中找出所有元素都能被k整除的图元。", "code_comment": "定义函数 find_tuples 接收两个参数：test_list 和 K\n使用列表推导式遍历 test_list 中的每个子列表 sub，并筛选出其中所有元素都能被 K 整除的子列表\n将 res 转换为字符串并返回"}
{"prompt": "Write a python function to count the number of squares in a rectangle.", "canonical_solution": "def count_Squares(m,n):\r\n    if(n < m):\r\n        temp = m\r\n        m = n\r\n        n = temp\r\n    return ((m * (m + 1) * (2 * m + 1) / 6 + (n - m) * m * (m + 1) / 2))", "task_id": "Python/76", "test_setup": "", "test": ["assert count_Squares(4,3) == 20", "assert count_Squares(2,2) == 5", "assert count_Squares(1,1) == 1"], "challenge_test_list": [], "func_title": "def count_Squares(m,n):\r", "prompt_text_chinese": "写一个Python函数来计算一个矩形中的方块数量。", "code_comment": "定义函数 count_Squares，接收两个参数 m 和 n\n如果 n 小于 m，交换 m 和 n 的值\n计算并返回满足要求的平方数的个数\n"}
{"prompt": "Write a python function to find the difference between sum of even and odd digits.", "canonical_solution": "def is_Diff(n): \r\n    return (n % 11 == 0) ", "task_id": "Python/77", "test_setup": "", "test": ["assert is_Diff (12345) == False", "assert is_Diff(1212112) == True", "assert is_Diff(1212) == False"], "challenge_test_list": [], "func_title": "def is_Diff(n): \r", "prompt_text_chinese": "写一个Python函数，找出偶数和奇数之和的差异。", "code_comment": "定义函数 is_Diff，接收一个参数 n\n判断 n 是否被 11 整除，如果是，返回 True，否则返回 False\n"}
{"prompt": "Write a python function to find number of integers with odd number of set bits.", "canonical_solution": "def count_With_Odd_SetBits(n): \r\n    if (n % 2 != 0): \r\n        return (n + 1) / 2\r\n    count = bin(n).count('1') \r\n    ans = n / 2\r\n    if (count % 2 != 0): \r\n        ans += 1\r\n    return ans ", "task_id": "Python/78", "test_setup": "", "test": ["assert count_With_Odd_SetBits(5) == 3", "assert count_With_Odd_SetBits(10) == 5", "assert count_With_Odd_SetBits(15) == 8"], "challenge_test_list": [], "func_title": "def count_With_Odd_SetBits(n): \r", "prompt_text_chinese": "写一个Python函数，找出具有奇数位的整数。", "code_comment": "定义一个函数 count_With_Odd_SetBits，接收一个整数参数 n\n判断 n 是否为奇数，如果是，直接计算并返回结果\n计算 n 的二进制表示中 1 的个数\n初始化计数器 ans 为 n 的一半\n如果 1 的个数为奇数，ans 加 1\n返回结果\n"}
{"prompt": "Write a python function to check whether the length of the word is odd or not.", "canonical_solution": "def word_len(s): \r\n    s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2!=0: \r\n            return True  \r\n        else:\r\n          return False", "task_id": "Python/79", "test_setup": "", "test": ["assert word_len(\"Hadoop\") == False", "assert word_len(\"great\") == True", "assert word_len(\"structure\") == True"], "challenge_test_list": [], "func_title": "def word_len(s): \r", "prompt_text_chinese": "写一个Python函数来检查字的长度是否为奇数。", "code_comment": "定义一个函数 word_len，接收一个字符串参数 s\n将字符串 s 按空格分隔成单词列表 s\n遍历单词列表 s 中的每个单词 word\n如果单词 word 的长度为奇数，返回 True\n否则返回 False\n"}
{"prompt": "Write a function to find the nth tetrahedral number.", "canonical_solution": "def tetrahedral_number(n): \r\n\treturn (n * (n + 1) * (n + 2)) / 6", "task_id": "Python/80", "test_setup": "", "test": ["assert tetrahedral_number(5) == 35.0", "assert tetrahedral_number(6) == 56.0", "assert tetrahedral_number(7) == 84.0"], "challenge_test_list": [], "func_title": "def tetrahedral_number(n): \r", "prompt_text_chinese": "写一个查找第n个四面体数字的函数。", "code_comment": "定义一个函数 tetrahedral_number，接收一个整数参数 n\n计算并返回第 n 个四面体数\n"}
{"prompt": "Write a function to zip the two given tuples.", "canonical_solution": "def zip_tuples(test_tup1, test_tup2):\r\n  res = []\r\n  for i, j in enumerate(test_tup1):\r\n    res.append((j, test_tup2[i % len(test_tup2)])) \r\n  return (res) ", "task_id": "Python/81", "test_setup": "", "test": ["assert zip_tuples((7, 8, 4, 5, 9, 10),(1, 5, 6) ) == [(7, 1), (8, 5), (4, 6), (5, 1), (9, 5), (10, 6)]", "assert zip_tuples((8, 9, 5, 6, 10, 11),(2, 6, 7) ) == [(8, 2), (9, 6), (5, 7), (6, 2), (10, 6), (11, 7)]", "assert zip_tuples((9, 10, 6, 7, 11, 12),(3, 7, 8) ) == [(9, 3), (10, 7), (6, 8), (7, 3), (11, 7), (12, 8)]"], "challenge_test_list": [], "func_title": "def zip_tuples(test_tup1, test_tup2):\r", "prompt_text_chinese": "写一个函数来压缩给定的两个图元。", "code_comment": "定义一个函数 zip_tuples，接收两个元组参数 test_tup1 和 test_tup2\n初始化结果列表 res 为空列表\n遍历元组 test_tup1 中的每个元素 j 和它的下标 i\n将元组 (j, test_tup2[i % len(test_tup2)]) 添加到结果列表 res 中\n其中 test_tup2[i % len(test_tup2)] 表示 test_tup2 中与 j 下标对应的元素\n返回结果列表 res\n"}
{"prompt": "Write a function to find the volume of a sphere.", "canonical_solution": "import math\r\ndef volume_sphere(r):\r\n  volume=(4/3)*math.pi*r*r*r\r\n  return volume", "task_id": "Python/82", "test_setup": "", "test": ["assert volume_sphere(10)==4188.790204786391", "assert volume_sphere(25)==65449.84694978735", "assert volume_sphere(20)==33510.32163829113"], "challenge_test_list": [], "func_title": "def volume_sphere(r):\r", "prompt_text_chinese": "写一个函数来寻找球体的体积。", "code_comment": "导入 math 模块\n定义函数 volume_sphere，接收一个参数 r，表示球的半径\n计算球的体积\n返回结果\n"}
{"prompt": "Write a python function to find the character made by adding all the characters of the given string.", "canonical_solution": "def get_Char(strr):  \r\n    summ = 0\r\n    for i in range(len(strr)): \r\n        summ += (ord(strr[i]) - ord('a') + 1)  \r\n    if (summ % 26 == 0): \r\n        return ord('z') \r\n    else: \r\n        summ = summ % 26\r\n        return chr(ord('a') + summ - 1)", "task_id": "Python/83", "test_setup": "", "test": ["assert get_Char(\"abc\") == \"f\"", "assert get_Char(\"gfg\") == \"t\"", "assert get_Char(\"ab\") == \"c\""], "challenge_test_list": [], "func_title": "def get_Char(strr):  \r", "prompt_text_chinese": "写一个python函数，找出由给定字符串的所有字符相加而成的字符。", "code_comment": "定义函数 get_Char，接收一个参数 strr，表示要计算的字符串\n初始化求和变量 summ 为 0\n遍历字符串 strr 中的每个字符\n将字符转换为 ASCII 码值，减去 'a' 的 ASCII 码值，再加一\n得到该字符对应的数值，并累加到 summ 中\n判断 summ 是否能被 26 整除\n如果能，返回字符 'z' 的 ASCII 码值\n否则，对 summ 取模，转换为对应的字母，并返回\n"}
{"prompt": "Write a function to find the n-th number in newman conway sequence.", "canonical_solution": "def sequence(n): \r\n\tif n == 1 or n == 2: \r\n\t\treturn 1\r\n\telse: \r\n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))", "task_id": "Python/84", "test_setup": "", "test": ["assert sequence(10) == 6", "assert sequence(2) == 1", "assert sequence(3) == 2"], "challenge_test_list": [], "func_title": "def sequence(n): \r", "prompt_text_chinese": "写一个函数，求newman conway序列中的第n个数字。", "code_comment": "定义函数 sequence，接收一个整数参数 n\n判断 n 是否等于 1 或 2，如果是，返回 1\n否则，递归计算第 n 项斐波那契数列\n计算方式为 sequence(n - 1) 和 n - sequence(n - 1) 的和\n"}
{"prompt": "Write a function to find the surface area of a sphere.", "canonical_solution": "import math\r\ndef surfacearea_sphere(r):\r\n  surfacearea=4*math.pi*r*r\r\n  return surfacearea", "task_id": "Python/85", "test_setup": "", "test": ["assert surfacearea_sphere(10)==1256.6370614359173", "assert surfacearea_sphere(15)==2827.4333882308138", "assert surfacearea_sphere(20)==5026.548245743669"], "challenge_test_list": [], "func_title": "def surfacearea_sphere(r):\r", "prompt_text_chinese": "写一个函数来求球体的表面积。", "code_comment": "导入 math 模块\n定义函数 surfacearea_sphere，接收一个参数 r，表示球的半径\n计算球的表面积\n返回结果\n"}
{"prompt": "Write a function to find nth centered hexagonal number.", "canonical_solution": "def centered_hexagonal_number(n):\r\n  return 3 * n * (n - 1) + 1", "task_id": "Python/86", "test_setup": "", "test": ["assert centered_hexagonal_number(10) == 271", "assert centered_hexagonal_number(2) == 7", "assert centered_hexagonal_number(9) == 217"], "challenge_test_list": [], "func_title": "def centered_hexagonal_number(n):\r", "prompt_text_chinese": "写一个函数来求第n个居中的六边形数字。", "code_comment": "定义函数 centered_hexagonal_number，接收一个参数 n，表示要计算第 n 项中心六边形数\n计算并返回第 n 项中心六边形数\n"}
{"prompt": "Write a function to merge three dictionaries into a single expression.", "canonical_solution": "import collections as ct\r\ndef merge_dictionaries_three(dict1,dict2, dict3):\r\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\r\n    return merged_dict", "task_id": "Python/87", "test_setup": "", "test": ["assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}", "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{\"L\":\"lavender\",\"B\":\"Blue\"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}", "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" },{\"L\":\"lavender\",\"B\":\"Blue\"},{ \"G\": \"Green\", \"W\": \"White\" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}"], "challenge_test_list": [], "func_title": "def merge_dictionaries_three(dict1,dict2, dict3):\r", "prompt_text_chinese": "写一个函数，将三个字典合并成一个表达式。", "code_comment": "导入 collections 模块，并命名为 ct\n定义函数 merge_dictionaries_three，接收三个字典参数 dict1、dict2 和 dict3\n使用 ChainMap 将三个字典合并，生成一个新的字典 merged_dict\n返回合并后的字典 merged_dict\n"}
{"prompt": "Write a function to get the frequency of the elements in a list.", "canonical_solution": "import collections\r\ndef freq_count(list1):\r\n  freq_count= collections.Counter(list1)\r\n  return freq_count", "task_id": "Python/88", "test_setup": "", "test": ["assert freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])==({10: 4, 20: 4, 40: 2, 50: 2, 30: 1}) ", "assert freq_count([1,2,3,4,3,2,4,1,3,1,4])==({1:3, 2:2,3:3,4:3}) ", "assert freq_count([5,6,7,4,9,10,4,5,6,7,9,5])==({10:1,5:3,6:2,7:2,4:2,9:2}) "], "challenge_test_list": [], "func_title": "def freq_count(list1):\r", "prompt_text_chinese": "写一个函数来获取一个列表中元素的频率。", "code_comment": "导入 collections 模块\n定义函数 freq_count，接收一个列表参数 list1\n使用 Counter 函数对列表中的元素进行计数，生成一个新的字典 freq_count\n返回计数结果 freq_count\n"}
{"prompt": "Write a function to find the closest smaller number than n.", "canonical_solution": "def closest_num(N):\r\n  return (N - 1)", "task_id": "Python/89", "test_setup": "", "test": ["assert closest_num(11) == 10", "assert closest_num(7) == 6", "assert closest_num(12) == 11"], "challenge_test_list": [], "func_title": "def closest_num(N):\r", "prompt_text_chinese": "写一个函数来寻找比n小的最接近的数字。", "code_comment": "定义函数 closest_num，接收一个参数 N\n返回 N - 1\n"}
{"prompt": "Write a python function to find the length of the longest word.", "canonical_solution": "def len_log(list1):\r\n    max=len(list1[0])\r\n    for i in list1:\r\n        if len(i)>max:\r\n            max=len(i)\r\n    return max", "task_id": "Python/90", "test_setup": "", "test": ["assert len_log([\"python\",\"PHP\",\"bigdata\"]) == 7", "assert len_log([\"a\",\"ab\",\"abc\"]) == 3", "assert len_log([\"small\",\"big\",\"tall\"]) == 5"], "challenge_test_list": [], "func_title": "def len_log(list1):\r", "prompt_text_chinese": "写一个Python函数来寻找最长的单词的长度。", "code_comment": "定义函数 len_log，接收一个参数 list1，表示要计算列表中元素的最大长度\n初始化最大值为列表中第一个元素的长度\n遍历列表中的每个元素\n如果当前元素的长度大于最大值，更新最大值\n返回最大值\n"}
{"prompt": "Write a function to check if a substring is present in a given list of string values.", "canonical_solution": "def find_substring(str1, sub_str):\r\n   if any(sub_str in s for s in str1):\r\n       return True\r\n   return False", "task_id": "Python/91", "test_setup": "", "test": ["assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ack\")==True", "assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"abc\")==False", "assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ange\")==True"], "challenge_test_list": [], "func_title": "def find_substring(str1, sub_str):\r", "prompt_text_chinese": "写一个函数来检查在给定的字符串值列表中是否存在一个子串。", "code_comment": "定义函数 find_substring，接收两个参数 str1 和 sub_str，表示要在 str1 中查找 sub_str 是否存在\n遍历 str1 中的每个子串，如果 sub_str 存在于其中任意一个子串，则返回 True\n如果 sub_str 不存在于任何一个子串中，则返回 False\n"}
{"prompt": "Write a function to check whether the given number is undulating or not.", "canonical_solution": "def is_undulating(n): \r\n\tif (len(n) <= 2): \r\n\t\treturn False\r\n\tfor i in range(2, len(n)): \r\n\t\tif (n[i - 2] != n[i]): \r\n\t\t\treturn False\r\n\treturn True", "task_id": "Python/92", "test_setup": "", "test": ["assert is_undulating(\"1212121\") == True", "assert is_undulating(\"1991\") == False", "assert is_undulating(\"121\") == True"], "challenge_test_list": [], "func_title": "def is_undulating(n): \r", "prompt_text_chinese": "写一个函数来检查给定的数字是否是起伏的。", "code_comment": "定义函数 is_undulating，接收一个参数 n，表示要判断的数字\n如果 n 的长度小于等于 2，则不满足波浪数的定义，返回 False\n遍历 n 中的每个数字，从第三个数字开始\n如果当前数字和前面两个数字不相等，说明不满足波浪数的定义，返回 False\n如果遍历完 n 中的每个数字都满足波浪数的定义，返回 True\n"}
{"prompt": "Write a function to calculate the value of 'a' to the power 'b'.", "canonical_solution": "def power(a,b):\r\n\tif b==0:\r\n\t\treturn 1\r\n\telif a==0:\r\n\t\treturn 0\r\n\telif b==1:\r\n\t\treturn a\r\n\telse:\r\n\t\treturn a*power(a,b-1)", "task_id": "Python/93", "test_setup": "", "test": ["assert power(3,4) == 81", "assert power(2,3) == 8", "assert power(5,5) == 3125"], "challenge_test_list": [], "func_title": "def power(a,b):\r", "prompt_text_chinese": "写一个函数来计算'a'的值到'b'的幂。", "code_comment": "定义函数 power，接收两个参数 a 和 b，表示要计算 a 的 b 次方\n如果 b 等于 0，返回 1\n如果 a 等于 0，返回 0\n如果 b 等于 1，返回 a\n否则，递归计算 a 的 b - 1 次方，并将结果乘以 a\n"}
{"prompt": "Write a function to extract the index minimum value record from the given tuples.", "canonical_solution": "from operator import itemgetter \r\ndef index_minimum(test_list):\r\n  res = min(test_list, key = itemgetter(1))[0]\r\n  return (res) ", "task_id": "Python/94", "test_setup": "", "test": ["assert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'", "assert index_minimum([('Yash', 185), ('Dawood', 125), ('Sanya', 175)]) == 'Dawood'", "assert index_minimum([('Sai', 345), ('Salman', 145), ('Ayesha', 96)]) == 'Ayesha'"], "challenge_test_list": [], "func_title": "def index_minimum(test_list):\r", "prompt_text_chinese": "写一个函数，从给定的图元中提取索引最小值记录。", "code_comment": "导入 itemgetter 函数\n定义函数 index_minimum，接收一个参数 test_list，表示要在列表中查找第二列值最小的元素的第一列值\n使用 min 函数和 itemgetter 函数找出列表中第二列值最小的元素\n再使用其对应的第一列值作为结果返回\n"}
{"prompt": "Write a python function to find the minimum length of sublist.", "canonical_solution": "def Find_Min_Length(lst):  \r\n    minLength = min(len(x) for x in lst )\r\n    return minLength ", "task_id": "Python/95", "test_setup": "", "test": ["assert Find_Min_Length([[1],[1,2]]) == 1", "assert Find_Min_Length([[1,2],[1,2,3],[1,2,3,4]]) == 2", "assert Find_Min_Length([[3,3,3],[4,4,4,4]]) == 3"], "challenge_test_list": [], "func_title": "def Find_Min_Length(lst):  \r", "prompt_text_chinese": "写一个Python函数，找出子列表的最小长度。", "code_comment": "定义函数 Find_Min_Length，接收一个参数 lst，表示要在列表中查找最短元素的长度\n使用 min 函数和生成器表达式找到 lst 中最短元素的长度\n返回最短元素的长度\n"}
{"prompt": "Write a python function to find the number of divisors of a given integer.", "canonical_solution": "def divisor(n):\r\n  for i in range(n):\r\n    x = len([i for i in range(1,n+1) if not n % i])\r\n  return x", "task_id": "Python/96", "test_setup": "", "test": ["assert divisor(15) == 4 ", "assert divisor(12) == 6", "assert divisor(9) == 3"], "challenge_test_list": [], "func_title": "def divisor(n):\r", "prompt_text_chinese": "写一个Python函数来寻找一个给定的整数的除数。", "code_comment": "定义函数 divisor，接收一个参数 n，表示要计算 n 的因数个数\n遍历 1 到 n，找到 n 的因数并保存在列表中，最后返回列表的长度即为 n 的因数个数\n"}
{"prompt": "Write a function to find frequency count of list of lists.", "canonical_solution": "def frequency_lists(list1):\r\n    list1 = [item for sublist in list1 for item in sublist]\r\n    dic_data = {}\r\n    for num in list1:\r\n        if num in dic_data.keys():\r\n            dic_data[num] += 1\r\n        else:\r\n            key = num\r\n            value = 1\r\n            dic_data[key] = value\r\n    return dic_data\r\n", "task_id": "Python/97", "test_setup": "", "test": ["assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])=={1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}", "assert frequency_lists([[1,2,3,4],[5,6,7,8],[9,10,11,12]])=={1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1,10:1,11:1,12:1}", "assert frequency_lists([[20,30,40,17],[18,16,14,13],[10,20,30,40]])=={20:2,30:2,40:2,17: 1,18:1, 16: 1,14: 1,13: 1, 10: 1}"], "challenge_test_list": [], "func_title": "def frequency_lists(list1):\r", "prompt_text_chinese": "写一个函数来查找列表的频率计数。", "code_comment": "定义函数 frequency_lists，接收一个参数 list1，表示一个包含若干个列表的列表\n将 list1 的所有元素合并成一个列表\n定义一个空字典 dic_data\n遍历合并后的列表，统计每个数字的出现次数，并将结果保存在 dic_data 中\n返回 dic_data\n"}
{"prompt": "Write a function to multiply all the numbers in a list and divide with the length of the list.", "canonical_solution": "def multiply_num(numbers):  \r\n    total = 1\r\n    for x in numbers:\r\n        total *= x  \r\n    return total/len(numbers) ", "task_id": "Python/98", "test_setup": "", "test": ["assert multiply_num((8, 2, 3, -1, 7))==-67.2", "assert multiply_num((-10,-20,-30))==-2000.0", "assert multiply_num((19,15,18))==1710.0"], "challenge_test_list": [], "func_title": "def multiply_num(numbers):  \r", "prompt_text_chinese": "写一个函数，将一个列表中的所有数字相乘并与列表的长度相除。", "code_comment": "定义函数 multiply_num，接收一个参数 numbers，表示一个数字列表\n初始化变量 total 为 1\n遍历数字列表 numbers，将列表中所有数字相乘\n将数字列表中所有数字相乘的结果除以数字列表的长度，得到平均值，并返回平均值\n"}
{"prompt": "Write a function to convert the given decimal number to its binary equivalent.", "canonical_solution": "def decimal_to_binary(n): \r\n    return bin(n).replace(\"0b\",\"\") ", "task_id": "Python/99", "test_setup": "", "test": ["assert decimal_to_binary(8) == '1000'", "assert decimal_to_binary(18) == '10010'", "assert decimal_to_binary(7) == '111' "], "challenge_test_list": [], "func_title": "def decimal_to_binary(n): \r", "prompt_text_chinese": "写一个函数，将给定的十进制数转换为二进制数。", "code_comment": "定义函数 decimal_to_binary，接收一个参数 n，表示要将该数字转换为二进制数\n使用内置函数 bin() 将 n 转换为二进制字符串，再使用 replace() 方法将字符串开头的 \"0b\" 替换为空字符串\n"}
{"prompt": "Write a function to find the next smallest palindrome of a specified number.", "canonical_solution": "import sys\r\ndef next_smallest_palindrome(num):\r\n    numstr = str(num)\r\n    for i in range(num+1,sys.maxsize):\r\n        if str(i) == str(i)[::-1]:\r\n            return i", "task_id": "Python/100", "test_setup": "", "test": ["assert next_smallest_palindrome(99)==101", "assert next_smallest_palindrome(1221)==1331", "assert next_smallest_palindrome(120)==121"], "challenge_test_list": [], "func_title": "def next_smallest_palindrome(num):\r", "prompt_text_chinese": "写一个函数来寻找指定数字的下一个最小的宫格。", "code_comment": "导入 sys 模块\n定义函数 next_smallest_palindrome，接收一个参数 num，表示要找出比 num 大的下一个回文数\n将 num 转换为字符串\n从 num+1 开始遍历到 sys.maxsize\n如果 i 等于 i 的倒序字符串，说明 i 是回文数，返回 i\n"}
{"prompt": "Write a function to find the kth element in the given array.", "canonical_solution": "def kth_element(arr, n, k):\r\n  for i in range(n):\r\n    for j in range(0, n-i-1):\r\n      if arr[j] > arr[j+1]:\r\n        arr[j], arr[j+1] == arr[j+1], arr[j]\r\n  return arr[k-1]", "task_id": "Python/101", "test_setup": "", "test": ["assert kth_element([12,3,5,7,19], 5, 2) == 3", "assert kth_element([17,24,8,23], 4, 3) == 8", "assert kth_element([16,21,25,36,4], 5, 4) == 36"], "challenge_test_list": [], "func_title": "def kth_element(arr, n, k):\r", "prompt_text_chinese": "写一个函数来寻找给定数组中的第k个元素。", "code_comment": "定义函数 kth_element，接收三个参数 arr、n 和 k，其中 arr 表示一个整数列表，n 表示列表中元素的个数，k 表示要查找的第 k 小的元素（k 从 1 开始）\n使用冒泡排序对 arr 进行排序，从小到大排列\n返回排序后的列表 arr 中第 k-1 个元素作为结果，因为 k 从 1 开始，而列表下标从 0 开始"}
{"prompt": "Write a function to convert snake case string to camel case string.", "canonical_solution": "def snake_to_camel(word):\r\n        import re\r\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))", "task_id": "Python/102", "test_setup": "", "test": ["assert snake_to_camel('python_program')=='PythonProgram'", "assert snake_to_camel('python_language')==('PythonLanguage')", "assert snake_to_camel('programming_language')==('ProgrammingLanguage')"], "challenge_test_list": [], "func_title": "def snake_to_camel(word):\r", "prompt_text_chinese": "写一个函数，将蛇形大小写的字符串转换为驼色大小写的字符串。", "code_comment": "定义函数 snake_to_camel，接收一个参数 word，表示一个蛇形命名的字符串\n导入 re 模块\n将蛇形命名的字符串 word 按照下划线分割成单词列表，并对每个单词首字母大写\n将首字母大写后的单词列表连接成一个新的字符串，返回新的字符串\n"}
{"prompt": "Write a function to find eulerian number a(n, m).", "canonical_solution": "def eulerian_num(n, m): \r\n\tif (m >= n or n == 0): \r\n\t\treturn 0 \r\n\tif (m == 0): \r\n\t\treturn 1 \r\n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))", "task_id": "Python/103", "test_setup": "", "test": ["assert eulerian_num(3, 1) == 4", "assert eulerian_num(4, 1) == 11", "assert eulerian_num(5, 3) == 26"], "challenge_test_list": [], "func_title": "def eulerian_num(n, m): \r", "prompt_text_chinese": "写一个函数来寻找欧拉数a(n, m)。", "code_comment": "定义函数 eulerian_num，接收两个参数 n 和 m，表示计算欧拉数 E(n, m) 的值\n如果 m 大于等于 n 或者 n 等于 0，则 E(n, m) 等于 0\n如果 m 等于 0，则 E(n, m) 等于 1\n否则，根据递推式 E(n, m) = (n - m) * E(n - 1, m - 1) + (m + 1) * E(n - 1, m) 递归计算 E(n, m)\n"}
{"prompt": "Write a function to sort each sublist of strings in a given list of lists using lambda function.", "canonical_solution": "def sort_sublists(input_list):\r\n    result = [sorted(x, key = lambda x:x[0]) for x in input_list] \r\n    return result\r", "task_id": "Python/104", "test_setup": "", "test": ["assert sort_sublists(([\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]))==[['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]", "assert sort_sublists(([\" red \",\"green\" ],[\"blue \",\" black\"],[\" orange\",\"brown\"]))==[[' red ', 'green'], [' black', 'blue '], [' orange', 'brown']]", "assert sort_sublists(([\"zilver\",\"gold\"], [\"magnesium\",\"aluminium\"], [\"steel\", \"bronze\"]))==[['gold', 'zilver'],['aluminium', 'magnesium'], ['bronze', 'steel']]"], "challenge_test_list": [], "func_title": "def sort_sublists(input_list):\r", "prompt_text_chinese": "写一个函数，用lambda函数对给定的列表中的每个子列表的字符串进行排序。", "code_comment": "定义函数 sort_sublists，接收一个参数 input_list，表示一个包含若干个子列表的列表\n对每个子列表按照第一个元素进行排序，并返回包含排序后子列表的新列表\n使用列表生成式和 sorted 函数对 input_list 中的每个子列表按照第一个元素进行排序\nkey 函数用于指定排序规则，这里使用 lambda 表达式指定按照第一个元素排序\n"}
{"prompt": "Write a python function to count true booleans in the given list.", "canonical_solution": "def count(lst):   \r\n    return sum(lst) ", "task_id": "Python/105", "test_setup": "", "test": ["assert count([True,False,True]) == 2", "assert count([False,False]) == 0", "assert count([True,True,True]) == 3"], "challenge_test_list": [], "func_title": "def count(lst):   \r", "prompt_text_chinese": "写一个python函数来计算给定列表中的真布尔。", "code_comment": "定义函数 count，接收一个参数 lst，表示一个数字列表\n使用内置函数 sum() 对 lst 中所有数字求和，并返回求和结果\n"}
{"prompt": "Write a function to add the given list to the given tuples.", "canonical_solution": "def add_lists(test_list, test_tup):\r\n  res = tuple(list(test_tup) + test_list)\r\n  return (res) ", "task_id": "Python/106", "test_setup": "", "test": ["assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)", "assert add_lists([6, 7, 8], (10, 11)) == (10, 11, 6, 7, 8)", "assert add_lists([7, 8, 9], (11, 12)) == (11, 12, 7, 8, 9)"], "challenge_test_list": [], "func_title": "def add_lists(test_list, test_tup):\r", "prompt_text_chinese": "写一个函数，将给定的列表添加到给定的图元中。", "code_comment": "定义函数 add_lists，接收两个参数 test_list 和 test_tup，分别表示一个列表和一个元组\n将元组 test_tup 转换为列表，然后将列表和列表 test_list 进行拼接成一个新的列表，并将新的列表转换为元组\n返回新的元组 res 作为结果\n"}
{"prompt": "Write a python function to count hexadecimal numbers for a given range.", "canonical_solution": "def count_Hexadecimal(L,R) :  \r\n    count = 0;  \r\n    for i in range(L,R + 1) : \r\n        if (i >= 10 and i <= 15) : \r\n            count += 1;  \r\n        elif (i > 15) : \r\n            k = i;  \r\n            while (k != 0) :  \r\n                if (k % 16 >= 10) : \r\n                    count += 1;  \r\n                k = k // 16;  \r\n    return count;  ", "task_id": "Python/107", "test_setup": "", "test": ["assert count_Hexadecimal(10,15) == 6", "assert count_Hexadecimal(2,4) == 0", "assert count_Hexadecimal(15,16) == 1"], "challenge_test_list": [], "func_title": "def count_Hexadecimal(L,R) :  \r", "prompt_text_chinese": "写一个Python函数来计算给定范围的十六进制数字。", "code_comment": "定义函数 count_Hexadecimal，接收两个参数 L 和 R，表示一个区间 [L, R]，计算该区间内的十六进制数中包含字母的个数\n遍历区间 [L, R] 中的每个数 i\n如果 i 是十六进制数中的字母（A-F），则计数器 count 加 1\n如果 i 大于 15，则将 i 转换为十六进制字符串，再遍历字符串中的每个字符\n如果字符是字母，则计数器 count 加 1\n返回计数器 count 的值作为结果\n"}
{"prompt": "Write a function to merge multiple sorted inputs into a single sorted iterator using heap queue algorithm.", "canonical_solution": "import heapq\r\ndef merge_sorted_list(num1,num2,num3):\r\n  num1=sorted(num1)\r\n  num2=sorted(num2)\r\n  num3=sorted(num3)\r\n  result = heapq.merge(num1,num2,num3)\r\n  return list(result)", "task_id": "Python/108", "test_setup": "", "test": ["assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110],[19, 20, 11, 56, 25, 233, 154],[24, 26, 54, 48])==[4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]", "assert merge_sorted_list([1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12])==[1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]", "assert merge_sorted_list([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1],[25, 35, 22, 85, 14, 65, 75, 25, 58],[12, 74, 9, 50, 61, 41])==[1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]"], "challenge_test_list": [], "func_title": "def merge_sorted_list(num1,num2,num3):\r", "prompt_text_chinese": "写一个函数，使用堆队列算法将多个排序的输入合并成一个排序的迭代器。", "code_comment": "导入 heapq 模块\n定义函数 merge_sorted_list，接收三个参数 num1、num2 和 num3，分别表示三个已排序的数字列表\n对 num1、num2 和 num3 中的元素进行排序（升序）\n使用 heapq.merge() 函数将三个已排序列表合并成一个迭代器，并将合并后的迭代器转换为列表\n"}
{"prompt": "Write a python function to find the count of rotations of a binary string with odd value.", "canonical_solution": "def odd_Equivalent(s,n): \r\n    count=0\r\n    for i in range(0,n): \r\n        if (s[i] == '1'): \r\n            count = count + 1\r\n    return count ", "task_id": "Python/109", "test_setup": "", "test": ["assert odd_Equivalent(\"011001\",6) == 3", "assert odd_Equivalent(\"11011\",5) == 4", "assert odd_Equivalent(\"1010\",4) == 2"], "challenge_test_list": [], "func_title": "def odd_Equivalent(s,n): \r", "prompt_text_chinese": "写一个Python函数，找出一个奇数值的二进制字符串的旋转次数。", "code_comment": "定义函数 odd_Equivalent，接收两个参数 s 和 n，分别表示一个包含 n 个字符的字符串和字符串的长度\n遍历字符串 s 中的每个字符\n如果字符为 '1'，则计数器 count 加 1\n返回计数器 count 的值，作为结果\n"}
{"prompt": "Write a function to extract the ranges that are missing from the given list with the given start range and end range values.", "canonical_solution": "def extract_missing(test_list, strt_val, stop_val):\r\n  res = []\r\n  for sub in test_list:\r\n    if sub[0] > strt_val:\r\n      res.append((strt_val, sub[0]))\r\n      strt_val = sub[1]\r\n    if strt_val < stop_val:\r\n      res.append((strt_val, stop_val))\r\n  return (res) ", "task_id": "Python/110", "test_setup": "", "test": ["assert extract_missing([(6, 9), (15, 34), (48, 70)], 2, 100) == [(2, 6), (9, 100), (9, 15), (34, 100), (34, 48), (70, 100)]", "assert extract_missing([(7, 2), (15, 19), (38, 50)], 5, 60) == [(5, 7), (2, 60), (2, 15), (19, 60), (19, 38), (50, 60)]", "assert extract_missing([(7, 2), (15, 19), (38, 50)], 1, 52) == [(1, 7), (2, 52), (2, 15), (19, 52), (19, 38), (50, 52)]"], "challenge_test_list": [], "func_title": "def extract_missing(test_list, strt_val, stop_val):\r", "prompt_text_chinese": "写一个函数，从给定的列表中提取缺少的范围，并给出开始范围和结束范围的值。", "code_comment": "定义函数 extract_missing，接收三个参数 test_list、strt_val 和 stop_val，其中 test_list 表示一个由元组组成的列表，每个元组表示一个区间，strt_val 和 stop_val 分别表示区间的起始值和结束值\n函数的作用是将位于区间 [strt_val, stop_val] 中的空缺部分提取出来，并返回一个包含这些空缺部分的元组列表\n遍历 test_list 中的每个子列表 sub\n如果 sub 的起始值大于 strt_val，则说明存在一个空缺部分，将空缺部分添加到 res 列表中，并更新 strt_val 的值\n如果 strt_val 小于 stop_val，则说明还存在一个空缺部分，将空缺部分添加到 res 列表中\n返回包含空缺部分的元组列表 res 作为结果"}
{"prompt": "Write a function to find common elements in given nested lists. * list item * list item * list item * list item", "canonical_solution": "def common_in_nested_lists(nestedlist):\r\n    result = list(set.intersection(*map(set, nestedlist)))\r\n    return result", "task_id": "Python/111", "test_setup": "", "test": ["assert common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])==[18, 12]", "assert common_in_nested_lists([[12, 5, 23, 25, 45], [7, 11, 5, 23, 28], [1, 5, 8, 18, 23, 16]])==[5,23]", "assert common_in_nested_lists([[2, 3,4, 1], [4, 5], [6,4, 8],[4, 5], [6, 8,4]])==[4]"], "challenge_test_list": [], "func_title": "def common_in_nested_lists(nestedlist):\r", "prompt_text_chinese": "写一个函数来寻找给定嵌套列表中的共同元素。* 列表项 * 列表项 * 列表项 * 列表项", "code_comment": "定义函数 common_in_nested_lists，接收一个参数 nestedlist，表示一个嵌套的列表\n函数的作用是找出所有嵌套列表中共同出现的元素，并返回由这些元素组成的列表\n使用 set() 函数将嵌套列表转换为集合列表\n然后使用 map() 函数将集合列表中每个集合转换为集合对象\nset.intersection() 方法用于求多个集合的交集\n最后使用 list() 函数将交集集合转换为列表\n"}
{"prompt": "Write a python function to find the perimeter of a cylinder.", "canonical_solution": "def perimeter(diameter,height) : \r\n    return 2*(diameter+height)  ", "task_id": "Python/112", "test_setup": "", "test": ["assert perimeter(2,4) == 12", "assert perimeter(1,2) == 6", "assert perimeter(3,1) == 8"], "challenge_test_list": [], "func_title": "def perimeter(diameter,height) : \r", "prompt_text_chinese": "写一个Python函数来寻找一个圆柱体的周长。", "code_comment": "定义函数 perimeter，接收两个参数 diameter 和 height，分别表示一个圆的直径和该圆对应圆柱的高度\n函数的作用是计算该圆柱的周长，并返回周长的值\n根据周长的公式，周长等于圆柱的底面周长加上两个底面到顶部的高度\n"}
{"prompt": "Write a function to check if a string represents an integer or not.", "canonical_solution": "def check_integer(text):\r\n text = text.strip()\r\n if len(text) < 1:\r\n    return None\r\n else:\r\n     if all(text[i] in \"0123456789\" for i in range(len(text))):\r\n          return True\r\n     elif (text[0] in \"+-\") and \\\r\n         all(text[i] in \"0123456789\" for i in range(1,len(text))):\r\n         return True\r\n     else:\r\n        return False", "task_id": "Python/113", "test_setup": "", "test": ["assert check_integer(\"python\")==False", "assert check_integer(\"1\")==True", "assert check_integer(\"12345\")==True"], "challenge_test_list": [], "func_title": "def check_integer(text):\r", "prompt_text_chinese": "写一个函数来检查一个字符串是否代表一个整数。", "code_comment": "定义函数 check_integer，接收一个参数 text，表示待检查的字符串\n函数的作用是判断字符串 text 是否为整数，并返回判断的结果\nstrip() 方法用于去除字符串 text 的头尾空格\n如果字符串 text 的长度小于 1，则返回 None\n如果字符串 text 中的每个字符都是数字，则返回 True\n如果字符串 text 的第一个字符是 '+' 或 '-'，并且其余字符都是数字，则返回 True\n否则返回 False\n"}
{"prompt": "Write a function to assign frequency to each tuple in the given tuple list.", "canonical_solution": "from collections import Counter \r\ndef assign_freq(test_list):\r\n  res = [(*key, val) for key, val in Counter(test_list).items()]\r\n  return (str(res)) ", "task_id": "Python/114", "test_setup": "", "test": ["assert assign_freq([(6, 5, 8), (2, 7), (6, 5, 8), (6, 5, 8), (9, ), (2, 7)] ) == '[(6, 5, 8, 3), (2, 7, 2), (9, 1)]'", "assert assign_freq([(4, 2, 4), (7, 1), (4, 8), (4, 2, 4), (9, 2), (7, 1)] ) == '[(4, 2, 4, 2), (7, 1, 2), (4, 8, 1), (9, 2, 1)]'", "assert assign_freq([(11, 13, 10), (17, 21), (4, 2, 3), (17, 21), (9, 2), (4, 2, 3)] ) == '[(11, 13, 10, 1), (17, 21, 2), (4, 2, 3, 2), (9, 2, 1)]'"], "challenge_test_list": [], "func_title": "def assign_freq(test_list):\r", "prompt_text_chinese": "写一个函数为给定元组列表中的每个元组分配频率。", "code_comment": "引入 collections 模块中的 Counter 类\n定义函数 assign_freq，接收一个参数 test_list，表示待统计频数的列表\n函数的作用是统计列表 test_list 中每个元素出现的频数，并返回一个包含元素和频数的列表\n使用 Counter 对列表 test_list 进行元素频数统计，并将结果转换为元素和频数的列表\n注意这里使用了比较新的语法 *key，将元素拆分为多个参数传递给列表\n将结果转换为字符串并返回\n注意这里返回的是字符串形式的列表结果，而不是列表对象本身"}
{"prompt": "Write a function to check whether all dictionaries in a list are empty or not.", "canonical_solution": "def empty_dit(list1):\r\n empty_dit=all(not d for d in list1)\r\n return empty_dit", "task_id": "Python/115", "test_setup": "", "test": ["assert empty_dit([{},{},{}])==True", "assert empty_dit([{1,2},{},{}])==False", "assert empty_dit({})==True"], "challenge_test_list": [], "func_title": "def empty_dit(list1):\r", "prompt_text_chinese": "写一个函数来检查一个列表中的所有字典是否为空。", "code_comment": "定义函数 empty_dit，接收一个参数 list1，表示待检测的列表\n函数的作用是检测列表 list1 中是否所有元素均为空，如果是则返回 True，否则返回 False\n使用 all 函数检测列表 list1 中所有元素是否均为 False（即空）\n返回检测结果\n注意这里返回的是一个布尔值，表示列表是否为空"}
{"prompt": "Write a function to convert a given tuple of positive integers into an integer.", "canonical_solution": "def tuple_to_int(nums):\r\n    result = int(''.join(map(str,nums)))\r\n    return result", "task_id": "Python/116", "test_setup": "", "test": ["assert tuple_to_int((1,2,3))==123", "assert tuple_to_int((4,5,6))==456", "assert tuple_to_int((5,6,7))==567"], "challenge_test_list": [], "func_title": "def tuple_to_int(nums):\r", "prompt_text_chinese": "写一个函数，将给定的正整数元组转换为整数。", "code_comment": "定义函数 tuple_to_int，接收一个参数 nums，表示待转换的元组\n函数的作用是将元组中的数字转换为一个整数并返回\n将元组中的数字转换为字符串，使用 join 函数连接成一个字符串\n再使用 int 函数将字符串转换为整数\n返回转换结果\n注意这里返回的是整数类型"}
{"prompt": "Write a function to convert all possible convertible elements in the list to float.", "canonical_solution": "def list_to_float(test_list):\r\n  res = []\r\n  for tup in test_list:\r\n    temp = []\r\n    for ele in tup:\r\n      if ele.isalpha():\r\n        temp.append(ele)\r\n      else:\r\n        temp.append(float(ele))\r\n    res.append((temp[0],temp[1])) \r\n  return (str(res)) ", "task_id": "Python/117", "test_setup": "", "test": ["assert list_to_float( [(\"3\", \"4\"), (\"1\", \"26.45\"), (\"7.32\", \"8\"), (\"4\", \"8\")] ) == '[(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]'", "assert list_to_float( [(\"4\", \"4\"), (\"2\", \"27\"), (\"4.12\", \"9\"), (\"7\", \"11\")] ) == '[(4.0, 4.0), (2.0, 27.0), (4.12, 9.0), (7.0, 11.0)]'", "assert list_to_float( [(\"6\", \"78\"), (\"5\", \"26.45\"), (\"1.33\", \"4\"), (\"82\", \"13\")] ) == '[(6.0, 78.0), (5.0, 26.45), (1.33, 4.0), (82.0, 13.0)]'"], "challenge_test_list": [], "func_title": "def list_to_float(test_list):\r", "prompt_text_chinese": "写一个函数，将列表中所有可能的可转换元素转换为浮点数。", "code_comment": "定义函数 list_to_float，接收一个参数 test_list，表示待转换的列表\n函数的作用是将列表中的数字字符串转换为浮点数，并返回由每个元素的首尾两个元素组成的元组构成的列表\n定义结果列表 res\n遍历输入的列表 test_list 中的每个元素（元素为元组）\n定义临时列表 temp\n遍历元组 tup 中的每个元素\n判断元素是否为字母\n如果是字母，直接添加到临时列表 temp 中\n如果是数字字符串，使用 float 函数将其转换为浮点数，再添加到临时列表 temp 中\n将临时列表 temp 中的首尾两个元素组成的元组添加到结果列表 res 中\n将结果列表转换为字符串并返回\n注意这里返回的是字符串形式的列表结果，而不是列表对象本身"}
{"prompt": "[link text](https:// [link text](https:// [link text](https://)))write a function to convert a string to a list.", "canonical_solution": "def string_to_list(string): \r\n    lst = list(string.split(\" \")) \r\n    return lst", "task_id": "Python/118", "test_setup": "", "test": ["assert string_to_list(\"python programming\")==['python','programming']", "assert string_to_list(\"lists tuples strings\")==['lists','tuples','strings']", "assert string_to_list(\"write a program\")==['write','a','program']"], "challenge_test_list": [], "func_title": "def string_to_list(string): \r", "prompt_text_chinese": "[链接文本](https", "code_comment": "定义函数 string_to_list，接收一个参数 string，表示待转换的字符串\n函数的作用是将字符串按空格分割为多个部分，并返回由这些部分组成的列表\n使用 split 函数按空格将字符串分割为多个部分，并转换为列表对象\n返回列表对象"}
{"prompt": "Write a python function to find the element that appears only once in a sorted array.", "canonical_solution": "def search(arr,n) :\r\n    XOR = 0\r\n    for i in range(n) :\r\n        XOR = XOR ^ arr[i]\r\n    return (XOR)", "task_id": "Python/119", "test_setup": "", "test": ["assert search([1,1,2,2,3],5) == 3", "assert search([1,1,3,3,4,4,5,5,7,7,8],11) == 8", "assert search([1,2,2,3,3,4,4],7) == 1"], "challenge_test_list": [], "func_title": "def search(arr,n) :\r", "prompt_text_chinese": "写一个Python函数来寻找在一个排序的数组中只出现一次的元素。", "code_comment": "定义函数 search，接收两个参数 arr 和 n，分别表示待搜索的数组和数组长度\n函数的作用是在数组 arr 中寻找唯一出现的元素，并返回该元素\n初始化变量 XOR\n遍历数组 arr 中的每个元素\n使用异或运算符对变量 XOR 和当前遍历的元素进行异或运算，并将结果赋值给变量 XOR\n返回变量 XOR，即唯一出现的元素"}
{"prompt": "Write a function to find the maximum product from the pairs of tuples within a given list.", "canonical_solution": "def max_product_tuple(list1):\r\n    result_max = max([abs(x * y) for x, y in list1] )\r\n    return result_max", "task_id": "Python/120", "test_setup": "", "test": ["assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36", "assert max_product_tuple([(10,20), (15,2), (5,10)] )==200", "assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484"], "challenge_test_list": [], "func_title": "def max_product_tuple(list1):\r", "prompt_text_chinese": "写一个函数，从一个给定的列表中的图元对中找到最大的乘积。", "code_comment": "定义函数 max_product_tuple，接收一个参数 list1，表示待计算的元组列表\n函数的作用是计算元组列表中两个元素的乘积的绝对值的最大值，并返回该最大值\n使用列表推导式计算元组列表中两个元素的乘积的绝对值，并找出其中的最大值\n返回最大值\n注意这里返回的是一个数字类型的结果"}
{"prompt": "Write a function to find the triplet with sum of the given array", "canonical_solution": "def check_triplet(A, n, sum, count):\r\n    if count == 3 and sum == 0:\r\n        return True\r\n    if count == 3 or n == 0 or sum < 0:\r\n        return False\r\n    return check_triplet(A, n - 1, sum - A[n - 1], count + 1) or\\\r\n           check_triplet(A, n - 1, sum, count)", "task_id": "Python/121", "test_setup": "", "test": ["assert check_triplet([2, 7, 4, 0, 9, 5, 1, 3], 8, 6, 0) == True", "assert check_triplet([1, 4, 5, 6, 7, 8, 5, 9], 8, 6, 0) == False", "assert check_triplet([10, 4, 2, 3, 5], 5, 15, 0) == True"], "challenge_test_list": [], "func_title": "def check_triplet(A, n, sum, count):\r", "prompt_text_chinese": "写一个函数来寻找给定数组中的三者之和。", "code_comment": "定义函数 check_triplet，接收四个参数 A、n、sum 和 count，分别表示待匹配的数组、数组长度、目标和、当前已匹配的元素个数\n函数的作用是检查数组 A 中是否存在三个元素的和为 sum，并返回布尔值\n如果已经匹配了三个元素且它们的和为 sum，则返回 True\n如果已经匹配了三个元素或者数组长度为 0 或者目标和小于 0，则返回 False\n递归调用函数 check_triplet，尝试匹配下一个元素\n每次递归调用都将参数 n、sum 和 count 进行调整，并根据匹配结果返回 True 或 False\n注意这里使用了 Python 的三元表达式\n"}
{"prompt": "Write a function to find n’th smart number.", "canonical_solution": "MAX = 3000 \r\ndef smartNumber(n): \r\n\tprimes = [0] * MAX \r\n\tresult = [] \r\n\tfor i in range(2, MAX): \r\n\t\tif (primes[i] == 0): \r\n\t\t\tprimes[i] = 1 \r\n\t\t\tj = i * 2 \r\n\t\t\twhile (j < MAX): \r\n\t\t\t\tprimes[j] -= 1 \r\n\t\t\t\tif ( (primes[j] + 3) == 0): \r\n\t\t\t\t\tresult.append(j) \r\n\t\t\t\tj = j + i \r\n\tresult.sort() \r\n\treturn result[n - 1] ", "task_id": "Python/122", "test_setup": "", "test": ["assert smartNumber(1) == 30", "assert smartNumber(50) == 273", "assert smartNumber(1000) == 2664"], "challenge_test_list": [], "func_title": "def smartNumber(n): \r", "prompt_text_chinese": "写一个函数来寻找第n个智能数。", "code_comment": "定义常量 MAX，其值为 3000\n定义函数 smartNumber，接收一个参数 n，表示第 n 个特殊数字\n函数的作用是找出第 n 个特殊数字，并返回该数字\n定义长度为 MAX 的全零列表 primes，并初始化\n定义结果列表 result\n遍历 2 到 MAX 范围内的每个数\n如果当前数 i 是质数\n将 primes[i] 设为 1，表示该数是质数\n定义变量 j，其初始值为 i 的两倍\n不断将 j 加上 i 的值，并标记 primes[j] 为非 1 的值\n如果 primes[j] 的值为 -2，则表明 j 是特殊数字，将其添加到结果列表 result 中\n将 j 加上 i 的值\n对结果列表 result 进行排序\n返回结果列表 result 中的第 n 个元素"}
{"prompt": "Write a function to sum all amicable numbers from 1 to a specified number.", "canonical_solution": "def amicable_numbers_sum(limit):\r\n    if not isinstance(limit, int):\r\n        return \"Input is not an integer!\"\r\n    if limit < 1:\r\n        return \"Input must be bigger than 0!\"\r\n    amicables = set()\r\n    for num in range(2, limit+1):\r\n        if num in amicables:\r\n            continue\r\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\r\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\r\n        if num == sum_fact2 and num != sum_fact:\r\n            amicables.add(num)\r\n            amicables.add(sum_fact2)\r\n    return sum(amicables)", "task_id": "Python/123", "test_setup": "", "test": ["assert amicable_numbers_sum(999)==504", "assert amicable_numbers_sum(9999)==31626", "assert amicable_numbers_sum(99)==0"], "challenge_test_list": [], "func_title": "def amicable_numbers_sum(limit):\r", "prompt_text_chinese": "写一个函数来求从1到指定数字的所有友好数字的和。", "code_comment": "定义函数 amicable_numbers_sum，接收一个参数 limit，表示待寻找的上限\n函数的作用是寻找所有在 limit 范围内的亲和数，并返回它们的和\n如果输入的 limit 不是整数，则返回错误提示信息\n如果输入的 limit 小于 1，则返回错误提示信息\n定义集合 amicables，用于保存找到的亲和数\n遍历 2 到 limit 范围内的每个数 num\n如果 num 已经被记录为亲和数，则跳过本次循环\n计算 num 所有因子的和\n计算 sum_fact 所有因子的和\n如果满足 num == sum_fact2 且 num 不等于 sum_fact，则说明找到了一对亲和数\n将 num 添加到亲和数集合 amicables 中\n将 sum_fact2 添加到亲和数集合 amicables 中\n返回亲和数集合 amicables 中所有元素的和\n"}
{"prompt": "Write a function to get the angle of a complex number.", "canonical_solution": "import cmath\r\ndef angle_complex(a,b):\r\n  cn=complex(a,b)\r\n  angle=cmath.phase(a+b)\r\n  return angle", "task_id": "Python/124", "test_setup": "", "test": ["assert angle_complex(0,1j)==1.5707963267948966 ", "assert angle_complex(2,1j)==0.4636476090008061", "assert angle_complex(0,2j)==1.5707963267948966"], "challenge_test_list": [], "func_title": "def angle_complex(a,b):\r", "prompt_text_chinese": "写一个函数来获得一个复数的角度。", "code_comment": "导入 cmath 模块\n定义函数 angle_complex，接收两个参数 a 和 b，表示复数的实部和虚部\n函数的作用是计算复数对应向量与实轴正方向的夹角，并返回该夹角的弧度值\n定义复数 cn，其实部为 a，虚部为 b\n使用 cmath.phase 函数计算复数 cn 对应向量与实轴正方向的夹角，并将结果赋值给变量 angle\n返回夹角的弧度值\n"}
{"prompt": "Write a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.", "canonical_solution": "def find_length(string, n): \r\n\tcurrent_sum = 0\r\n\tmax_sum = 0\r\n\tfor i in range(n): \r\n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \r\n\t\tif current_sum < 0: \r\n\t\t\tcurrent_sum = 0\r\n\t\tmax_sum = max(current_sum, max_sum) \r\n\treturn max_sum if max_sum else 0", "task_id": "Python/125", "test_setup": "", "test": ["assert find_length(\"11000010001\", 11) == 6", "assert find_length(\"10111\", 5) == 1", "assert find_length(\"11011101100101\", 14) == 2 "], "challenge_test_list": [], "func_title": "def find_length(string, n): \r", "prompt_text_chinese": "写一个函数，找出给定的二进制字符串的任何子字符串中的0和1的最大差别。", "code_comment": "定义函数 find_length，接收两个参数 string 和 n，分别表示待搜索的字符串和字符串长度\n函数的作用是在字符串 string 中找到一个最长的连续子串，使得其中 0 的数量等于 1 的数量，返回该子串的长度\n定义变量 current_sum，其初始值为 0\n定义变量 max_sum，其初始值为 0\n遍历字符串 string 中的每个字符\n如果当前字符为 '0'，则 current_sum 加 1；否则减 1\n如果 current_sum 小于 0，则将其重新置为 0\n记录 current_sum 和 max_sum 中的较大值\n如果 max_sum 不为 0，则返回该值；否则返回 0\n注意这里使用了 Python 的三元表达式"}
{"prompt": "Write a python function to find the sum of common divisors of two given numbers.", "canonical_solution": "def sum(a,b): \r\n    sum = 0\r\n    for i in range (1,min(a,b)): \r\n        if (a % i == 0 and b % i == 0): \r\n            sum += i \r\n    return sum", "task_id": "Python/126", "test_setup": "", "test": ["assert sum(10,15) == 6", "assert sum(100,150) == 93", "assert sum(4,6) == 3"], "challenge_test_list": [], "func_title": "def sum(a,b): \r", "prompt_text_chinese": "写一个python函数，找出两个给定数字的共同除数之和。", "code_comment": "定义函数 sum，接收两个参数 a 和 b，分别表示待求最大公约数的两个正整数\n函数的作用是计算 a 和 b 的最大公约数，并返回其值\n定义变量 sum，其初始值为 0\n遍历 1 到 min(a, b)-1 范围内的每个整数 i\n如果 i 是 a 和 b 的公约数，则将其加入变量 sum 中\n返回变量 sum，即 a 和 b 的最大公约数\n"}
{"prompt": "Write a function to multiply two integers without using the * operator in python.", "canonical_solution": "def multiply_int(x, y):\r\n    if y < 0:\r\n        return -multiply_int(x, -y)\r\n    elif y == 0:\r\n        return 0\r\n    elif y == 1:\r\n        return x\r\n    else:\r\n        return x + multiply_int(x, y - 1)", "task_id": "Python/127", "test_setup": "", "test": ["assert multiply_int(10,20)==200", "assert multiply_int(5,10)==50", "assert multiply_int(4,8)==32"], "challenge_test_list": [], "func_title": "def multiply_int(x, y):\r", "prompt_text_chinese": "写一个函数，在不使用Python中的*操作符的情况下将两个整数相乘。", "code_comment": "定义函数 multiply_int，接收两个参数 x 和 y，分别表示待相乘的两个整数\n函数的作用是计算两个整数的乘积，并返回结果\n如果乘数 y 为负数，则调用函数 multiply_int 对原参数取反后再次计算结果，并将其取相反数后返回\n如果乘数 y 为 0，则直接返回 0\n如果乘数 y 为 1，则直接返回 x\n如果乘数 y 大于 1，则递归调用函数 multiply_int，并将结果与 x 相加后返回\n注意这里使用了 Python 的递归调用"}
{"prompt": "Write a function to shortlist words that are longer than n from a given list of words.", "canonical_solution": "def long_words(n, str):\r\n    word_len = []\r\n    txt = str.split(\" \")\r\n    for x in txt:\r\n        if len(x) > n:\r\n            word_len.append(x)\r\n    return word_len\t", "task_id": "Python/128", "test_setup": "", "test": ["assert long_words(3,\"python is a programming language\")==['python','programming','language']", "assert long_words(2,\"writing a program\")==['writing','program']", "assert long_words(5,\"sorting list\")==['sorting']"], "challenge_test_list": [], "func_title": "def long_words(n, str):\r", "prompt_text_chinese": "写一个函数，从一个给定的单词列表中筛选出长度大于n的单词。", "code_comment": "定义函数 long_words，接收两个参数 n 和 str，分别表示待筛选的字符串长度和待筛选的字符串\n函数的作用是在字符串 str 中找到所有长度大于 n 的单词，并返回它们组成的列表\n定义列表 word_len，用于保存长度大于 n 的单词\n使用 split 方法将字符串 str 按照空格拆分成单词，并将其保存到列表 txt 中\n遍历列表 txt 中的每个单词\n如果单词的长度大于 n，则将其添加到列表 word_len 中\n返回列表 word_len，即所有长度大于 n 的单词组成的列表"}
{"prompt": "Write a function to calculate magic square.", "canonical_solution": "def magic_square_test(my_matrix):\r\n    iSize = len(my_matrix[0])\r\n    sum_list = []\r\n    sum_list.extend([sum (lines) for lines in my_matrix])   \r\n    for col in range(iSize):\r\n        sum_list.append(sum(row[col] for row in my_matrix))\r\n    result1 = 0\r\n    for i in range(0,iSize):\r\n        result1 +=my_matrix[i][i]\r\n    sum_list.append(result1)      \r\n    result2 = 0\r\n    for i in range(iSize-1,-1,-1):\r\n        result2 +=my_matrix[i][i]\r\n    sum_list.append(result2)\r\n    if len(set(sum_list))>1:\r\n        return False\r\n    return True", "task_id": "Python/129", "test_setup": "", "test": ["assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True", "assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]])==True", "assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 7]])==False"], "challenge_test_list": [], "func_title": "def magic_square_test(my_matrix):\r", "prompt_text_chinese": "写一个函数来计算魔方。", "code_comment": "定义函数 magic_square_test，接收一个参数 my_matrix，表示一个二维矩阵\n函数的作用是判断二维矩阵 my_matrix 是否是幻方，并返回判断结果\n定义变量 iSize，表示矩阵的大小（即行数或列数）\n定义列表 sum_list，用于保存矩阵中每一行、每一列和每一条对角线的数字之和\n将矩阵中每一行的数字之和添加到列表 sum_list 中\n遍历矩阵中的每一列\n将矩阵中每一列的数字之和添加到列表 sum_list 中\n定义变量 result1，初始值为 0\n遍历矩阵的主对角线\n将主对角线上的数字相加，并将结果赋值给变量 result1\n将主对角线上的数字之和添加到列表 sum_list 中\n定义变量 result2，初始值为 0\n遍历矩阵的副对角线\n将副对角线上的数字相加，并将结果赋值给变量 result2\n将副对角线上的数字之和添加到列表 sum_list 中\n如果列表 sum_list 中有大于 1 个不同的元素，则说明矩阵不是幻方，返回 False\n否则，说明矩阵是幻方，返回 True"}
{"prompt": "Write a function to find the item with maximum frequency in a given list.", "canonical_solution": "from collections import defaultdict\r\ndef max_occurrences(nums):\r\n    dict = defaultdict(int)\r\n    for i in nums:\r\n        dict[i] += 1\r\n    result = max(dict.items(), key=lambda x: x[1]) \r\n    return result", "task_id": "Python/130", "test_setup": "", "test": ["assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==(2, 5)", "assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,16,18])==(8, 2)", "assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==(20, 3)"], "challenge_test_list": [], "func_title": "def max_occurrences(nums):\r", "prompt_text_chinese": "写一个函数，在一个给定的列表中找到频率最高的项目。", "code_comment": "导入 collections 模块中的 defaultdict 类\n定义函数 max_occurrences，接收一个参数 nums，表示待寻找众数的列表\n函数的作用是在列表 nums 中找到出现次数最多的元素，并返回该元素及其出现次数\n定义 defaultdict，用于保存每个元素的出现次数\n遍历列表 nums 中的每个元素\n将当前元素在 defaultdict 中的计数加 1\n使用 max 函数和 lambda 表达式，找到 defaultdict 中出现次数最多的元素及其出现次数，并将结果保存到变量 result 中\n返回 result，即出现次数最多的元素及其出现次数"}
{"prompt": "Write a python function to reverse only the vowels of a given string.", "canonical_solution": "def reverse_vowels(str1):\r\n\tvowels = \"\"\r\n\tfor char in str1:\r\n\t\tif char in \"aeiouAEIOU\":\r\n\t\t\tvowels += char\r\n\tresult_string = \"\"\r\n\tfor char in str1:\r\n\t\tif char in \"aeiouAEIOU\":\r\n\t\t\tresult_string += vowels[-1]\r\n\t\t\tvowels = vowels[:-1]\r\n\t\telse:\r\n\t\t\tresult_string += char\r\n\treturn result_string", "task_id": "Python/131", "test_setup": "", "test": ["assert reverse_vowels(\"Python\") == \"Python\"", "assert reverse_vowels(\"USA\") == \"ASU\"", "assert reverse_vowels(\"ab\") == \"ab\""], "challenge_test_list": [], "func_title": "def reverse_vowels(str1):\r", "prompt_text_chinese": "写一个Python函数，只逆转给定字符串的元音。", "code_comment": "定义函数 reverse_vowels，接收一个参数 str1，表示待翻转元音字母的字符串\n函数的作用是将字符串 str1 中的元音字母翻转位置，并返回翻转后的字符串\n定义空字符串 vowels，用于保存字符串 str1 中所有的元音字母\n遍历字符串 str1 中的每个字符\n如果当前字符为元音字母，则将其添加到字符串 vowels 中\n定义空字符串 result_string，用于保存翻转后的字符串\n再次遍历字符串 str1 中的每个字符\n如果当前字符为元音字母，则将字符串 vowels 中的最后一个元音字母添加到字符串 result_string 中\n同时将字符串 vowels 中的最后一个元音字母删除\n如果当前字符不是元音字母，则直接将其添加到字符串 result_string 中\n返回翻转后的字符串，即字符串 str1 中的元音字母翻转位置后的结果"}
{"prompt": "Write a function to convert tuple to a string.", "canonical_solution": "def tup_string(tup1):\r\n  str =  ''.join(tup1)\r\n  return str", "task_id": "Python/132", "test_setup": "", "test": ["assert tup_string(('e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's'))==(\"exercises\")", "assert tup_string(('p','y','t','h','o','n'))==(\"python\")", "assert tup_string(('p','r','o','g','r','a','m'))==(\"program\")"], "challenge_test_list": [], "func_title": "def tup_string(tup1):\r", "prompt_text_chinese": "写一个将元组转换为字符串的函数。", "code_comment": "定义函数 tup_string，接收一个参数 tup1，表示待转换为字符串的元组\n函数的作用是将元组转换为字符串，并返回结果\n使用 join 方法将元组中的所有元素组合成一个字符串，并将其赋值给变量 str\n返回变量 str，即元组转换后的字符串"}
{"prompt": "Write a function to calculate the sum of the negative numbers of a given list of numbers using lambda function.", "canonical_solution": "def sum_negativenum(nums):\r\n  sum_negativenum = list(filter(lambda nums:nums<0,nums))\r\n  return sum(sum_negativenum)", "task_id": "Python/133", "test_setup": "", "test": ["assert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17])==-32", "assert sum_negativenum([10,15,-14,13,-18,12,-20])==-52", "assert sum_negativenum([19, -65, 57, 39, 152,-639, 121, 44, 90, -190])==-894"], "challenge_test_list": [], "func_title": "def sum_negativenum(nums):\r", "prompt_text_chinese": "写一个函数，用lambda函数计算给定的数字列表的负数之和。", "code_comment": "定义函数 sum_negativenum，接收一个参数 nums，表示待计算负数和的列表\n函数的作用是计算列表 nums 中所有负数的和，并返回结果\n使用 filter 函数和 lambda 表达式，找到列表 nums 中所有小于 0 的元素，并将其保存到列表 sum_negativenum 中\n返回 sum_negativenum 列表中所有元素的和\n"}
{"prompt": "Write a python function to check whether the last element of given array is even or odd after performing an operation p times.", "canonical_solution": "def check_last (arr,n,p): \r\n    _sum = 0\r\n    for i in range(n): \r\n        _sum = _sum + arr[i] \r\n    if p == 1: \r\n        if _sum % 2 == 0: \r\n            return \"ODD\"\r\n        else: \r\n            return \"EVEN\"\r\n    return \"EVEN\"\r\n      ", "task_id": "Python/134", "test_setup": "", "test": ["assert check_last([5,7,10],3,1) == \"ODD\"", "assert check_last([2,3],2,3) == \"EVEN\"", "assert check_last([1,2,3],3,1) == \"ODD\""], "challenge_test_list": [], "func_title": "def check_last (arr,n,p): \r", "prompt_text_chinese": "写一个Python函数，在进行了p次操作后，检查给定数组的最后一个元素是偶数还是奇数。", "code_comment": "定义函数 check_last，接收三个参数 arr、n 和 p，分别表示待计算的列表、列表长度和待判断的参数\n函数的作用是判断列表 arr 中所有元素之和的奇偶性，并返回判断结果\n定义变量 _sum，初始值为 0\n遍历列表 arr 中的每个元素\n将当前元素加入变量 _sum 中\n如果参数 p 为 1\n如果变量 _sum 的值为偶数，则返回 \"ODD\"\n否则返回 \"EVEN\"\n如果参数 p 不为 1，则返回 \"EVEN\""}
{"prompt": "Write a function to find the nth hexagonal number.", "canonical_solution": "def hexagonal_num(n): \r\n\treturn n*(2*n - 1) ", "task_id": "Python/135", "test_setup": "", "test": ["assert hexagonal_num(10) == 190", "assert hexagonal_num(5) == 45", "assert hexagonal_num(7) == 91"], "challenge_test_list": [], "func_title": "def hexagonal_num(n): \r", "prompt_text_chinese": "写一个函数来寻找第n个六边形的数字。", "code_comment": "定义函数 hexagonal_num，接收一个参数 n，表示待计算六边形数的项数\n函数的作用是计算第 n 项六边形数，并返回结果\n根据六边形数的递推公式，计算第 n 项六边形数并返回结果"}
{"prompt": "Write a function to calculate electricity bill.", "canonical_solution": "def cal_electbill(units):\r\n if(units < 50):\r\n    amount = units * 2.60\r\n    surcharge = 25\r\n elif(units <= 100):\r\n    amount = 130 + ((units - 50) * 3.25)\r\n    surcharge = 35\r\n elif(units <= 200):\r\n    amount = 130 + 162.50 + ((units - 100) * 5.26)\r\n    surcharge = 45\r\n else:\r\n    amount = 130 + 162.50 + 526 + ((units - 200) * 8.45)\r\n    surcharge = 75\r\n total = amount + surcharge\r\n return total", "task_id": "Python/136", "test_setup": "", "test": ["assert cal_electbill(75)==246.25", "assert cal_electbill(265)==1442.75", "assert cal_electbill(100)==327.5"], "challenge_test_list": [], "func_title": "def cal_electbill(units):\r", "prompt_text_chinese": "写一个计算电费的函数。", "code_comment": "定义函数 cal_electbill，接收一个参数 units，表示用电量\n函数的作用是根据用电量计算电费，并返回总费用\n如果用电量小于 50\n计算电费 amount，每单位电费用为 2.60 元\n计算附加费 surcharge，为 25 元\n如果用电量在 50 到 100 之间\n计算电费 amount，前 50 单位电费用为 130 元，超出部分每单位电费用为 3.25 元\n计算附加费 surcharge，为 35 元\n如果用电量在 100 到 200 之间\n计算电费 amount，前 50 单位电费用为 130 元，50 到 100 单位电费用为 162.50 元，超出部分每单位电费用为 5.26 元\n计算附加费 surcharge，为 45 元\n如果用电量大于 200\n计算电费 amount，前 50 单位电费用为 130 元，50 到 100 单位电费用为 162.50 元，100 到 200 单位电费用为 526 元，超出部分每单位电费用为 8.45 元\n计算附加费 surcharge，为 75 元\n计算总费用 total，为电费和附加费之和\n返回总费用 total"}
{"prompt": "Write a function to find the ration of zeroes in an array of integers.", "canonical_solution": "from array import array\r\ndef zero_count(nums):\r\n    n = len(nums)\r\n    n1 = 0\r\n    for x in nums:\r\n        if x == 0:\r\n            n1 += 1\r\n        else:\r\n          None\r\n    return round(n1/n,2)", "task_id": "Python/137", "test_setup": "", "test": ["assert zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.15", "assert zero_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.00", "assert zero_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.00"], "challenge_test_list": [], "func_title": "def zero_count(nums):\r", "prompt_text_chinese": "写一个函数来寻找整数阵列中的零的比例。", "code_comment": "导入 array 模块中的 array 类\n定义函数 zero_count，接收一个参数 nums，表示待计算零的比例的数组\n函数的作用是计算数组 nums 中零的比例，并返回结果（保留两位小数）\n计算数组 nums 的长度，即数组中元素的个数\n定义变量 n1，表示数组 nums 中零的个数，初始值为 0\n遍历数组 nums 中的每个元素\n如果当前元素为零，则将变量 n1 加 1\n计算数组 nums 中零的比例，并将结果保留两位小数后返回"}
{"prompt": "Write a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.", "canonical_solution": "def is_Sum_Of_Powers_Of_Two(n): \r\n    if (n % 2 == 1): \r\n        return False\r\n    else: \r\n        return True", "task_id": "Python/138", "test_setup": "", "test": ["assert is_Sum_Of_Powers_Of_Two(10) == True", "assert is_Sum_Of_Powers_Of_Two(7) == False", "assert is_Sum_Of_Powers_Of_Two(14) == True"], "challenge_test_list": [], "func_title": "def is_Sum_Of_Powers_Of_Two(n): \r", "prompt_text_chinese": "写一个python函数来检查给定的数字是否可以表示为2的非零次方之和。", "code_comment": "定义函数 is_Sum_Of_Powers_Of_Two，接收一个参数 n，表示待判断的整数\n函数的作用是判断整数 n 是否为 2 的幂次方之和，并返回判断结果\n如果整数 n 为奇数，则一定不是 2 的幂次方之和，返回 False\n如果整数 n 为偶数，则有可能是 2 的幂次方之和，继续判断\n如果整数 n 是 2 的幂次方之和，则返回 True，否则返回 False"}
{"prompt": "Write a function to find the circumference of a circle.", "canonical_solution": "def circle_circumference(r):\r\n  perimeter=2*3.1415*r\r\n  return perimeter", "task_id": "Python/139", "test_setup": "", "test": ["assert circle_circumference(10)==62.830000000000005", "assert circle_circumference(5)==31.415000000000003", "assert circle_circumference(4)==25.132"], "challenge_test_list": [], "func_title": "def circle_circumference(r):\r", "prompt_text_chinese": "写一个函数来寻找圆的周长。", "code_comment": "定义函数 circle_circumference，接收一个参数 r，表示圆的半径\n函数的作用是计算圆的周长，并返回结果\n根据圆的周长公式，计算圆的周长 perimeter\n返回计算结果 perimeter\n"}
{"prompt": "Write a function to extract elements that occur singly in the given tuple list.", "canonical_solution": "def extract_singly(test_list):\r\n  res = []\r\n  temp = set()\r\n  for inner in test_list:\r\n    for ele in inner:\r\n      if not ele in temp:\r\n        temp.add(ele)\r\n        res.append(ele)\r\n  return (res) ", "task_id": "Python/140", "test_setup": "", "test": ["assert extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)]) == [3, 4, 5, 7, 1]", "assert extract_singly([(1, 2, 3), (4, 2, 3), (7, 8)]) == [1, 2, 3, 4, 7, 8]", "assert extract_singly([(7, 8, 9), (10, 11, 12), (10, 11)]) == [7, 8, 9, 10, 11, 12]"], "challenge_test_list": [], "func_title": "def extract_singly(test_list):\r", "prompt_text_chinese": "写一个函数，提取在给定元组列表中单一出现的元素。", "code_comment": "定义函数 extract_singly，接收一个参数 test_list，表示待提取元素的列表\n函数的作用是提取列表 test_list 中所有不重复的元素，并返回结果\n定义空列表 res，用于保存提取后的元素\n定义空集合 temp，用于保存已经提取的元素\n遍历列表 test_list 中的每个子列表\n遍历当前子列表 inner 中的每个元素\n如果当前元素不在集合 temp 中，则将其添加到集合 temp 中，并将其添加到列表 res 中\n返回提取后的元素列表 res"}
{"prompt": "Write a function to sort a list of elements using pancake sort.", "canonical_solution": "def pancake_sort(nums):\r\n    arr_len = len(nums)\r\n    while arr_len > 1:\r\n        mi = nums.index(max(nums[0:arr_len]))\r\n        nums = nums[mi::-1] + nums[mi+1:len(nums)]\r\n        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]\r\n        arr_len -= 1\r\n    return nums", "task_id": "Python/141", "test_setup": "", "test": ["assert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]", "assert pancake_sort([98, 12, 54, 36, 85]) == [12, 36, 54, 85, 98]", "assert pancake_sort([41, 42, 32, 12, 23]) == [12, 23, 32, 41, 42]"], "challenge_test_list": [], "func_title": "def pancake_sort(nums):\r", "prompt_text_chinese": "写一个函数，用煎饼排序法对一个元素列表进行排序。", "code_comment": "定义函数 pancake_sort，接收一个参数 nums，表示待排序的列表\n函数的作用是对列表 nums 进行煎饼排序，并返回排序后的列表\n获取列表 nums 的长度\n当列表 nums 还未排序完成时\n找到 nums 的前 arr_len 个元素中的最大值，并记录其下标\n将 nums 中前 mi 个元素翻转后放到列表的前面，再将 mi 之后的元素接到末尾，即完成了一次翻转操作\n将 nums 中前 arr_len 个元素翻转后放到列表的前面，再将 arr_len 之后的元素接到末尾，即完成了一次翻转操作\n将 arr_len 减 1，表示已经将最大值放到了列表的末尾\n返回煎饼排序后的列表 nums\n"}
{"prompt": "Write a function to count the same pair in three given lists.", "canonical_solution": "def count_samepair(list1,list2,list3):\r\n    result = sum(m == n == o for m, n, o in zip(list1,list2,list3))\r\n    return result", "task_id": "Python/142", "test_setup": "", "test": ["assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,9],[2,1,3,1,2,6,7,9])==3", "assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==4", "assert count_samepair([1,2,3,4,2,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==5"], "challenge_test_list": [], "func_title": "def count_samepair(list1,list2,list3):\r", "prompt_text_chinese": "写一个函数来计算三个给定列表中的同一对。", "code_comment": "定义函数 count_samepair，接收三个参数 list1、list2、list3，分别表示三个列表\n函数的作用是计算三个列表中相同位置上元素相同的对数，并返回结果\n使用 zip 函数将三个列表中相同位置的元素组合成元组，然后通过遍历这些元组的方式，判断其中所有元素是否相等，并将相等的元组计数\n返回计算结果"}
{"prompt": "Write a function to find number of lists present in the given tuple.", "canonical_solution": "def find_lists(Input): \r\n\tif isinstance(Input, list): \r\n\t\treturn 1\r\n\telse: \r\n\t\treturn len(Input) ", "task_id": "Python/143", "test_setup": "", "test": ["assert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2", "assert find_lists(([1, 2], [3, 4], [5, 6]))  == 3", "assert find_lists(([9, 8, 7, 6, 5, 4, 3, 2, 1])) == 1"], "challenge_test_list": [], "func_title": "def find_lists(Input): \r", "prompt_text_chinese": "写一个函数来查找给定元组中存在的列表的数量。", "code_comment": "定义函数 find_lists，接收一个参数 Input，表示待查找的列表或元素\n函数的作用是判断参数 Input 是否为列���，如果是则返回 1，否则返回其长度\n判断参数 Input 是否为列表\n如果是，则返回 1\n如果不是，则返回其长度\n"}
{"prompt": "Write a python function to find the sum of absolute differences in all pairs of the given array.", "canonical_solution": "def sum_Pairs(arr,n): \r\n    sum = 0\r\n    for i in range(n - 1,-1,-1): \r\n        sum += i*arr[i] - (n-1-i) * arr[i] \r\n    return sum", "task_id": "Python/144", "test_setup": "", "test": ["assert sum_Pairs([1,8,9,15,16],5) == 74", "assert sum_Pairs([1,2,3,4],4) == 10", "assert sum_Pairs([1,2,3,4,5,7,9,11,14],9) == 188"], "challenge_test_list": [], "func_title": "def sum_Pairs(arr,n): \r", "prompt_text_chinese": "写一个python函数，找出给定数组中所有配对的绝对差异之和。", "code_comment": "定义函数 sum_Pairs，接收两个参数 arr 和 n，分别表示一个数组和数组的长度\n函数的作用是计算数组中所有元素与其下标的乘积与其与数组末尾的距离的乘积之差的和，并返回结果\n定义变量 sum，初始值为 0\n从数组末尾开始遍历数组 arr 中的每个元素\n计算当前元素与其下标的乘积与其与数组末尾的距离的乘积之差，并将其加到变量 sum 上\n返回变量 sum 的值"}
{"prompt": "Write a python function to find the maximum difference between any two elements in a given array.", "canonical_solution": "def max_Abs_Diff(arr,n): \r\n    minEle = arr[0] \r\n    maxEle = arr[0] \r\n    for i in range(1, n): \r\n        minEle = min(minEle,arr[i]) \r\n        maxEle = max(maxEle,arr[i]) \r\n    return (maxEle - minEle) ", "task_id": "Python/145", "test_setup": "", "test": ["assert max_Abs_Diff((2,1,5,3),4) == 4", "assert max_Abs_Diff((9,3,2,5,1),5) == 8", "assert max_Abs_Diff((3,2,1),3) == 2"], "challenge_test_list": [], "func_title": "def max_Abs_Diff(arr,n): \r", "prompt_text_chinese": "写一个Python函数来查找给定数组中任何两个元素之间的最大差异。", "code_comment": "定义函数 max_Abs_Diff，接收两个参数 arr 和 n，分别表示一个数组和数组的长度\n函数的作用是计算数组中最大元素与最小元素的差的绝对值，并返回结果\n定义变量 minEle，初始值为数组 arr 的第一个元素\n定义变量 maxEle，初始值为数组 arr 的第一个元素\n遍历数组 arr 中的每个元素\n更新变量 minEle 的值，为数组 arr 中的最小元素\n更新变量 maxEle 的值，为数组 arr 中的最大元素\n返回最大元素与最小元素的差的绝对值\n"}
{"prompt": "Write a function to find the ascii value of total characters in a string.", "canonical_solution": "def ascii_value_string(str1):\r\n  for i in range(len(str1)):\r\n   return ord(str1[i])", "task_id": "Python/146", "test_setup": "", "test": ["assert ascii_value_string(\"python\")==112", "assert ascii_value_string(\"Program\")==80", "assert ascii_value_string(\"Language\")==76"], "challenge_test_list": [], "func_title": "def ascii_value_string(str1):\r", "prompt_text_chinese": "写一个函数来查找一个字符串中全部字符的ascii值。", "code_comment": "定义函数 ascii_value_string，接收一个参数 str1，表示待计算 ASCII 值的字符串\n函数的作用是计算字符串 str1 中第一个字符的 ASCII 值，并返回结果\n遍历字符串 str1 中的每个字符\n使用 ord 函数计算字符的 ASCII 值，并将其返回"}
{"prompt": "Write a function to find the maximum total path sum in the given triangle.", "canonical_solution": "def max_path_sum(tri, m, n): \r\n\tfor i in range(m-1, -1, -1): \r\n\t\tfor j in range(i+1): \r\n\t\t\tif (tri[i+1][j] > tri[i+1][j+1]): \r\n\t\t\t\ttri[i][j] += tri[i+1][j] \r\n\t\t\telse: \r\n\t\t\t\ttri[i][j] += tri[i+1][j+1] \r\n\treturn tri[0][0]", "task_id": "Python/147", "test_setup": "", "test": ["assert max_path_sum([[1, 0, 0], [4, 8, 0], [1, 5, 3]], 2, 2) == 14", "assert max_path_sum([[13, 0, 0], [7, 4, 0], [2, 4, 6]], 2, 2) == 24 ", "assert max_path_sum([[2, 0, 0], [11, 18, 0], [21, 25, 33]], 2, 2) == 53"], "challenge_test_list": [], "func_title": "def max_path_sum(tri, m, n): \r", "prompt_text_chinese": "写一个函数来查找给定三角形中的最大总路径和。", "code_comment": "定义函数 max_path_sum，接收三个参数 tri、m 和 n，分别表示一个二维列表、列表的行数和列数\n函数的作用是计算从三角形的顶部到底部的最大路径之和，并返回结果\n从三角形的倒数第二行开始往上计算每个节点的最大路径之和\n对于每一行中的每个节点，计算它的最大路径之和\n如果它的左子节点的最大路径之和大于右子节点的最大路径之和，则将左子节点的值加到当前节点上\n否则将右子节点的值加到当前节点上\n返回三角形的顶部节点的值，即为从顶部到底部的最大路径之和"}
{"prompt": "Write a function to divide a number into two parts such that the sum of digits is maximum.", "canonical_solution": "def sum_digits_single(x) : \r\n    ans = 0\r\n    while x : \r\n        ans += x % 10\r\n        x //= 10  \r\n    return ans \r\ndef closest(x) : \r\n    ans = 0\r\n    while (ans * 10 + 9 <= x) : \r\n        ans = ans * 10 + 9  \r\n    return ans   \r\ndef sum_digits_twoparts(N) : \r\n    A = closest(N)  \r\n    return sum_digits_single(A) + sum_digits_single(N - A) ", "task_id": "Python/148", "test_setup": "", "test": ["assert sum_digits_twoparts(35)==17", "assert sum_digits_twoparts(7)==7", "assert sum_digits_twoparts(100)==19"], "challenge_test_list": [], "func_title": "def sum_digits_single(x) : \r", "prompt_text_chinese": "写一个函数，将一个数字分成两部分，使其数字之和为最大值。", "code_comment": "定义函数 sum_digits_single，接收一个参数x，表示一个整数\n函数的作用是计算参数 x 的各位数字之和，并返回结果\n定义变量 ans，初始值为 0\n将当前 x 的个位数字加到 ans 上\n将 x 除以 10，丢弃个位数字\n返回计算结果 ans\n定义函数 closest，接收一个参数x，表示一个整数\n函数的作用是找到小于等于 x 的所有数字中，每个数字的各位数字之和最大的一位数字，并返回结果\n定义变量 ans，初始值为 0\n将 ans 的值乘以 10 并加上 9，直到其值大于 x 为止\n返回计算结果 ans\n定义函数 sum_digits_twoparts，接收一个参数 N，表示一个整数\n函数的作用是将整数 N 拆成两部分：closest(N) 和 N - closest(N)，然后计算这两部分的各位数字之和之和，并返回结果\n找到小于等于 N 的所有数字中，每个数字的各位数字之和最大的一位数字 A\n计算 A 和 N - A 的各位数字之和之和，并将其返回"}
{"prompt": "Write a function to find the longest subsequence such that the difference between adjacents is one for the given array.", "canonical_solution": "def longest_subseq_with_diff_one(arr, n): \r\n\tdp = [1 for i in range(n)] \r\n\tfor i in range(n): \r\n\t\tfor j in range(i): \r\n\t\t\tif ((arr[i] == arr[j]+1) or (arr[i] == arr[j]-1)): \r\n\t\t\t\tdp[i] = max(dp[i], dp[j]+1) \r\n\tresult = 1\r\n\tfor i in range(n): \r\n\t\tif (result < dp[i]): \r\n\t\t\tresult = dp[i] \r\n\treturn result", "task_id": "Python/149", "test_setup": "", "test": ["assert longest_subseq_with_diff_one([1, 2, 3, 4, 5, 3, 2], 7) == 6", "assert longest_subseq_with_diff_one([10, 9, 4, 5, 4, 8, 6], 7) == 3", "assert longest_subseq_with_diff_one([1, 2, 3, 2, 3, 7, 2, 1], 8) == 7"], "challenge_test_list": [], "func_title": "def longest_subseq_with_diff_one(arr, n): \r", "prompt_text_chinese": "写一个函数，找出最长的子序列，使给定数组的邻接点之差为1。", "code_comment": "定义函数 longest_subseq_with_diff_one，接收两个参数 arr 和 n，分别表示一个数组和数组的长度\n函数的作用是在数组 arr 中找到一个最长的子序列，使得其中的任意两个元素的差的绝对值为 1，并返回该子序列的长度\n初始化动态规划数组 dp，每个元素初始值为 1\n遍历数组 arr 中的每个元素\n遍历 i 之前的每个元素\n如果 arr[i] 和 arr[j] 的差的绝对值为 1\n则 dp[i] 的值为 dp[j]+1 和 dp[i] 中的最大值\n初始化变量 result，表示最长的子序列长度，初始值为 1\n遍历数组 dp 中的每个元素\n如果 dp[i] 大于 result，则将 result 的值更新为 dp[i]\n返回最长的子序列长度"}
{"prompt": "Write a python function to find whether the given number is present in the infinite sequence or not.", "canonical_solution": "def does_Contain_B(a,b,c): \r\n    if (a == b): \r\n        return True\r\n    if ((b - a) * c > 0 and (b - a) % c == 0): \r\n        return True\r\n    return False", "task_id": "Python/150", "test_setup": "", "test": ["assert does_Contain_B(1,7,3) == True", "assert does_Contain_B(1,-3,5) == False", "assert does_Contain_B(3,2,5) == False"], "challenge_test_list": [], "func_title": "def does_Contain_B(a,b,c): \r", "prompt_text_chinese": "写一个python函数，找出给定的数字是否存在于无限序列中。", "code_comment": "定义函数 does_Contain_B，接收三个参数 a、b 和 c，分别表示三个整数\n函数的作用是判断整数 b 是否在以整数 a 为起点，以整数 c 为步长的等差数列中，如果是则返回 True，否则返回 False\n如果 a 和 b 相等，则返回 True，因为此时 b 肯定在等差数列中\n如果 b - a 与 c 的乘积大于 0，表示 b 和 a 在等差数列中同向移动；且 b - a 是 c 的倍数，则返回 True，否则返回 False\n如果以上条件都不满足，则返回 False\n"}
{"prompt": "Write a python function to check whether the given number is co-prime or not.", "canonical_solution": "def gcd(p,q):\r\n    while q != 0:\r\n        p, q = q,p%q\r\n    return p\r\ndef is_coprime(x,y):\r\n    return gcd(x,y) == 1", "task_id": "Python/151", "test_setup": "", "test": ["assert is_coprime(17,13) == True", "assert is_coprime(15,21) == False", "assert is_coprime(25,45) == False"], "challenge_test_list": [], "func_title": "def gcd(p,q):\r", "prompt_text_chinese": "写一个python函数来检查给定的数字是否是同素数。", "code_comment": "定义函数 gcd，接收两个参数 p 和 q，表示两个整数\n函数的作用是计算 p 和 q 的最大公约数，并返回结果\n当 q 不为 0 时，进行以下操作\n计算 p 和 q 的余数，赋值给 p 和 q\n返回最大公约数 p\n定义函数 is_coprime，接收两个参数 x 和 y，表示两个整数\n函数的作用是判断 x 和 y 是否互质，如果互质，则返回 True，否则返回 False\n如果 x 和 y 的最大公约数为 1，则返回 True，表示 x 和 y 互质，否则返回 False"}
{"prompt": "Write a function to sort the given array by using merge sort.", "canonical_solution": "def merge(a,b):\r\n    c = []\r\n    while len(a) != 0 and len(b) != 0:\r\n        if a[0] < b[0]:\r\n            c.append(a[0])\r\n            a.remove(a[0])\r\n        else:\r\n            c.append(b[0])\r\n            b.remove(b[0])\r\n    if len(a) == 0:\r\n        c += b\r\n    else:\r\n        c += a\r\n    return c\r\ndef merge_sort(x):\r\n    if len(x) == 0 or len(x) == 1:\r\n        return x\r\n    else:\r\n        middle = len(x)//2\r\n        a = merge_sort(x[:middle])\r\n        b = merge_sort(x[middle:])\r\n        return merge(a,b)\r\n", "task_id": "Python/152", "test_setup": "", "test": ["assert merge_sort([3, 4, 2, 6, 5, 7, 1, 9]) == [1, 2, 3, 4, 5, 6, 7, 9]", "assert merge_sort([7, 25, 45, 78, 11, 33, 19]) == [7, 11, 19, 25, 33, 45, 78]", "assert merge_sort([3, 1, 4, 9, 8]) == [1, 3, 4, 8, 9]"], "challenge_test_list": [], "func_title": "def merge(a,b):\r", "prompt_text_chinese": "写一个函数，通过使用合并排序对给定数组进行排序。", "code_comment": "定义函数 merge，接收两个参数 a 和 b，分别表示两个有序列表\n函数的作用是将 a 和 b 合并为一个有序列表，并返回合并后的列表\n定义空列表 c，用于存储合并后的有序列表\n当 a 和 b 都不为空时，进行以下操作\n如果 a 的第一个元素小于 b 的第一个元素，则将 a 的第一个元素添加到 c 中，并从 a 中删除该元素\n否则将 b 的第一个元素添加到 c 中，并从 b 中删除该元素\n如果 a 已经为空，则将 b 中的所有元素添加到 c 的末尾\n否则将 a 中的所有元素添加到 c 的末尾\n返回合并后的有序列表 c\n定义函数 merge_sort，接收一个参数 x，表示一个列表\n函数的作用是使用归并排序算法将列表 x 排序，并返回排序后的列表\n如果列表 x 的长度为 0 或 1，则返回 x\n将列表 x 平均分成两部分，找到中间位置\n对 x 的左半部分进行归并排序\n对 x 的右半部分进行归并排序\n将排序后的左右两部分列表合并为一个有序列表，然后返回该列表"}
{"prompt": "Write a function to find the vertex of a parabola.", "canonical_solution": "def parabola_vertex(a, b, c): \r\n  vertex=(((-b / (2 * a)),(((4 * a * c) - (b * b)) / (4 * a))))\r\n  return vertex", "task_id": "Python/153", "test_setup": "", "test": ["assert parabola_vertex(5,3,2)==(-0.3, 1.55)", "assert parabola_vertex(9,8,4)==(-0.4444444444444444, 2.2222222222222223)", "assert parabola_vertex(2,4,6)==(-1.0, 4.0)"], "challenge_test_list": [], "func_title": "def parabola_vertex(a, b, c): \r", "prompt_text_chinese": "写一个函数来寻找抛物线的顶点。", "code_comment": "定义函数 parabola_vertex，接收三个参数 a、b 和 c，表示二次函数的三个系数\n函数的作用是计算二次函数的顶点坐标，并返回结果\n计算二次函数的顶点坐标，顶点的 x 坐标为 -b / (2a)，y 坐标为 (4ac - b^2) / (4a)\n返回顶点坐标\n"}
{"prompt": "Write a function to extract every specified element from a given two dimensional list.", "canonical_solution": "def specified_element(nums, N):\r\n    result = [i[N] for i in nums]\r\n    return result", "task_id": "Python/154", "test_setup": "", "test": ["assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]", "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]", "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],3)==[2,2,5]"], "challenge_test_list": [], "func_title": "def specified_element(nums, N):\r", "prompt_text_chinese": "写一个函数，从一个给定的二维列表中提取每个指定的元素。", "code_comment": "定义函数 specified_element，接收两个参数 nums 和 N，分别表示一个二维列表和一个整数\n函数的作用是找到二维列表中每个子列表的第 N 个元素，并将这些元素组成一个列表返回\n创建结果列表 result，将二维列表中每个子列表的第 N 个元素添加到 result 中\n返回结果列表 result"}
{"prompt": "Write a python function to toggle all even bits of a given number.", "canonical_solution": "def even_bit_toggle_number(n) : \r\n    res = 0; count = 0; temp = n \r\n    while (temp > 0) :     \r\n        if (count % 2 == 1) : \r\n            res = res | (1 << count)      \r\n        count = count + 1\r\n        temp >>= 1 \r\n    return n ^ res ", "task_id": "Python/155", "test_setup": "", "test": ["assert even_bit_toggle_number(10) == 0", "assert even_bit_toggle_number(20) == 30", "assert even_bit_toggle_number(30) == 20"], "challenge_test_list": [], "func_title": "def even_bit_toggle_number(n) : \r", "prompt_text_chinese": "写一个python函数来切换一个给定数字的所有偶数位。", "code_comment": "定义函数 even_bit_toggle_number，接收一个参数 n，表示一个整数\n函数的作用是将 n 的二进制表示中的偶数位取反，奇数位不变，并返回结果\n定义变量 res，用于存储取反后的结果\n定义变量 count，用于记录当前处理的二进制位的位置\n将 n 的值赋给变量 temp，用于进行位运算\n当 temp 大于 0 时，进行以下操作\n如果 count 为奇数，则将 res 的第 count 位设为 1\ncount 加 1\n将 temp 右移一位，丢弃最低位\n将 n 和 res 进行异或运算，得到取反后的结果，并将其返回"}
{"prompt": "Write a function to convert a tuple of string values to a tuple of integer values.", "canonical_solution": "def tuple_int_str(tuple_str):\r\n    result = tuple((int(x[0]), int(x[1])) for x in tuple_str)\r\n    return result", "task_id": "Python/156", "test_setup": "", "test": ["assert tuple_int_str((('333', '33'), ('1416', '55')))==((333, 33), (1416, 55))", "assert tuple_int_str((('999', '99'), ('1000', '500')))==((999, 99), (1000, 500))", "assert tuple_int_str((('666', '66'), ('1500', '555')))==((666, 66), (1500, 555))"], "challenge_test_list": [], "func_title": "def tuple_int_str(tuple_str):\r", "prompt_text_chinese": "写一个函数，将一个字符串值的元组转换成一个整数值的元组。", "code_comment": "定义函数 tuple_int_str，接收一个参数 tuple_str，表示一个由字符串组成的元组\n元组中的每个字符串包含两个数字，数字之间用逗号隔开\n函数的作用是将元组中的每个字符串转换为整数，然后返回新的元组\n使用生成器表达式将每个字符串转换为整数，并组成新的元组，赋值给变量 result\n返回新的元组"}
{"prompt": "Write a function to reflect the run-length encoding from a list.", "canonical_solution": "from itertools import groupby\r\ndef encode_list(list1):\r\n    return [[len(list(group)), key] for key, group in groupby(list1)]", "task_id": "Python/157", "test_setup": "", "test": ["assert encode_list([1,1,2,3,4,4.3,5,1])==[[2, 1], [1, 2], [1, 3], [1, 4], [1, 4.3], [1, 5], [1, 1]]", "assert encode_list('automatically')==[[1, 'a'], [1, 'u'], [1, 't'], [1, 'o'], [1, 'm'], [1, 'a'], [1, 't'], [1, 'i'], [1, 'c'], [1, 'a'], [2, 'l'], [1, 'y']]", "assert encode_list('python')==[[1, 'p'], [1, 'y'], [1, 't'], [1, 'h'], [1, 'o'], [1, 'n']]"], "challenge_test_list": [], "func_title": "def encode_list(list1):\r", "prompt_text_chinese": "写一个函数来反映一个列表的运行长度编码。", "code_comment": "导入 groupby 函数\n定义函数 encode_list，接收一个参数 list1，表示一个列表\n函数的作用是将列表中连续相同的元素编码成一个子列表，并返回新的列表\n使用 groupby 函数将列表中连续相同的元素分组，然后使用列表推导式将每个分组编码成一个子列表\n子列表的第一个元素为分组中相同元素的个数，第二个元素为分组中的元素值\n最后将每个子列表组成一个新的列表，并将其返回\n"}
{"prompt": "Write a python function to find k number of operations required to make all elements equal.", "canonical_solution": "def min_Ops(arr,n,k): \r\n    max1 = max(arr) \r\n    res = 0\r\n    for i in range(0,n):  \r\n        if ((max1 - arr[i]) % k != 0): \r\n            return -1 \r\n        else: \r\n            res += (max1 - arr[i]) / k \r\n    return int(res) ", "task_id": "Python/158", "test_setup": "", "test": ["assert min_Ops([2,2,2,2],4,3) == 0", "assert min_Ops([4,2,6,8],4,3) == -1", "assert min_Ops([21,33,9,45,63],5,6) == 24"], "challenge_test_list": [], "func_title": "def min_Ops(arr,n,k): \r", "prompt_text_chinese": "写一个Python函数，找出使所有元素相等所需的操作数k。", "code_comment": "定义函数 min_Ops，接收三个参数 arr、n 和 k，分别表示一个列表、列表的长度和一个整数\n函数的作用是计算将列表 arr 中的每个元素都增加某个整数的最小操作次数，并返回结果\n如果不存在这样的整数使得每个元素都可以通过增加该整数得到，则返回 -1\n找到列表 arr 中的最大元素，赋值给变量 max1\n定义变量 res，用于记录操作次数，初始值为 0\n遍历列表 arr 中的每个元素\n如果 max1 减去该元素的差不是 k 的倍数，则无法通过增加 k 得到该元素，返回 -1\n否则将该元素增加 (max1 - arr[i]) / k 次可以得到 max1，记录操作次数\n将操作次数 res 转换为整数并返回"}
{"prompt": "Write a function to print the season for the given month and day.", "canonical_solution": "def month_season(month,days):\r\n if month in ('January', 'February', 'March'):\r\n\t season = 'winter'\r\n elif month in ('April', 'May', 'June'):\r\n\t season = 'spring'\r\n elif month in ('July', 'August', 'September'):\r\n\t season = 'summer'\r\n else:\r\n\t season = 'autumn'\r\n if (month == 'March') and (days > 19):\r\n\t season = 'spring'\r\n elif (month == 'June') and (days > 20):\r\n\t season = 'summer'\r\n elif (month == 'September') and (days > 21):\r\n\t season = 'autumn'\r\n elif (month == 'October') and (days > 21):\r\n\t season = 'autumn'\r\n elif (month == 'November') and (days > 21):\r\n\t season = 'autumn'\r\n elif (month == 'December') and (days > 20):\r\n\t season = 'winter'\r\n return season", "task_id": "Python/159", "test_setup": "", "test": ["assert month_season('January',4)==('winter')", "assert month_season('October',28)==('autumn')", "assert month_season('June',6)==('spring')"], "challenge_test_list": [], "func_title": "def month_season(month,days):\r", "prompt_text_chinese": "写一个函数来打印给定月份和日期的季节。", "code_comment": "定义函数 month_season，接收两个参数 month 和 days，分别表示一个月份和该月的天数\n函数的作用是根据给定的月份和天数，判断该月份所属的季节，并返回季节名称\n如果月份为 1、2、3 月，则属于冬季\n如果月份为 4、5、6 月，则属于春季\n如果月份为 7、8、9 月，则属于夏季\n否则属于秋季\n如果是 3 月 20 日以后，则属于春季\n如果是 6 月 21 日以后，则属于夏季\n如果是 9 月 22 日以后，则属于秋季\n如果是 10 月 22 日以后，则属于秋季\n如果是 11 月 22 日以后，则属于秋季\n如果是 12 月 21 日以后，则属于冬季\n返回季节名称"}
{"prompt": "Write a function to find x and y that satisfies ax + by = n.", "canonical_solution": "def solution (a, b, n): \r\n\ti = 0\r\n\twhile i * a <= n: \r\n\t\tif (n - (i * a)) % b == 0: \r\n\t\t\treturn (\"x = \",i ,\", y = \", \r\n\t\t\tint((n - (i * a)) / b)) \r\n\t\t\treturn 0\r\n\t\ti = i + 1\r\n\treturn (\"No solution\") ", "task_id": "Python/160", "test_setup": "", "test": ["assert solution(2, 3, 7) == ('x = ', 2, ', y = ', 1)", "assert solution(4, 2, 7) == 'No solution'", "assert solution(1, 13, 17) == ('x = ', 4, ', y = ', 1)"], "challenge_test_list": [], "func_title": "def solution (a, b, n): \r", "prompt_text_chinese": "写一个函数来寻找满足ax+by=n的x和y。", "code_comment": "定义函数 solution，接收三个参数 a、b 和 n，分别表示两个未知数的系数和等式右边的常数\n函数的作用是求解方程 ax + by = n 的所有整数解，并返回一个元组，包含两个整数解 x 和 y\n如果方程无整数解，则返回字符串 \"No solution\"\n定义变量 i，表示解的个数，初始值为 0\n在 ax <= n 的范围内，遍历每个解\n如果 n - ax 是 b 的倍数，则存在整数解\n返回一个元组，包含两个整数解 x 和 y，其中 x = i，y = (n - a*x) / b\n如果有解，返回解并结束函数\n如果无解，则继续遍历下一个解\n如果所有解都被遍历完了，仍然无解，则返回字符串 \"No solution\""}
{"prompt": "Write a function to remove all elements from a given list present in another list.", "canonical_solution": "def remove_elements(list1, list2):\r\n    result = [x for x in list1 if x not in list2]\r\n    return result", "task_id": "Python/161", "test_setup": "", "test": ["assert remove_elements([1,2,3,4,5,6,7,8,9,10],[2,4,6,8])==[1, 3, 5, 7, 9, 10]", "assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],[1, 3, 5, 7])==[2, 4, 6, 8, 9, 10]", "assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],[5,7])==[1, 2, 3, 4, 6, 8, 9, 10]"], "challenge_test_list": [], "func_title": "def remove_elements(list1, list2):\r", "prompt_text_chinese": "写一个函数，从一个给定的列表中删除存在于另一个列表中的所有元素。", "code_comment": "定义函数 remove_elements，接收两个参数 list1 和 list2，分别表示两个列表\n函数的作用是从列表 list1 中删除列表 list2 中包含的元素，并返回结果列表\n使用列表推导式过滤掉列表 list1 中包含在列表 list2 中的元素\n返回结果列表"}
{"prompt": "Write a function to calculate the sum of the positive integers of n+(n-2)+(n-4)... (until n-x =< 0).", "canonical_solution": "def sum_series(n):\r\n  if n < 1:\r\n    return 0\r\n  else:\r\n    return n + sum_series(n - 2)", "task_id": "Python/162", "test_setup": "", "test": ["assert sum_series(6)==12", "assert sum_series(10)==30", "assert sum_series(9)==25"], "challenge_test_list": [], "func_title": "def sum_series(n):\r", "prompt_text_chinese": "写一个函数来计算n+(n-2)+(n-4)...的正整数之和（直到n-x=<0）。", "code_comment": "定义函数 sum_series，接收一个参数 n，表示一个正整数\n函数的作用是计算斐波那契数列的一部分，并返回第 n 个数的值\n如果 n 小于 1，则返回 0\n否则，递归调用 sum_series 函数，参数为 n - 2，并将结果与 n 相加\n"}
{"prompt": "Write a function to calculate the area of a regular polygon.", "canonical_solution": "from math import tan, pi\r\ndef area_polygon(s,l):\r\n  area = s * (l ** 2) / (4 * tan(pi / s))\r\n  return area", "task_id": "Python/163", "test_setup": "", "test": ["assert area_polygon(4,20)==400.00000000000006", "assert area_polygon(10,15)==1731.1969896610804", "assert area_polygon(9,7)==302.90938549487214"], "challenge_test_list": [], "func_title": "def area_polygon(s,l):\r", "prompt_text_chinese": "写一个函数来计算一个正多边形的面积。", "code_comment": "导入 tan 和 pi 函数\n定义函数 area_polygon，接收两个参数 s 和 l，分别表示多边形的边数和边长\n函数的作用是计算正多边形的面积，并返回结果\n计算正多边形的面积，公式为 s * l^2 / (4 * tan(pi / s))\n返回正多边形的面积\n"}
{"prompt": "Write a python function to check whether the sum of divisors are same or not.", "canonical_solution": "import math \r\ndef divSum(n): \r\n    sum = 1; \r\n    i = 2; \r\n    while(i * i <= n): \r\n        if (n % i == 0): \r\n            sum = (sum + i +math.floor(n / i)); \r\n        i += 1; \r\n    return sum; \r\ndef areEquivalent(num1,num2): \r\n    return divSum(num1) == divSum(num2); ", "task_id": "Python/164", "test_setup": "", "test": ["assert areEquivalent(36,57) == False", "assert areEquivalent(2,4) == False", "assert areEquivalent(23,47) == True"], "challenge_test_list": [], "func_title": "def divSum(n): \r", "prompt_text_chinese": "写一个python函数来检查除数之和是否相同。", "code_comment": "引入math模块\n定义一个函数，用于计算n的因数之和\n初始化sum为1\n初始化i为2\n当i的平方小于等于n时，进行循环\n如果n能够整除i，执行以下语句\n计算sum的值，加上i和n/i的值，并向下取整\ni自增\n返回sum的值\n定义一个函数，用于判断两个数的因数之和是否相等\n调用divSum函数分别计算num1和num2的因数之和，进行比较\n"}
{"prompt": "Write a python function to count characters at same position in a given string (lower and uppercase characters) as in english alphabet.", "canonical_solution": "def count_char_position(str1): \r\n    count_chars = 0\r\n    for i in range(len(str1)):\r\n        if ((i == ord(str1[i]) - ord('A')) or \r\n            (i == ord(str1[i]) - ord('a'))): \r\n            count_chars += 1\r\n    return count_chars ", "task_id": "Python/165", "test_setup": "", "test": ["assert count_char_position(\"xbcefg\") == 2", "assert count_char_position(\"ABcED\") == 3", "assert count_char_position(\"AbgdeF\") == 5"], "challenge_test_list": [], "func_title": "def count_char_position(str1): \r", "prompt_text_chinese": "写一个Python函数来计算在给定的字符串中处于相同位置的字符（小写和大写字符），如英文字母表。", "code_comment": "定义一个函数，用于统计字符串中位置与其对应的字母是否相同的字符个数\n初始化计数器为0\n循环字符串的每一个字符\n如果当前字符的位置等于其ASCII码值减去A的ASCII码值，或者等于其ASCII码值减去a的ASCII码值，即位置与字母相等\n计数器加1\n返回计数器的值\n"}
{"prompt": "Write a python function to count the pairs with xor as an even number.", "canonical_solution": "def find_even_Pair(A,N): \r\n    evenPair = 0\r\n    for i in range(0,N): \r\n        for j in range(i+1,N): \r\n            if ((A[i] ^ A[j]) % 2 == 0): \r\n                evenPair+=1\r\n    return evenPair; ", "task_id": "Python/166", "test_setup": "", "test": ["assert find_even_Pair([5,4,7,2,1],5) == 4", "assert find_even_Pair([7,2,8,1,0,5,11],7) == 9", "assert find_even_Pair([1,2,3],3) == 1"], "challenge_test_list": [], "func_title": "def find_even_Pair(A,N): \r", "prompt_text_chinese": "编写一个Python函数，计算带有xor的偶数对。", "code_comment": "定义一个函数，用于找出列表中有多少个元素对的异或结果是偶数\n初始化计数器为0\n双重循环，枚举所有元素对\n如果当前元素对的异或结果是偶数\n计数器加1\n返回计数器的值\n"}
{"prompt": "Write a python function to find smallest power of 2 greater than or equal to n.", "canonical_solution": "def next_Power_Of_2(n): \r\n    count = 0; \r\n    if (n and not(n & (n - 1))): \r\n        return n   \r\n    while( n != 0): \r\n        n >>= 1\r\n        count += 1\r\n    return 1 << count; ", "task_id": "Python/167", "test_setup": "", "test": ["assert next_Power_Of_2(0) == 1", "assert next_Power_Of_2(5) == 8", "assert next_Power_Of_2(17) == 32"], "challenge_test_list": [], "func_title": "def next_Power_Of_2(n): \r", "prompt_text_chinese": "写一个Python函数，找出大于或等于n的2的最小幂。", "code_comment": "定义一个函数，用于找到大于等于n的最小的2的幂次方数\n初始化计数器为0\n如果n是2的幂次方，直接返回n\n如果n不是2的幂次方，循环右移n并计数，直到n等于0\n返回2的count次幂\n"}
{"prompt": "Write a python function to find the frequency of a number in a given array.", "canonical_solution": "def frequency(a,x): \r\n    count = 0  \r\n    for i in a: \r\n        if i == x: count += 1\r\n    return count ", "task_id": "Python/168", "test_setup": "", "test": ["assert frequency([1,2,3],4) == 0", "assert frequency([1,2,2,3,3,3,4],3) == 3", "assert frequency([0,1,2,3,1,2],1) == 2"], "challenge_test_list": [], "func_title": "def frequency(a,x): \r", "prompt_text_chinese": "写一个Python函数来寻找一个数字在给定数组中的频率。", "code_comment": "定义一个函数，用于统计列表a中元素x的出现次数\n初始化计数器为0\n循环列表a中的每一个元素\n如果当前元素等于x，计数器加1\n返回计数器的值\n"}
{"prompt": "Write a function to calculate the nth pell number.", "canonical_solution": "def get_pell(n): \r\n\tif (n <= 2): \r\n\t\treturn n \r\n\ta = 1\r\n\tb = 2\r\n\tfor i in range(3, n+1): \r\n\t\tc = 2 * b + a \r\n\t\ta = b \r\n\t\tb = c \r\n\treturn b ", "task_id": "Python/169", "test_setup": "", "test": ["assert get_pell(4) == 12", "assert get_pell(7) == 169", "assert get_pell(8) == 408"], "challenge_test_list": [], "func_title": "def get_pell(n): \r", "prompt_text_chinese": "写一个函数来计算第n个佩尔数。", "code_comment": "定义一个函数，用于计算第n个Pell数\n如果n小于等于2，Pell数为n\n初始化a和b的初始值\n循环计算第i个Pell数\n通过公式c=2b+a计算第i个Pell数\n更新a和b的值\n返回第n个Pell数\n"}
{"prompt": "Write a function to find sum of the numbers in a list between the indices of a specified range.", "canonical_solution": "def sum_range_list(list1, m, n):                                                                                                                                                                                                \r\n    sum_range = 0                                                                                                                                                                                                         \r\n    for i in range(m, n+1, 1):                                                                                                                                                                                        \r\n        sum_range += list1[i]                                                                                                                                                                                                  \r\n    return sum_range   ", "task_id": "Python/170", "test_setup": "", "test": ["assert sum_range_list( [2,1,5,6,8,3,4,9,10,11,8,12],8,10)==29", "assert sum_range_list( [2,1,5,6,8,3,4,9,10,11,8,12],5,7)==16", "assert sum_range_list( [2,1,5,6,8,3,4,9,10,11,8,12],7,10)==38"], "challenge_test_list": [], "func_title": "def sum_range_list(list1, m, n):                                                                                                                                                                                                \r", "prompt_text_chinese": "写一个函数来求一个列表中指定范围的索引之间的数字之和。", "code_comment": "定义一个函数，用于计算列表list1中下标从m到n的元素之和\n初始化计数器为0\n循环计算下标从m到n的元素之和\n返回计数器的值\n返回下标从m到n的元素之和"}
{"prompt": "Write a function to find the perimeter of a pentagon.", "canonical_solution": "import math\r\ndef perimeter_pentagon(a):\r\n  perimeter=(5*a)\r\n  return perimeter", "task_id": "Python/171", "test_setup": "", "test": ["assert perimeter_pentagon(5)==25", "assert perimeter_pentagon(10)==50", "assert perimeter_pentagon(15)==75"], "challenge_test_list": [], "func_title": "def perimeter_pentagon(a):\r", "prompt_text_chinese": "写一个函数来求一个五边形的周长。", "code_comment": "引入math模块\n定义一个函数，用于计算正五边形的周长\n周长等于五边形边长的五倍\n返回周长\n"}
{"prompt": "Write a function to find the occurence of characters 'std' in the given string 1. list item 1. list item 1. list item 2. list item 2. list item 2. list item", "canonical_solution": "def count_occurance(s):\r\n  count=0\r\n  for i in range(len(s)):\r\n    if (s[i]== 's' and s[i+1]=='t' and s[i+2]== 'd'):\r\n      count = count + 1\r\n  return count", "task_id": "Python/172", "test_setup": "", "test": ["assert count_occurance(\"letstdlenstdporstd\") == 3", "assert count_occurance(\"truststdsolensporsd\") == 1", "assert count_occurance(\"makestdsostdworthit\") == 2"], "challenge_test_list": [], "func_title": "def count_occurance(s):\r", "prompt_text_chinese": "写一个函数来查找 \"std \"字符在给定字符串中的出现次数 1.列表项 1.列表项 1.列表项 2.列表项 2.列表项", "code_comment": "定义一个函数，用于统计字符串s中\"std\"出现的次数\n初始化计数器为0\n循环遍历字符串s中的每一个字符\n判断当前字符是否是\"std\"的第一个字符，同时后面两个字符也满足要求\n计数器加1\n返回计数器的值\n"}
{"prompt": "Write a function to remove everything except alphanumeric characters from a string.", "canonical_solution": "import re\r\ndef remove_splchar(text): \r\n pattern = re.compile('[\\W_]+')\r\n return (pattern.sub('', text))", "task_id": "Python/173", "test_setup": "", "test": ["assert remove_splchar('python  @#&^%$*program123')==('pythonprogram123')", "assert remove_splchar('python %^$@!^&*()  programming24%$^^()    language')==('pythonprogramming24language')", "assert remove_splchar('python   ^%&^()(+_)(_^&67)                  program')==('python67program')"], "challenge_test_list": [], "func_title": "def remove_splchar(text): \r", "prompt_text_chinese": "编写一个函数，从一个字符串中删除除字母数字字符以外的所有字符。", "code_comment": "引入re模块\n定义一个函数，用于移除字符串中的特殊字符\n匹配正则表达式中的特殊字符\n使用空字符串替换匹配到的特殊字符，返回结果\n"}
{"prompt": "Write a function to group a sequence of key-value pairs into a dictionary of lists.", "canonical_solution": "def group_keyvalue(l):\r\n    result = {}\r\n    for k, v in l:\r\n         result.setdefault(k, []).append(v)\r\n    return result", "task_id": "Python/174", "test_setup": "", "test": ["assert group_keyvalue([('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)])=={'yellow': [1, 3], 'blue': [2, 4], 'red': [1]}", "assert group_keyvalue([('python', 1), ('python', 2), ('python', 3), ('python', 4), ('python', 5)])=={'python': [1,2,3,4,5]}", "assert group_keyvalue([('yellow',100), ('blue', 200), ('yellow', 300), ('blue', 400), ('red', 100)])=={'yellow': [100, 300], 'blue': [200, 400], 'red': [100]}"], "challenge_test_list": [], "func_title": "def group_keyvalue(l):\r", "prompt_text_chinese": "写一个函数，将一串键值对分组到一个列表字典中。", "code_comment": "定义一个函数，用于将列表l中的元素按照key值分组\n初始化一个空字典\n遍历列表l中的每一个元素，将其按照key值分组\n返回分组后的结果\n"}
{"prompt": "Write a function to verify validity of a string of parentheses.", "canonical_solution": "def is_valid_parenthese( str1):\r\n        stack, pchar = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\r\n        for parenthese in str1:\r\n            if parenthese in pchar:\r\n                stack.append(parenthese)\r\n            elif len(stack) == 0 or pchar[stack.pop()] != parenthese:\r\n                return False\r\n        return len(stack) == 0", "task_id": "Python/175", "test_setup": "", "test": ["assert is_valid_parenthese(\"(){}[]\")==True", "assert is_valid_parenthese(\"()[{)}\")==False", "assert is_valid_parenthese(\"()\")==True"], "challenge_test_list": [], "func_title": "def is_valid_parenthese( str1):\r", "prompt_text_chinese": "写一个函数来验证一串小括号的有效性。", "code_comment": "定义一个函数，用于判断字符串str1中的括号是否匹配\n定义一个栈和一个字典，字典中存储不同类型括号的映射关系\n遍历字符串str1中的每一个字符\n如果当前字符是左括号，将其入栈\n如果当前字符是右括号，判断栈是否为空，以及当前右括号是否与栈顶元素匹配\n如果不匹配，返回False\n最后判断栈是否为空，如果为空返回True，否则返回False\n"}
{"prompt": "Write a function to find the perimeter of a triangle.", "canonical_solution": "def perimeter_triangle(a,b,c):\r\n  perimeter=a+b+c\r\n  return perimeter", "task_id": "Python/176", "test_setup": "", "test": ["assert perimeter_triangle(10,20,30)==60", "assert perimeter_triangle(3,4,5)==12", "assert perimeter_triangle(25,35,45)==105"], "challenge_test_list": [], "func_title": "def perimeter_triangle(a,b,c):\r", "prompt_text_chinese": "写一个函数来求一个三角形的周长。", "code_comment": "定义一个函数，用于计算三角形的周长\n周长等于三条边长之和\n返回周长\n"}
{"prompt": "Write a python function to find two distinct numbers such that their lcm lies within the given range.", "canonical_solution": "def answer(L,R): \r\n    if (2 * L <= R): \r\n        return (L ,2*L)\r\n    else: \r\n        return (-1) ", "task_id": "Python/177", "test_setup": "", "test": ["assert answer(3,8) == (3,6)", "assert answer(2,6) == (2,4)", "assert answer(1,3) == (1,2)"], "challenge_test_list": [], "func_title": "def answer(L,R): \r", "prompt_text_chinese": "写一个Python函数来寻找两个不同的数字，使它们的lcm位于给定的范围内。", "code_comment": "定义一个函数，用于判断给定的区间[L, R]是否满足条件\n如果2L小于等于R，返回[L, 2L]\n否则区间不满足条件，返回-1\n"}
{"prompt": "Write a function to search some literals strings in a string.", "canonical_solution": "import re\r\ndef string_literals(patterns,text):\r\n  for pattern in patterns:\r\n     if re.search(pattern,  text):\r\n       return ('Matched!')\r\n     else:\r\n       return ('Not Matched!')", "task_id": "Python/178", "test_setup": "", "test": ["assert string_literals(['language'],'python language')==('Matched!')", "assert string_literals(['program'],'python language')==('Not Matched!')", "assert string_literals(['python'],'programming language')==('Not Matched!')"], "challenge_test_list": [], "func_title": "def string_literals(patterns,text):\r", "prompt_text_chinese": "写一个函数来搜索一个字符串中的一些字词串。", "code_comment": "引入re模块\n定义一个函数，用于在文本text中查找字符串常量patterns\n遍历字符串常量列表patterns中的每一个字符串\n如果当前pattern在text中匹配到了结果，返回'Matched!'\n否则返回'Not Matched!'\n"}
{"prompt": "Write a function to find if the given number is a keith number or not.", "canonical_solution": "def is_num_keith(x): \r\n\tterms = [] \r\n\ttemp = x \r\n\tn = 0 \r\n\twhile (temp > 0): \r\n\t\tterms.append(temp % 10) \r\n\t\ttemp = int(temp / 10) \r\n\t\tn+=1 \r\n\tterms.reverse() \r\n\tnext_term = 0 \r\n\ti = n \r\n\twhile (next_term < x): \r\n\t\tnext_term = 0 \r\n\t\tfor j in range(1,n+1): \r\n\t\t\tnext_term += terms[i - j] \r\n\t\tterms.append(next_term) \r\n\t\ti+=1 \r\n\treturn (next_term == x) ", "task_id": "Python/179", "test_setup": "", "test": ["assert is_num_keith(14) == True", "assert is_num_keith(12) == False", "assert is_num_keith(197) == True"], "challenge_test_list": [], "func_title": "def is_num_keith(x): \r", "prompt_text_chinese": "写一个函数来查找给定的数字是否是凯斯数字。", "code_comment": "定义一个函数，用于判断给定的整数x是否满足基序数列的性质\n初始化一个列表terms和一个变量temp，用于保存x的各个位\n将x的各个位保存到terms列表中\n将terms列表中的元素反转\n计算基序数列中的下一项，直到下一项大于等于x\n判断最后计算的下一项是否等于x，如果等于返回True，否则返回False\n"}
{"prompt": "Write a function to calculate distance between two points using latitude and longitude.", "canonical_solution": "from math import radians, sin, cos, acos\r\ndef distance_lat_long(slat,slon,elat,elon):\r\n dist = 6371.01 * acos(sin(slat)*sin(elat) + cos(slat)*cos(elat)*cos(slon - elon))\r\n return dist", "task_id": "Python/180", "test_setup": "", "test": ["assert distance_lat_long(23.5,67.5,25.5,69.5)==12179.372041317429", "assert distance_lat_long(10.5,20.5,30.5,40.5)==6069.397933300514", "assert distance_lat_long(10,20,30,40)==6783.751974994595"], "challenge_test_list": [], "func_title": "def distance_lat_long(slat,slon,elat,elon):\r", "prompt_text_chinese": "写一个函数，用经纬度计算两点之间的距离。", "code_comment": "引入math模块中的radians、sin、cos、acos函数\n定义一个函数，用于计算两个经纬度之间的距离\n计算两点之间的距离（单位：千米）\n返回计算的距离"}
{"prompt": "Write a function to find the longest common prefix in the given set of strings.", "canonical_solution": "def common_prefix_util(str1, str2): \r\n\tresult = \"\"; \r\n\tn1 = len(str1) \r\n\tn2 = len(str2) \r\n\ti = 0\r\n\tj = 0\r\n\twhile i <= n1 - 1 and j <= n2 - 1: \r\n\t\tif (str1[i] != str2[j]): \r\n\t\t\tbreak\r\n\t\tresult += str1[i] \r\n\t\ti += 1\r\n\t\tj += 1\r\n\treturn (result) \r\ndef common_prefix (arr, n): \r\n\tprefix = arr[0] \r\n\tfor i in range (1, n): \r\n\t\tprefix = common_prefix_util(prefix, arr[i]) \r\n\treturn (prefix) ", "task_id": "Python/181", "test_setup": "", "test": ["assert common_prefix([\"tablets\", \"tables\", \"taxi\", \"tamarind\"], 4) == 'ta'", "assert common_prefix([\"apples\", \"ape\", \"april\"], 3) == 'ap'", "assert common_prefix([\"teens\", \"teenager\", \"teenmar\"], 3) == 'teen'"], "challenge_test_list": [], "func_title": "def common_prefix_util(str1, str2): \r", "prompt_text_chinese": "写一个函数，在给定的字符串集中找到最长的共同前缀。", "code_comment": "定义一个函数，用于查找两个字符串的公共前缀\n初始化一个空字符串result和两个字符串的长度n1和n2\n查找两个字符串的公共前缀\n返回查找结果\n定义一个函数，用于查找一个字符串数组中所有字符串的公共前缀\n初始化prefix为数组的第一个元素\n遍历数组中的其他元素，依次查找公共前缀\n返回查找结果\n"}
{"prompt": "Write a function to find uppercase, lowercase, special character and numeric values using regex.", "canonical_solution": "import re\r\ndef find_character(string):\r\n  uppercase_characters = re.findall(r\"[A-Z]\", string) \r\n  lowercase_characters = re.findall(r\"[a-z]\", string) \r\n  numerical_characters = re.findall(r\"[0-9]\", string) \r\n  special_characters = re.findall(r\"[, .!?]\", string) \r\n  return uppercase_characters, lowercase_characters, numerical_characters, special_characters", "task_id": "Python/182", "test_setup": "", "test": ["assert find_character(\"ThisIsGeeksforGeeks\") == (['T', 'I', 'G', 'G'], ['h', 'i', 's', 's', 'e', 'e', 'k', 's', 'f', 'o', 'r', 'e', 'e', 'k', 's'], [], [])", "assert find_character(\"Hithere2\") == (['H'], ['i', 't', 'h', 'e', 'r', 'e'], ['2'], [])", "assert find_character(\"HeyFolks32\") == (['H', 'F'], ['e', 'y', 'o', 'l', 'k', 's'], ['3', '2'], [])"], "challenge_test_list": [], "func_title": "def find_character(string):\r", "prompt_text_chinese": "写一个函数，用regex查找大写、小写、特殊字符和数字值。", "code_comment": "引入re模块\n定义一个函数，用于查找字符串中的各类字符\n使用正则表达式查找字符串中的大写字母\n使用正则表达式查找字符串中的小写字母\n使用正则表达式查找字符串中的数字\n使用正则表达式查找字符串中的特殊字符（, .!?）\n返回查找结果\n"}
{"prompt": "Write a function to count all the distinct pairs having a difference of k in any array.", "canonical_solution": "def count_pairs(arr, n, k):\r\n  count=0;\r\n  for i in range(0,n):\r\n    for j in range(i+1, n):\r\n      if arr[i] - arr[j] == k or arr[j] - arr[i] == k:\r\n        count += 1\r\n  return count", "task_id": "Python/183", "test_setup": "", "test": ["assert count_pairs([1, 5, 3, 4, 2], 5, 3) == 2", "assert count_pairs([8, 12, 16, 4, 0, 20], 6, 4) == 5", "assert count_pairs([2, 4, 1, 3, 4], 5, 2) == 3"], "challenge_test_list": [], "func_title": "def count_pairs(arr, n, k):\r", "prompt_text_chinese": "写一个函数来计算任何数组中差值为k的所有不同对。", "code_comment": "定义一个函数，用于计算一个数组中差的绝对值为k的数对个数\n初始化计数器count为0\n遍历数组中所有的数对\n如果当前数对的差的绝对值为k，则计数器加一\n返回计数器的值\n"}
{"prompt": "Write a function to find all the values in a list that are greater than a specified number.", "canonical_solution": "def greater_specificnum(list,num):\r\n greater_specificnum=all(x >= num for x in list)\r\n return greater_specificnum", "task_id": "Python/184", "test_setup": "", "test": ["assert greater_specificnum([220, 330, 500],200)==True", "assert greater_specificnum([12, 17, 21],20)==False", "assert greater_specificnum([1,2,3,4],10)==False"], "challenge_test_list": [], "func_title": "def greater_specificnum(list,num):\r", "prompt_text_chinese": "写一个函数来查找一个列表中所有大于指定数字的值。", "code_comment": "定义一个函数，用于判断一个列表中的所有数是否都大于等于给定的特定数\n使用all()函数判断列表中的所有数是否都大于等于给定的特定数\n返回判断结果\n"}
{"prompt": "Write a function to find the focus of a parabola.", "canonical_solution": "def parabola_focus(a, b, c): \r\n  focus= (((-b / (2 * a)),(((4 * a * c) - (b * b) + 1) / (4 * a))))\r\n  return focus", "task_id": "Python/185", "test_setup": "", "test": ["assert parabola_focus(5,3,2)==(-0.3, 1.6)", "assert parabola_focus(9,8,4)==(-0.4444444444444444, 2.25)", "assert parabola_focus(2,4,6)==(-1.0, 4.125)"], "challenge_test_list": [], "func_title": "def parabola_focus(a, b, c): \r", "prompt_text_chinese": "写一个函数来寻找抛物线的焦点。", "code_comment": "定义一个函数，用于计算二次函数的焦点坐标\n根据公式计算二次函数的焦点坐标并保存到变量focus中\n返回焦点坐标\n"}
{"prompt": "Write a function to search some literals strings in a string by using regex.", "canonical_solution": "import re\r\ndef check_literals(text, patterns):\r\n  for pattern in patterns:\r\n    if re.search(pattern,  text):\r\n        return ('Matched!')\r\n    else:\r\n        return ('Not Matched!')", "task_id": "Python/186", "test_setup": "", "test": ["assert check_literals('The quick brown fox jumps over the lazy dog.',['fox']) == 'Matched!'", "assert check_literals('The quick brown fox jumps over the lazy dog.',['horse']) == 'Not Matched!'", "assert check_literals('The quick brown fox jumps over the lazy dog.',['lazy']) == 'Matched!'"], "challenge_test_list": [], "func_title": "def check_literals(text, patterns):\r", "prompt_text_chinese": "写一个函数，通过使用regex在一个字符串中搜索一些字面字符串。", "code_comment": "引入re模块\n定义一个函数，用于检查给定文本中是否包含指定的模式字符串\n遍历指定的模式字符串列表\n使用re.search()方法查找模式字符串在文本中的匹配情况\n如果匹配成功，则返回'Matched!'\n如果匹配失败，则继续检查下一个模式字符串\n如果所有模式字符串都未匹配成功，则返回'Not Matched!'\n"}
{"prompt": "Write a function to find the longest common subsequence for the given two sequences.", "canonical_solution": "def longest_common_subsequence(X, Y, m, n): \r\n    if m == 0 or n == 0: \r\n       return 0 \r\n    elif X[m-1] == Y[n-1]: \r\n       return 1 + longest_common_subsequence(X, Y, m-1, n-1) \r\n    else: \r\n       return max(longest_common_subsequence(X, Y, m, n-1), longest_common_subsequence(X, Y, m-1, n))", "task_id": "Python/187", "test_setup": "", "test": ["assert longest_common_subsequence(\"AGGTAB\" , \"GXTXAYB\", 6, 7) == 4", "assert longest_common_subsequence(\"ABCDGH\" , \"AEDFHR\", 6, 6) == 3", "assert longest_common_subsequence(\"AXYT\" , \"AYZX\", 4, 4) == 2"], "challenge_test_list": [], "func_title": "def longest_common_subsequence(X, Y, m, n): \r", "prompt_text_chinese": "写一个函数，为给定的两个序列找到最长的共同子序列。", "code_comment": "定义一个函数，用于计算两个字符串的最长公共子序列的长度\n如果两个字符串中有一个为空，则最长公共子序列的长度为0\n如果两个字符串的最后一个字符相同，则最长公共子序列的长度加一，并递归计算剩余部分的最长公共子序列的长度\n如果两个字符串的最后一个字符不同，则递归计算两个字符串去掉最后一个字符后的最长公共子序列的长度，并取其中较大的一个作为结果\n"}
{"prompt": "Write a python function to check whether the given number can be represented by product of two squares or not.", "canonical_solution": "def prod_Square(n):\r\n    for i in range(2,(n) + 1):\r\n        if (i*i < (n+1)):\r\n            for j in range(2,n + 1):\r\n                if ((i*i*j*j) == n):\r\n                    return True;\r\n    return False;", "task_id": "Python/188", "test_setup": "", "test": ["assert prod_Square(25) == False", "assert prod_Square(30) == False", "assert prod_Square(16) == True"], "challenge_test_list": [], "func_title": "def prod_Square(n):\r", "prompt_text_chinese": "写一个python函数来检查给定的数字是否可以用两个正方形的乘积来表示。", "code_comment": "定义一个函数，用于判断给定的数是否可以表示为两个正整数的平方的乘积\n遍历所有可能的平方数ii\n如果ii大于n+1，则跳出循环\n遍历所有可能的正整数j\n如果iijj等于n，则说明n可以表示为两个正整数的平方的乘积，返回True\n如果循环结束仍未找到符合条件的数，则返回False\n"}
{"prompt": "Write a python function to find the first missing positive number.", "canonical_solution": "def first_Missing_Positive(arr,n): \r\n    ptr = 0\r\n    for i in range(n):\r\n        if arr[i] == 1:\r\n            ptr = 1\r\n            break\r\n    if ptr == 0:\r\n        return(1)\r\n    for i in range(n):\r\n        if arr[i] <= 0 or arr[i] > n:\r\n            arr[i] = 1\r\n    for i in range(n):\r\n        arr[(arr[i] - 1) % n] += n\r\n    for i in range(n):\r\n        if arr[i] <= n:\r\n            return(i + 1)\r\n    return(n + 1)", "task_id": "Python/189", "test_setup": "", "test": ["assert first_Missing_Positive([1,2,3,-1,5],5) == 4", "assert first_Missing_Positive([0,-1,-2,1,5,8],6) == 2", "assert first_Missing_Positive([0,1,2,5,-8],5) == 3"], "challenge_test_list": [], "func_title": "def first_Missing_Positive(arr,n): \r", "prompt_text_chinese": "写一个Python函数来寻找第一个丢失的正数。", "code_comment": "定义一个函数，用于查找给定数组中第一个缺失的正整数\n遍历数组，查找是否有1\n如果数组中没有1，则返回1\n将小于等于0或大于n的数都替换为1\n将数组中的数与其对应下标的数加n\n遍历数组，查找第一个小于等于n的数的下标，返回下标+1\n如果数组中所有数都大于n，则返回n+1\n"}
{"prompt": "Write a python function to count the number of integral co-ordinates that lie inside a square.", "canonical_solution": "def count_Intgral_Points(x1,y1,x2,y2): \r\n    return ((y2 - y1 - 1) * (x2 - x1 - 1)) ", "task_id": "Python/190", "test_setup": "", "test": ["assert count_Intgral_Points(1,1,4,4) == 4", "assert count_Intgral_Points(1,2,1,2) == 1", "assert count_Intgral_Points(4,2,6,4) == 1"], "challenge_test_list": [], "func_title": "def count_Intgral_Points(x1,y1,x2,y2): \r", "prompt_text_chinese": "写一个Python函数来计算位于一个正方形内的积分坐标的数量。", "code_comment": "定义一个函数，用于计算平面直角坐标系中两点之间的整点个数\n计算两点之间的水平距离和垂直距离，并将其减1后相乘，即为整点个数\n"}
{"prompt": "Write a function to check whether the given month name contains 30 days or not.", "canonical_solution": "def check_monthnumber(monthname3):\r\n  if monthname3 ==\"April\" or monthname3== \"June\" or monthname3== \"September\" or monthname3== \"November\":\r\n    return True\r\n  else:\r\n    return False", "task_id": "Python/191", "test_setup": "", "test": ["assert check_monthnumber(\"February\")==False", "assert check_monthnumber(\"June\")==True", "assert check_monthnumber(\"April\")==True"], "challenge_test_list": [], "func_title": "def check_monthnumber(monthname3):\r", "prompt_text_chinese": "写一个函数，检查给定的月份名称是否包含30天。", "code_comment": "定义一个函数，用于检查给定的英文月份是否是30天的月份\n如果给定的月份是四月、六月、九月或十一月，则返回True\n如果给定的月份不是30天的月份，则返回False\n"}
{"prompt": "Write a python function to check whether a string has atleast one letter and one number.", "canonical_solution": "def check_String(str): \r\n    flag_l = False\r\n    flag_n = False\r\n    for i in str: \r\n        if i.isalpha(): \r\n            flag_l = True  \r\n        if i.isdigit(): \r\n            flag_n = True\r\n    return flag_l and flag_n ", "task_id": "Python/192", "test_setup": "", "test": ["assert check_String('thishasboth29') == True", "assert check_String('python') == False", "assert check_String ('string') == False"], "challenge_test_list": [], "func_title": "def check_String(str): \r", "prompt_text_chinese": "写一个python函数来检查一个字符串是否至少有一个字母和一个数字。", "code_comment": "定义一个函数，用于检查给定字符串中是否同时包含字母和数字\n初始化标志位flag_l和flag_n为False\n遍历字符串中的每个字符\n如果当前字符是字母，则将标志位flag_l设为True\n如果当前字符是数字，则将标志位flag_n设为True\n如果字符串中同时包含字母和数字，则返回True，否则返回False\n"}
{"prompt": "Write a function to remove the duplicates from the given tuple.", "canonical_solution": "def remove_tuple(test_tup):\r\n  res = tuple(set(test_tup))\r\n  return (res) ", "task_id": "Python/193", "test_setup": "", "test": ["assert remove_tuple((1, 3, 5, 2, 3, 5, 1, 1, 3)) == (1, 2, 3, 5)", "assert remove_tuple((2, 3, 4, 4, 5, 6, 6, 7, 8, 8)) == (2, 3, 4, 5, 6, 7, 8)", "assert remove_tuple((11, 12, 13, 11, 11, 12, 14, 13)) == (11, 12, 13, 14)"], "challenge_test_list": [], "func_title": "def remove_tuple(test_tup):\r", "prompt_text_chinese": "写一个函数，从给定的元组中删除重复的部分。", "code_comment": "定义一个函数，用于去除元组中的重复元素\n使用set()函数将元组转换为集合，去除重复元素。然后再将集合转换为元组。\n因为集合中的元素是无序的，所以此处不能直接返回集合，而需要再次将其转换为元组。\n返回去重后的元组\n"}
{"prompt": "Write a python function to convert octal number to decimal number.", "canonical_solution": "def octal_To_Decimal(n):  \r\n    num = n; \r\n    dec_value = 0; \r\n    base = 1; \r\n    temp = num; \r\n    while (temp): \r\n        last_digit = temp % 10; \r\n        temp = int(temp / 10); \r\n        dec_value += last_digit*base; \r\n        base = base * 8; \r\n    return dec_value; ", "task_id": "Python/194", "test_setup": "", "test": ["assert octal_To_Decimal(25) == 21", "assert octal_To_Decimal(30) == 24", "assert octal_To_Decimal(40) == 32"], "challenge_test_list": [], "func_title": "def octal_To_Decimal(n):  \r", "prompt_text_chinese": "编写一个将八进制数转换为十进制数的Python函数。", "code_comment": "定义一个函数，用于将八进制数转换为十进制数\n将八进制数保存到变量num中\n将十进制数初始化为0\n将进制基数初始化为1\n将num保存到临时变量temp中\n循环处理temp中的每一位数字\n取出temp的最后一位数字\n将temp除以10向下取整，相当于去掉temp的最后一位数字\n将last_digit乘以进制基数base，并累加到十进制数dec_value中\n将进制基数base乘以8，相当于进位\n返回转换后的十进制数\n"}
{"prompt": "Write a python function to find the first position of an element in a sorted array.", "canonical_solution": "def first(arr,x,n): \r\n    low = 0\r\n    high = n - 1\r\n    res = -1  \r\n    while (low <= high):\r\n        mid = (low + high) // 2 \r\n        if arr[mid] > x:\r\n            high = mid - 1\r\n        elif arr[mid] < x:\r\n            low = mid + 1\r\n        else:\r\n            res = mid\r\n            high = mid - 1\r\n    return res", "task_id": "Python/195", "test_setup": "", "test": ["assert first([1,2,3,4,5,6,6],6,6) == 5", "assert first([1,2,2,2,3,2,2,4,2],2,9) == 1", "assert first([1,2,3],1,3) == 0"], "challenge_test_list": [], "func_title": "def first(arr,x,n): \r", "prompt_text_chinese": "写一个Python函数来寻找一个排序数组中元素的第一个位置。", "code_comment": "定义一个函数，用于在有序数组中查找第一个等于给定值的元素的下标\n将搜索范围的左端点low初始化为0，右端点high初始化为n-1\n将结果res初始化为-1\n在搜索范围内进行二分查找\n计算中间位置mid\n如果中间位置的元素大于给定值x，则将搜索范围缩小到左半部分\n如果中间位置的元素小于给定值x，则将搜索范围缩小到右半部分\n如果中间位置的元素等于给定值x，则将结果res设为mid，然后将搜索范围缩小到左半部分，继续查找第一个等于给定值的元素的下标\n返回结果res\n"}
{"prompt": "Write a function to remove all the tuples with length k.", "canonical_solution": "def remove_tuples(test_list, K):\r\n  res = [ele for ele in test_list if len(ele) != K]\r\n  return (res) ", "task_id": "Python/196", "test_setup": "", "test": ["assert remove_tuples([(4, 5), (4, ), (8, 6, 7), (1, ), (3, 4, 6, 7)] , 1) == [(4, 5), (8, 6, 7), (3, 4, 6, 7)]", "assert remove_tuples([(4, 5), (4,5), (6, 7), (1, 2, 3), (3, 4, 6, 7)] ,2) == [(1, 2, 3), (3, 4, 6, 7)]", "assert remove_tuples([(1, 4, 4), (4, 3), (8, 6, 7), (1, ), (3, 6, 7)] , 3) == [(4, 3), (1,)]"], "challenge_test_list": [], "func_title": "def remove_tuples(test_list, K):\r", "prompt_text_chinese": "写一个函数，删除所有长度为k的图元。", "code_comment": "定义一个函数，用于删除列表中长度为K的元组\n使用列表推导式，遍历test_list中的每个元素ele，如果ele的长度不等于K，则保留ele，否则删除ele。\n返回删除后的结果列表res\n"}
{"prompt": "Write a function to perform the exponentiation of the given two tuples.", "canonical_solution": "def find_exponentio(test_tup1, test_tup2):\r\n  res = tuple(ele1 ** ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res)\r\n", "task_id": "Python/197", "test_setup": "", "test": ["assert find_exponentio((10, 4, 5, 6), (5, 6, 7, 5)) == (100000, 4096, 78125, 7776)", "assert find_exponentio((11, 5, 6, 7), (6, 7, 8, 6)) == (1771561, 78125, 1679616, 117649)", "assert find_exponentio((12, 6, 7, 8), (7, 8, 9, 7)) == (35831808, 1679616, 40353607, 2097152)"], "challenge_test_list": [], "func_title": "def find_exponentio(test_tup1, test_tup2):\r", "prompt_text_chinese": "写一个函数，对给定的两个图元进行指数化处理。", "code_comment": "定义一个函数，用于计算两个元组对应元素的指数幂\n使用zip()函数将两个元组中对应位置的元素打包成元组，并遍历打包后的元组\n将每个元组中对应位置的元素进行指数幂运算，然后生成一个结果元组res\n返回结果元组res\n"}
{"prompt": "Write a function to find the largest triangle that can be inscribed in an ellipse.", "canonical_solution": "import math\r\ndef largest_triangle(a,b): \r\n    if (a < 0 or b < 0): \r\n        return -1 \r\n    area = (3 * math.sqrt(3) * pow(a, 2)) / (4 * b);  \r\n    return area ", "task_id": "Python/198", "test_setup": "", "test": ["assert largest_triangle(4,2)==10.392304845413264", "assert largest_triangle(5,7)==4.639421805988064", "assert largest_triangle(9,1)==105.2220865598093"], "challenge_test_list": [], "func_title": "def largest_triangle(a,b): \r", "prompt_text_chinese": "写一个函数，找出能被刻在椭圆里的最大三角形。", "code_comment": "导入math模块\n定义一个函数，用于计算边长为a，高为b的等边三角形的最大面积\n如果a或b小于0，则返回-1\n根据等边三角形的公式计算其最大面积\n返回计算得到的最大面积\n"}
{"prompt": "Write a python function to find highest power of 2 less than or equal to given number.", "canonical_solution": "def highest_Power_of_2(n): \r\n    res = 0; \r\n    for i in range(n, 0, -1):  \r\n        if ((i & (i - 1)) == 0): \r\n            res = i; \r\n            break;      \r\n    return res; ", "task_id": "Python/199", "test_setup": "", "test": ["assert highest_Power_of_2(10) == 8", "assert highest_Power_of_2(19) == 16", "assert highest_Power_of_2(32) == 32"], "challenge_test_list": [], "func_title": "def highest_Power_of_2(n): \r", "prompt_text_chinese": "写一个Python函数，找出小于或等于给定数的2的最高幂。", "code_comment": "定义一个函数，用于查找小于等于n的最大2的幂次方\n将结果res初始化为0\n从n开始循环递减直到1\n如果i和i-1按位与运算的结果为0，则说明i是2的幂次方\n将结果res设为i，然后跳出循环\n返回结果res\n"}
{"prompt": "Write a function to find all index positions of the maximum values in a given list.", "canonical_solution": "def position_max(list1):\r\n    max_val = max(list1)\r\n    max_result = [i for i, j in enumerate(list1) if j == max_val]\r\n    return max_result", "task_id": "Python/200", "test_setup": "", "test": ["assert position_max([12,33,23,10,67,89,45,667,23,12,11,10,54])==[7]", "assert position_max([1,2,2,2,4,4,4,5,5,5,5])==[7,8,9,10]", "assert position_max([2,1,5,6,8,3,4,9,10,11,8,12])==[11]"], "challenge_test_list": [], "func_title": "def position_max(list1):\r", "prompt_text_chinese": "写一个函数来查找给定列表中最大值的所有索引位置。", "code_comment": "定义一个函数，用于查找列表中最大值的位置\n使用max()函数找出列表中的最大值\n使用列表推导式，遍历列表中的每个元素，如果元素等于最大值，则将其下标保存到列表max_result中\n返回max_result列表，其中包含了所有最大值的位置\n"}
{"prompt": "Write a python function to check whether the elements in a list are same or not.", "canonical_solution": "def chkList(lst): \r\n    return len(set(lst)) == 1", "task_id": "Python/201", "test_setup": "", "test": ["assert chkList(['one','one','one']) == True", "assert chkList(['one','Two','Three']) == False", "assert chkList(['bigdata','python','Django']) == False"], "challenge_test_list": [], "func_title": "def chkList(lst): \r", "prompt_text_chinese": "写一个python函数来检查一个列表中的元素是否相同。", "code_comment": "定义一个函数，用于判断列表中的元素是否全部相同\n使用set()函数将列表转换为集合，因为集合中不能有重复元素，所以如果集合的长度为1，则说明列表中的所有元素都相同，返回True，否则返回False\n"}
{"prompt": "Write a function to remove even characters in a string.", "canonical_solution": "def remove_even(str1):\r\n str2 = ''\r\n for i in range(1, len(str1) + 1):\r\n    if(i % 2 != 0):\r\n        str2 = str2 + str1[i - 1]\r\n return str2", "task_id": "Python/202", "test_setup": "", "test": ["assert remove_even(\"python\")==(\"pto\")", "assert remove_even(\"program\")==(\"porm\")", "assert remove_even(\"language\")==(\"lnug\")"], "challenge_test_list": [], "func_title": "def remove_even(str1):\r", "prompt_text_chinese": "写一个函数来删除一个字符串中的偶数字符。", "code_comment": "定义一个函数，用于删除字符串中下标为偶数的字符\n初始化一个空字符串str2\n遍历字符串中每个字符的下标，从1开始，步长为1，直到字符串的长度\n如果当前字符的下标是奇数，则将其添加到str2中\n返回删除偶数下标字符后的字符串\n"}
{"prompt": "Write a python function to find the hamming distance between given two integers.", "canonical_solution": "def hamming_Distance(n1,n2) : \r\n    x = n1 ^ n2  \r\n    setBits = 0\r\n    while (x > 0) : \r\n        setBits += x & 1\r\n        x >>= 1\r\n    return setBits  ", "task_id": "Python/203", "test_setup": "", "test": ["assert hamming_Distance(4,8) == 2", "assert hamming_Distance(2,4) == 2", "assert hamming_Distance(1,2) == 2"], "challenge_test_list": [], "func_title": "def hamming_Distance(n1,n2) : \r", "prompt_text_chinese": "写一个Python函数，找出给定的两个整数之间的hamming距离。", "code_comment": "定义一个函数，用于计算两个整数二进制下不同位置的个数（即汉明距离）\n将两个整数进行按位异或运算，并将结果保存到变量x中\n将变量setBits初始化为0，用于记录二进制下不同位置的个数\n循环检查x的每一位二进制数字是否为1\n如果x的最后一位二进制数字为1，则将setBits加1\n将x右移一位，相当于除以2，继续检查下一位二进制数字\n返回二进制下不同位置的个数\n"}
{"prompt": "Write a python function to count the occurrence of a given character in a string.", "canonical_solution": "def count(s,c) : \r\n    res = 0 \r\n    for i in range(len(s)) : \r\n        if (s[i] == c): \r\n            res = res + 1\r\n    return res ", "task_id": "Python/204", "test_setup": "", "test": ["assert count(\"abcc\",\"c\") == 2", "assert count(\"ababca\",\"a\") == 3", "assert count(\"mnmm0pm\",\"m\") == 4"], "challenge_test_list": [], "func_title": "def count(s,c) : \r", "prompt_text_chinese": "写一个Python函数来计算一个字符串中给定字符的出现次数。", "code_comment": "定义一个函数，用于计算字符串s中字符c出现的次数\n将结果res初始化为0\n遍历字符串中的每个字符，如果当前字符等于字符c，则将结果res加1\n返回字符c在字符串s中出现的次数\n"}
{"prompt": "Write a function to find the inversions of tuple elements in the given tuple list.", "canonical_solution": "def inversion_elements(test_tup):\r\n  res = tuple(list(map(lambda x: ~x, list(test_tup))))\r\n  return (res) ", "task_id": "Python/205", "test_setup": "", "test": ["assert inversion_elements((7, 8, 9, 1, 10, 7)) == (-8, -9, -10, -2, -11, -8)", "assert inversion_elements((2, 4, 5, 6, 1, 7)) == (-3, -5, -6, -7, -2, -8)", "assert inversion_elements((8, 9, 11, 14, 12, 13)) == (-9, -10, -12, -15, -13, -14)"], "challenge_test_list": [], "func_title": "def inversion_elements(test_tup):\r", "prompt_text_chinese": "写一个函数来查找给定元组列表中元组元素的反转。", "code_comment": "定义一个函数，用于将元组中的每个元素取反（按位取反）\n使用map()函数将元组中的每个元素进行按位取反操作，并将结果保存到列表中\n然后将列表转换为元组类型，并将其赋值给res变量\n返回结果元组res\n"}
{"prompt": "Write a function to perform the adjacent element concatenation in the given tuples.", "canonical_solution": "def concatenate_elements(test_tup):\r\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\r\n  return (res) ", "task_id": "Python/206", "test_setup": "", "test": ["assert concatenate_elements((\"DSP \", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"UTS\")) == ('DSP IS ', 'IS BEST ', 'BEST FOR ', 'FOR ALL ', 'ALL UTS')", "assert concatenate_elements((\"RES \", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"QESR\")) == ('RES IS ', 'IS BEST ', 'BEST FOR ', 'FOR ALL ', 'ALL QESR')", "assert concatenate_elements((\"MSAM\", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"SKD\")) == ('MSAMIS ', 'IS BEST ', 'BEST FOR ', 'FOR ALL ', 'ALL SKD')"], "challenge_test_list": [], "func_title": "def concatenate_elements(test_tup):\r", "prompt_text_chinese": "写一个函数，在给定的元组中进行相邻元素的连接。", "code_comment": "定义一个函数，用于将元组中相邻两个元素进行连接\n使用zip()函数将元组中相邻的两个元素打包成元组，并遍历打包后的元组，将相邻元素连接后生成一个新元组\n返回连接后的新元组\n"}
{"prompt": "Write a function to count the longest repeating subsequences such that the two subsequences don’t have same string characters at same positions.", "canonical_solution": "def find_longest_repeating_subseq(str): \r\n\tn = len(str) \r\n\tdp = [[0 for k in range(n+1)] for l in range(n+1)] \r\n\tfor i in range(1, n+1): \r\n\t\tfor j in range(1, n+1): \r\n\t\t\tif (str[i-1] == str[j-1] and i != j): \r\n\t\t\t\tdp[i][j] = 1 + dp[i-1][j-1] \r\n\t\t\telse: \r\n\t\t\t\tdp[i][j] = max(dp[i][j-1], dp[i-1][j]) \r\n\treturn dp[n][n]", "task_id": "Python/207", "test_setup": "", "test": ["assert find_longest_repeating_subseq(\"AABEBCDD\") == 3", "assert find_longest_repeating_subseq(\"aabb\") == 2", "assert find_longest_repeating_subseq(\"aab\") == 1"], "challenge_test_list": [], "func_title": "def find_longest_repeating_subseq(str): \r", "prompt_text_chinese": "写一个函数来计算最长的重复子序列，使两个子序列在相同的位置没有相同的字符串字符。", "code_comment": "定义一个函数，用于查找字符串中最长的重复子序列的长度\n获取字符串的长度\n初始化一个二维列表dp，其中dp[i][j]表示以第一个字符串的前i个字符和第二个字符串的前j个字符为结尾的最长重复子序列的长度\n遍历第一个字符串中的每个字符\n遍历第二个字符串中的每个字符\n如果第一个字符串中的第i个字符和第二个字符串中的第j个字符相等，并且i不等于j，则说明找到了一个新的重复字符，将dp[i][j]设为dp[i-1][j-1]+1\n如果第一个字符串中的第i个字符和第二个字符串中的第j个字符不相等，则说明没有找到新的重复字符，将dp[i][j]设为dp[i][j-1]和dp[i-1][j]中的较大值\n返回dp[n][n]，即以第一个字符串的前n个字符和第二个字符串的前n个字符为结尾的最长重复子序列的长度\n"}
{"prompt": "Write a function to check the given decimal with a precision of 2 by using regex.", "canonical_solution": "import re\r\ndef is_decimal(num):\r\n  num_fetch = re.compile(r\"\"\"^[0-9]+(\\.[0-9]{1,2})?$\"\"\")\r\n  result = num_fetch.search(num)\r\n  return bool(result)", "task_id": "Python/208", "test_setup": "", "test": ["assert is_decimal('123.11') == True", "assert is_decimal('0.21') == True", "assert is_decimal('123.1214') == False"], "challenge_test_list": [], "func_title": "def is_decimal(num):\r", "prompt_text_chinese": "写一个函数，通过使用regex检查给定的精度为2的小数。", "code_comment": "导入re模块\n定义一个函数，用于判断一个字符串是否为小数格式\n定义一个正则表达式，用于匹配小数\n使用search()函数进行匹配，返回匹配结果\n如果匹配成功，则返回True，否则返回False\n"}
{"prompt": "Write a function to delete the smallest element from the given heap and then insert a new item.", "canonical_solution": "import heapq as hq\r\ndef heap_replace(heap,a):\r\n  hq.heapify(heap)\r\n  hq.heapreplace(heap, a)\r\n  return heap", "task_id": "Python/209", "test_setup": "", "test": ["assert heap_replace( [25, 44, 68, 21, 39, 23, 89],21)==[21, 25, 23, 44, 39, 68, 89]", "assert heap_replace([25, 44, 68, 21, 39, 23, 89],110)== [23, 25, 68, 44, 39, 110, 89]", "assert heap_replace([25, 44, 68, 21, 39, 23, 89],500)==[23, 25, 68, 44, 39, 500, 89]"], "challenge_test_list": [], "func_title": "def heap_replace(heap,a):\r", "prompt_text_chinese": "写一个函数，从给定的堆中删除最小的元素，然后插入一个新项。", "code_comment": "导入heapq模块\n定义一个函数，用于将堆中最小的元素替换为指定元素\n使用heapify()函数将列表转换为堆\n使用heapreplace()函数将堆中最小的元素替换为指定元素a，并重新维护堆的结构\n返回替换后的堆\n"}
{"prompt": "Write a function to check that the given string contains only a certain set of characters(in this case a-z, a-z and 0-9) by using regex.", "canonical_solution": "import re\r\ndef is_allowed_specific_char(string):\r\n    get_char = re.compile(r'[^a-zA-Z0-9.]')\r\n    string = get_char.search(string)\r\n    return not bool(string)", "task_id": "Python/210", "test_setup": "", "test": ["assert is_allowed_specific_char(\"ABCDEFabcdef123450\") == True", "assert is_allowed_specific_char(\"*&%@#!}{\") == False", "assert is_allowed_specific_char(\"HELLOhowareyou98765\") == True"], "challenge_test_list": [], "func_title": "def is_allowed_specific_char(string):\r", "prompt_text_chinese": "写一个函数，通过使用regex检查给定的字符串是否只包含某一组字符（在这个例子中是a-z，a-z和0-9）。", "code_comment": "导入re模块\n定义一个函数，用于检查字符串中是否只包含指定的字符和数字\n定义一个正则表达式，用于匹配所有不是字母、数字或小数点的字符\n使用search()函数匹配字符串中的第一个不符合要求的字符，并将其保存到变量string中\n如果string存在，则说明字符串中包含了不符合要求的字符，返回False；否则返回True\n"}
{"prompt": "Write a python function to count numbers whose oth and nth bits are set.", "canonical_solution": "def count_Num(n): \r\n    if (n == 1): \r\n        return 1\r\n    count = pow(2,n - 2) \r\n    return count ", "task_id": "Python/211", "test_setup": "", "test": ["assert count_Num(2) == 1", "assert count_Num(3) == 2", "assert count_Num(1) == 1"], "challenge_test_list": [], "func_title": "def count_Num(n): \r", "prompt_text_chinese": "写一个Python函数来计算第O位和第N位被设置的数字。", "code_comment": "定义一个函数，用于计算在n位二进制数中，第一位和最后一位是1的数的个数\n如果n等于1，则只有一种情况，即数本身为1\n否则，第一位和最后一位都为1的二进制数的个数等于n-2位的所有二进制数的个数，即2^(n-2)\n返回计数结果\n"}
{"prompt": "Write a python function to find the sum of fourth power of n natural numbers.", "canonical_solution": "import math  \r\ndef fourth_Power_Sum(n): \r\n    sum = 0\r\n    for i in range(1,n+1) : \r\n        sum = sum + (i*i*i*i) \r\n    return sum", "task_id": "Python/212", "test_setup": "", "test": ["assert fourth_Power_Sum(2) == 17", "assert fourth_Power_Sum(4) == 354", "assert fourth_Power_Sum(6) == 2275"], "challenge_test_list": [], "func_title": "def fourth_Power_Sum(n): \r", "prompt_text_chinese": "编写一个Python函数，求n个自然数的四次方之和。", "code_comment": "导入math模块\n定义一个函数，用于计算1到n的四次方和\n将计数器sum初始化为0\n遍历1到n的所有整数\n将当前整数的四次方加入计数器sum中\n返回1到n的四次方和\n"}
{"prompt": "Write a function to perform the concatenation of two string tuples.", "canonical_solution": "def concatenate_strings(test_tup1, test_tup2):\r\n  res = tuple(ele1 + ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res) ", "task_id": "Python/213", "test_setup": "", "test": ["assert concatenate_strings((\"Manjeet\", \"Nikhil\", \"Akshat\"), (\" Singh\", \" Meherwal\", \" Garg\")) == ('Manjeet Singh', 'Nikhil Meherwal', 'Akshat Garg')", "assert concatenate_strings((\"Shaik\", \"Ayesha\", \"Sanya\"), (\" Dawood\", \" Begum\", \" Singh\")) == ('Shaik Dawood', 'Ayesha Begum', 'Sanya Singh')", "assert concatenate_strings((\"Harpreet\", \"Priyanka\", \"Muskan\"), (\"Kour\", \" Agarwal\", \"Sethi\")) == ('HarpreetKour', 'Priyanka Agarwal', 'MuskanSethi')"], "challenge_test_list": [], "func_title": "def concatenate_strings(test_tup1, test_tup2):\r", "prompt_text_chinese": "写一个函数，对两个字符串图元进行连接。", "code_comment": "定义一个函数，用于将两个元组中的字符串按位连接生成一个新的元组\n使用zip()函数将两个元组中字符串按位打包成元组，并遍历打包后的元组，将相应位置的字符串连接后生成一个新元组\n返回新元组\n"}
{"prompt": "Write a function to convert radians to degrees.", "canonical_solution": "import math\r\ndef degree_radian(radian):\r\n degree = radian*(180/math.pi)\r\n return degree", "task_id": "Python/214", "test_setup": "", "test": ["assert degree_radian(90)==5156.620156177409", "assert degree_radian(60)==3437.746770784939", "assert degree_radian(120)==6875.493541569878"], "challenge_test_list": [], "func_title": "def degree_radian(radian):\r", "prompt_text_chinese": "写一个将弧度转换为度的函数。", "code_comment": "导入math模块\n定义一个函数，用于将弧度值转换为角度值\n使用math模块中的pi变量获取π的值，将弧度值乘以180再除以π，得到对应的角度值\n返回角度值\n"}
{"prompt": "Write a function to decode a run-length encoded given list.", "canonical_solution": "def decode_list(alist):\r\n    def aux(g):\r\n        if isinstance(g, list):\r\n            return [(g[1], range(g[0]))]\r\n        else:\r\n            return [(g, [0])]\r\n    return [x for g in alist for x, R in aux(g) for i in R]", "task_id": "Python/215", "test_setup": "", "test": ["assert decode_list([[2, 1], 2, 3, [2, 4], 5,1])==[1,1,2,3,4,4,5,1]", "assert decode_list(['a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'a', [2, 'l'], 'y'])==['a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'a', 'l', 'l', 'y']", "assert decode_list(['p', 'y', 't', 'h', 'o', 'n'])==['p', 'y', 't', 'h', 'o', 'n']"], "challenge_test_list": [], "func_title": "def decode_list(alist):\r", "prompt_text_chinese": "写一个函数来解码一个运行长度编码的给定列表。", "code_comment": "定义一个函数，用于将包含嵌套列表的列表转换为一维列表\n定义一个辅助函数aux，用于将嵌套列表转换为包含元组的列表\n如果g是一个列表，则将其第二个元素和range(g[0])中的所有元素组成元组，\n并将元组作为列表的元素返回\n如果g不是一个列表，则将其作为元组的第一个元素，[0]作为元组的第二个元素，\n并将元组作为列表的元素返回\n使用列表推导式，遍历alist中的每个元素g，对于aux(g)返回的每个元组，\n使用元组第一个元素x和第二个元素R中的每个元素i组成一个新的元素，将新元素添加到结果列表中\n"}
{"prompt": "Write a function to check if a nested list is a subset of another nested list.", "canonical_solution": "def check_subset_list(list1, list2): \r\n    l1, l2 = list1[0], list2[0] \r\n    exist = True\r\n    for i in list2: \r\n        if i not in list1: \r\n            exist = False\r\n    return exist ", "task_id": "Python/216", "test_setup": "", "test": ["assert check_subset_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],[[12, 18, 23, 25, 45], [7, 11, 19, 24, 28], [1, 5, 8, 18, 15, 16]])==False", "assert check_subset_list([[2, 3, 1], [4, 5], [6, 8]],[[4, 5], [6, 8]])==True", "assert check_subset_list([['a', 'b'], ['e'], ['c', 'd']],[['g']])==False"], "challenge_test_list": [], "func_title": "def check_subset_list(list1, list2): \r", "prompt_text_chinese": "写一个函数来检查一个嵌套列表是否是另一个嵌套列表的子集。", "code_comment": "定义一个函数，用于检查list2是否为list1的子集\n获取list1和list2的第一个元素\n将exist初始值设为True\n遍历list2中的每个元素\n如果当前元素不在list1中，则将exist设为False\n返回exist\n"}
{"prompt": "Write a python function to find the first repeated character in a given string.", "canonical_solution": "def first_Repeated_Char(str): \r\n    h = {}\r\n    for ch in str:\r\n        if ch in h: \r\n            return ch;\r\n        else: \r\n            h[ch] = 0\r\n    return '\\0'", "task_id": "Python/217", "test_setup": "", "test": ["assert first_Repeated_Char(\"Google\") == \"o\"", "assert first_Repeated_Char(\"data\") == \"a\"", "assert first_Repeated_Char(\"python\") == '\\0'"], "challenge_test_list": [], "func_title": "def first_Repeated_Char(str): \r", "prompt_text_chinese": "编写一个Python函数来查找给定字符串中的第一个重复字符。", "code_comment": "定义一个函数，用于查找字符串中第一个重复出现的字符\n创建一个空字典h，用于保存已经遍历过的字符\n遍历字符串中的每个字符\n如果当前字符已经在字典h中出现过，则说明这是第一个重复出现的字符，返回当前字符\n否则，将当前字符添加到字典h中\n如果字符串中没有重复出现的字符，则返回空字符'�'\n"}
{"prompt": "Write a python function to find the minimum operations required to make two numbers equal.", "canonical_solution": "import math   \r\ndef min_Operations(A,B):  \r\n    if (A > B): \r\n        swap(A,B)  \r\n    B = B // math.gcd(A,B);  \r\n    return B - 1", "task_id": "Python/218", "test_setup": "", "test": ["assert min_Operations(2,4) == 1", "assert min_Operations(4,10) == 4", "assert min_Operations(1,4) == 3"], "challenge_test_list": [], "func_title": "def min_Operations(A,B):  \r", "prompt_text_chinese": "写一个python函数，找出使两个数字相等所需的最小操作。", "code_comment": "导入math模块\n定义一个函数，用于计算将两个数变成整数倍所需的最小操作数\n如果A大于B，则交换A和B的值\n将B除以A和B的最大公约数，得到将A和B变成整数倍所需的最小操作数\n返回最小操作数\n"}
{"prompt": "Write a function to extract maximum and minimum k elements in the given tuple.", "canonical_solution": "\r\ndef extract_min_max(test_tup, K):\r\n  res = []\r\n  test_tup = list(test_tup)\r\n  temp = sorted(test_tup)\r\n  for idx, val in enumerate(temp):\r\n    if idx < K or idx >= len(temp) - K:\r\n      res.append(val)\r\n  res = tuple(res)\r\n  return (res) ", "task_id": "Python/219", "test_setup": "", "test": ["assert extract_min_max((5, 20, 3, 7, 6, 8), 2) == (3, 5, 8, 20)", "assert extract_min_max((4, 5, 6, 1, 2, 7), 3) == (1, 2, 4, 5, 6, 7)", "assert extract_min_max((2, 3, 4, 8, 9, 11, 7), 4) == (2, 3, 4, 7, 8, 9, 11)"], "challenge_test_list": [], "func_title": "def extract_min_max(test_tup, K):\r", "prompt_text_chinese": "写一个函数来提取给定元组中最大和最小的K元素。", "code_comment": "定义一个函数，用于从元组中提取K个最小值和K个最大值\n将元组转换为列表\n使用sorted()函数对列表进行排序，并保存到temp变量中\n遍历排序后的列表，将前K个元素和后K个元素添加到结果列表中\n将结果列表转换为元组\n返回结果元组\n"}
{"prompt": "Write a function to replace maximum n occurrences of spaces, commas, or dots with a colon.", "canonical_solution": "import re\r\ndef replace_max_specialchar(text,n):\r\n return (re.sub(\"[ ,.]\", \":\", text, n))", "task_id": "Python/220", "test_setup": "", "test": ["assert replace_max_specialchar('Python language, Programming language.',2)==('Python:language: Programming language.')", "assert replace_max_specialchar('a b c,d e f',3)==('a:b:c:d e f')", "assert replace_max_specialchar('ram reshma,ram rahim',1)==('ram:reshma,ram rahim')"], "challenge_test_list": [], "func_title": "def replace_max_specialchar(text,n):\r", "prompt_text_chinese": "写一个函数，用冒号替换最大N次出现的空格、逗号或圆点。", "code_comment": "导入re模块\n定义一个函数，用于将字符串中最多n个空格、逗号、句号替换为冒号\n使用re.sub()函数将字符串text中最多n个空格、逗号、句号替换为冒号，并返回替换后的结果\n"}
{"prompt": "Write a python function to find the first even number in a given list of numbers.", "canonical_solution": "def first_even(nums):\r\n    first_even = next((el for el in nums if el%2==0),-1)\r\n    return first_even", "task_id": "Python/221", "test_setup": "", "test": ["assert first_even ([1, 3, 5, 7, 4, 1, 6, 8]) == 4", "assert first_even([2, 3, 4]) == 2", "assert first_even([5, 6, 7]) == 6"], "challenge_test_list": [], "func_title": "def first_even(nums):\r", "prompt_text_chinese": "写一个python函数，在给定的数字列表中找出第一个偶数。", "code_comment": "定义一个函数，用于查找列表中第一个偶数\n使用生成器表达式和next()函数，查找列表中第一个满足条件的元素，如果没有找到，则返回-1\n返回第一个偶数\n"}
{"prompt": "Write a function to check if all the elements in tuple have same data type or not.", "canonical_solution": "def check_type(test_tuple):\r\n  res = True\r\n  for ele in test_tuple:\r\n    if not isinstance(ele, type(test_tuple[0])):\r\n      res = False\r\n      break\r\n  return (res) ", "task_id": "Python/222", "test_setup": "", "test": ["assert check_type((5, 6, 7, 3, 5, 6) ) == True", "assert check_type((1, 2, \"4\") ) == False", "assert check_type((3, 2, 1, 4, 5) ) == True"], "challenge_test_list": [], "func_title": "def check_type(test_tuple):\r", "prompt_text_chinese": "写一个函数来检查元组中的所有元素是否具有相同的数据类型。", "code_comment": "定义一个函数，用于检查元组中的所有元素是否都是同一种类型\n将res初始值设为True\n遍历元组中的每个元素\n如果当前元素的类型不等于第一个元素的类型，则将res设为False，退出循环\n返回结果\n"}
{"prompt": "Write a function to check for majority element in the given sorted array.", "canonical_solution": "def is_majority(arr, n, x):\r\n\ti = binary_search(arr, 0, n-1, x)\r\n\tif i == -1:\r\n\t\treturn False\r\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\r\n\t\treturn True\r\n\telse:\r\n\t\treturn False\r\ndef binary_search(arr, low, high, x):\r\n\tif high >= low:\r\n\t\tmid = (low + high)//2 \r\n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\r\n\t\t\treturn mid\r\n\t\telif x > arr[mid]:\r\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\r\n\t\telse:\r\n\t\t\treturn binary_search(arr, low, (mid -1), x)\r\n\treturn -1", "task_id": "Python/223", "test_setup": "", "test": ["assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True", "assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False", "assert is_majority([1, 1, 1, 2, 2], 5, 1) == True"], "challenge_test_list": [], "func_title": "def is_majority(arr, n, x):\r", "prompt_text_chinese": "写一个函数来检查给定的排序数组中的多数元素。", "code_comment": "定义一个函数，用于检查元素x在数组arr中是否为占据数组一半以上的主元素\n调用函数binary_search()查找元素x在数组arr中的位置\n如果x不在数组arr中，则返回False\n如果x在数组arr中，且其后n//2个元素都等于x，则返回True\n定义一个函数，用于在有序数组arr中查找元素x的位置\n如果high大于等于low，则进行查找\n计算数组的中间位置mid\n如果mid为0，或者x大于arr[mid-1]，且arr[mid]等于x，则表示找到了x，返回mid\n如果x大于arr[mid]，则在数组的右半部分查找x\n否则，在数组的左半部分查找x\n如果high小于low，则表示x不在数组中，返回-1\n"}
{"prompt": "Write a python function to count set bits of a given number.", "canonical_solution": "def count_Set_Bits(n): \r\n    count = 0\r\n    while (n): \r\n        count += n & 1\r\n        n >>= 1\r\n    return count ", "task_id": "Python/224", "test_setup": "", "test": ["assert count_Set_Bits(2) == 1", "assert count_Set_Bits(4) == 1", "assert count_Set_Bits(6) == 2"], "challenge_test_list": [], "func_title": "def count_Set_Bits(n): \r", "prompt_text_chinese": "写一个Python函数来计算一个给定数字的设定位。", "code_comment": "定义一个函数，用于计算一个整数的二进制表示中1的个数\n将count初始值设为0\n循环遍历n的二进制表示中的每一位\n如果当前位为1，则将count加1\n将n右移一位，继续判断下一位\n返回1的个数\n"}
{"prompt": "Write a python function to find the minimum element in a sorted and rotated array.", "canonical_solution": "def find_Min(arr,low,high): \r\n    while (low < high): \r\n        mid = low + (high - low) // 2;   \r\n        if (arr[mid] == arr[high]): \r\n            high -= 1; \r\n        elif (arr[mid] > arr[high]): \r\n            low = mid + 1; \r\n        else: \r\n            high = mid; \r\n    return arr[high]; ", "task_id": "Python/225", "test_setup": "", "test": ["assert find_Min([1,2,3,4,5],0,4) == 1", "assert find_Min([4,6,8],0,2) == 4", "assert find_Min([2,3,5,7,9],0,4) == 2"], "challenge_test_list": [], "func_title": "def find_Min(arr,low,high): \r", "prompt_text_chinese": "编写一个Python函数，在一个已排序和已旋转的数组中找出最小的元素。", "code_comment": "定义一个函数，用于查找旋转数组中的最小元素\n循环执行以下操作，直到low等于high为止\n计算数组的中间位置mid\n如果arr[mid]等于arr[high]，则说明最小元素在mid和high之间，将high减1\n如果arr[mid]大于arr[high]，则说明最小元素在mid和high之间，将low设为mid+1\n如果arr[mid]小于arr[high]，则说明最小元素在low和mid之间，将high设为mid\n返回最小元素\n"}
{"prompt": "Write a python function to remove the characters which have odd index values of a given string.", "canonical_solution": "def odd_values_string(str):\r\n  result = \"\" \r\n  for i in range(len(str)):\r\n    if i % 2 == 0:\r\n      result = result + str[i]\r\n  return result", "task_id": "Python/226", "test_setup": "", "test": ["assert odd_values_string('abcdef') == 'ace'", "assert odd_values_string('python') == 'pto'", "assert odd_values_string('data') == 'dt'"], "challenge_test_list": [], "func_title": "def odd_values_string(str):\r", "prompt_text_chinese": "编写一个Python函数，删除给定字符串中具有奇数索引值的字符。", "code_comment": "定义一个函数，用于从字符串中提取所有下标为奇数的字符\n将result初始值设为空字符串\n遍历字符串中的每个字符\n如果当前字符的下标为偶数，则将其添加到结果字符串result中\n返回结果字符串result\n"}
{"prompt": "Write a function to find minimum of three numbers.", "canonical_solution": "def min_of_three(a,b,c): \r\n      if (a <= b) and (a <= c): \r\n        smallest = a \r\n      elif (b <= a) and (b <= c): \r\n        smallest = b \r\n      else: \r\n        smallest = c \r\n      return smallest ", "task_id": "Python/227", "test_setup": "", "test": ["assert min_of_three(10,20,0)==0", "assert min_of_three(19,15,18)==15", "assert min_of_three(-10,-20,-30)==-30"], "challenge_test_list": [], "func_title": "def min_of_three(a,b,c): \r", "prompt_text_chinese": "写一个函数来寻找三个数字的最小值。", "code_comment": "定义一个函数，用于返回三个数中的最小值\n如果a小于等于b，且小于等于c，则将a设为最小值\n如果b小于等于a，且小于等于c，则将b设为最小值\n否则，将c设为最小值\n返回最小值\n"}
{"prompt": "Write a python function to check whether all the bits are unset in the given range or not.", "canonical_solution": "def all_Bits_Set_In_The_Given_Range(n,l,r):  \r\n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \r\n    new_num = n & num\r\n    if (new_num == 0): \r\n        return True\r\n    return False", "task_id": "Python/228", "test_setup": "", "test": ["assert all_Bits_Set_In_The_Given_Range(4,1,2) == True", "assert all_Bits_Set_In_The_Given_Range(17,2,4) == True", "assert all_Bits_Set_In_The_Given_Range(39,4,6) == False"], "challenge_test_list": [], "func_title": "def all_Bits_Set_In_The_Given_Range(n,l,r):  \r", "prompt_text_chinese": "写一个Python函数，检查在给定的范围内是否所有的位都没有被设置。", "code_comment": "定义一个函数，用于检查一个二进制数中从第l个位到第r个位是否都为1\n计算一个二进制数，从第r个位到第l个位都为1\n将n与num进行按位与运算，得到一个新的二进制数new_num\n如果new_num等于0，则表示n中从第l个位到第r个位都为1，返回True\n否则，返回False\n"}
{"prompt": "Write a function to re-arrange the elements of the given array so that all negative elements appear before positive ones.", "canonical_solution": "def re_arrange_array(arr, n):\r\n  j=0\r\n  for i in range(0, n):\r\n    if (arr[i] < 0):\r\n      temp = arr[i]\r\n      arr[i] = arr[j]\r\n      arr[j] = temp\r\n      j = j + 1\r\n  return arr", "task_id": "Python/229", "test_setup": "", "test": ["assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]", "assert re_arrange_array([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]", "assert re_arrange_array([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]"], "challenge_test_list": [], "func_title": "def re_arrange_array(arr, n):\r", "prompt_text_chinese": "写一个函数来重新排列给定数组中的元素，使所有负数元素出现在正数元素之前。", "code_comment": "定义一个函数，用于重新排列数组，将所有负数移到数组的前面\n定义一个变量j，用于记录负数的位置\n遍历数组中的每个元素\n如果当前元素是负数，则将其与j位置上的元素交换\n更新j的值\n返回重新排列后的数组\n"}
{"prompt": "Write a function to replace blank spaces with any character in a string.", "canonical_solution": "def replace_blank(str1,char):\r\n str2 = str1.replace(' ', char)\r\n return str2", "task_id": "Python/230", "test_setup": "", "test": ["assert replace_blank(\"hello people\",'@')==(\"hello@people\")", "assert replace_blank(\"python program language\",'$')==(\"python$program$language\")", "assert replace_blank(\"blank space\",\"-\")==(\"blank-space\")"], "challenge_test_list": [], "func_title": "def replace_blank(str1,char):\r", "prompt_text_chinese": "写一个函数，用字符串中的任何字符替换空白处。", "code_comment": "定义一个函数，用于将字符串中的空格替换为指定的字符\n调用replace()函数，将字符串str1中的空格替换为指定的字符char，并将结果保存为新字符串str2\n返回替换后的字符串str2\n"}
{"prompt": "Write a function to find the maximum sum in the given right triangle of numbers.", "canonical_solution": "def max_sum(tri, n): \r\n\tif n > 1: \r\n\t\ttri[1][1] = tri[1][1]+tri[0][0] \r\n\t\ttri[1][0] = tri[1][0]+tri[0][0] \r\n\tfor i in range(2, n): \r\n\t\ttri[i][0] = tri[i][0] + tri[i-1][0] \r\n\t\ttri[i][i] = tri[i][i] + tri[i-1][i-1] \r\n\t\tfor j in range(1, i): \r\n\t\t\tif tri[i][j]+tri[i-1][j-1] >= tri[i][j]+tri[i-1][j]: \r\n\t\t\t\ttri[i][j] = tri[i][j] + tri[i-1][j-1] \r\n\t\t\telse: \r\n\t\t\t\ttri[i][j] = tri[i][j]+tri[i-1][j] \r\n\treturn (max(tri[n-1]))", "task_id": "Python/231", "test_setup": "", "test": ["assert max_sum([[1], [2,1], [3,3,2]], 3) == 6", "assert max_sum([[1], [1, 2], [4, 1, 12]], 3) == 15 ", "assert max_sum([[2], [3,2], [13,23,12]], 3) == 28"], "challenge_test_list": [], "func_title": "def max_sum(tri, n): \r", "prompt_text_chinese": "写一个函数，找出给定的直角三角形中的最大和。", "code_comment": "定义一个函数，用于计算数字三角形中从顶部到底部路径上的最大和\n如果数字三角形的行数大于1，则将第二行的两个元素加上第一行的一个元素\n遍历数字三角形中的每一行\n对于每一行，将第一个元素加上上一行的第一个元素\n对于每一行，将最后一个元素加上上一行的最后一个元素\n对于每一行的中间元素，分别计算其与上一行相邻两个元素的和，取其中较大的值加上当前元素\n返回数字三角形最后一行中的最大值\n"}
{"prompt": "Write a function to get the n largest items from a dataset.", "canonical_solution": "import heapq\r\ndef larg_nnum(list1,n):\r\n largest=heapq.nlargest(n,list1)\r\n return largest", "task_id": "Python/232", "test_setup": "", "test": ["assert larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],2)==[100,90]", "assert larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],5)==[100,90,80,70,60]", "assert larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],3)==[100,90,80]"], "challenge_test_list": [], "func_title": "def larg_nnum(list1,n):\r", "prompt_text_chinese": "写一个函数，从一个数据集中得到最大的n个项目。", "code_comment": "导入heapq模块\n定义一个函数，用于找出列表中第n大的数\n使用heapq.nlargest()函数，找出列表list1中最大的n个数，并将其保存到变量largest中\n返回列表中第n大的数\n"}
{"prompt": "Write a function to find the lateral surface area of a cylinder.", "canonical_solution": "def lateralsuface_cylinder(r,h):\r\n  lateralsurface= 2*3.1415*r*h\r\n  return lateralsurface", "task_id": "Python/233", "test_setup": "", "test": ["assert lateralsuface_cylinder(10,5)==314.15000000000003", "assert lateralsuface_cylinder(4,5)==125.66000000000001", "assert lateralsuface_cylinder(4,10)==251.32000000000002"], "challenge_test_list": [], "func_title": "def lateralsuface_cylinder(r,h):\r", "prompt_text_chinese": "写一个函数来求一个圆柱体的侧表面积。", "code_comment": "定义一个函数，用于计算圆柱侧面积\n根据圆柱的半径r和高h计算圆柱的侧面积\n返回计算结果\n"}
{"prompt": "Write a function to find the volume of a cube.", "canonical_solution": "def volume_cube(l):\r\n  volume = l * l * l\r\n  return volume", "task_id": "Python/234", "test_setup": "", "test": ["assert volume_cube(3)==27", "assert volume_cube(2)==8", "assert volume_cube(5)==125"], "challenge_test_list": [], "func_title": "def volume_cube(l):\r", "prompt_text_chinese": "写一个函数来求一个立方体的体积。", "code_comment": "定义一个函数，用于计算正方体的体积\n根据正方体的边长l计算正方体的体积\n返回计算结果\n"}
{"prompt": "Write a python function to set all even bits of a given number.", "canonical_solution": "def even_bit_set_number(n): \r\n    count = 0;res = 0;temp = n \r\n    while(temp > 0): \r\n        if (count % 2 == 1): \r\n            res |= (1 << count)\r\n        count+=1\r\n        temp >>= 1\r\n    return (n | res) ", "task_id": "Python/235", "test_setup": "", "test": ["assert even_bit_set_number(10) == 10", "assert even_bit_set_number(20) == 30", "assert even_bit_set_number(30) == 30"], "challenge_test_list": [], "func_title": "def even_bit_set_number(n): \r", "prompt_text_chinese": "写一个Python函数来设置一个给定数字的所有偶数位。", "code_comment": "定义一个函数，用于将二进制数中的奇数位全部设置为1，偶数位全部设置为0\n定义一个计数器count，用于记录当前位数，初始值为0\n定义一个变量res，用于存储结果，初始值为0\n定义一个变量temp，用于存储n的值\n循环处理n中的每一位\n如果当前位是奇数位，则将res中对应的位设置为1\n更新计数器count和temp的值\n将n和res进行按位或运算，返回结果\n"}
{"prompt": "Write a python function to count the maximum number of equilateral triangles that can be formed within a given equilateral triangle.", "canonical_solution": "def No_of_Triangle(N,K):\r\n    if (N < K):\r\n        return -1;\r\n    else:\r\n        Tri_up = 0;\r\n        Tri_up = ((N - K + 1) *(N - K + 2)) // 2;\r\n        Tri_down = 0;\r\n        Tri_down = ((N - 2 * K + 1) *(N - 2 * K + 2)) // 2;\r\n        return Tri_up + Tri_down;", "task_id": "Python/236", "test_setup": "", "test": ["assert No_of_Triangle(4,2) == 7", "assert No_of_Triangle(4,3) == 3", "assert No_of_Triangle(1,3) == -1"], "challenge_test_list": [], "func_title": "def No_of_Triangle(N,K):\r", "prompt_text_chinese": "写一个Python函数，计算在给定的等边三角形内可以形成的最大数量。", "code_comment": "定义一个函数，用于计算N个点能够组成的、至少有K个点的三角形的数量\n如果N小于K，则无法组成三角形，返回-1\n否则，分别计算上三角形和下三角形的数量，然后将它们相加\n计算上三角形的数量\n计算下三角形的数量\n返回上下三角形数量的和\n"}
{"prompt": "Write a function to check the occurrences of records which occur similar times in the given tuples.", "canonical_solution": "from collections import Counter \r\ndef check_occurences(test_list):\r\n  res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))\r\n  return  (res) ", "task_id": "Python/237", "test_setup": "", "test": ["assert check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)] ) == {(1, 3): 2, (2, 5): 2, (3, 6): 1}", "assert check_occurences([(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)] ) == {(2, 4): 2, (3, 6): 2, (4, 7): 1}", "assert check_occurences([(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)] ) == {(2, 13): 1, (11, 23): 1, (12, 25): 2, (16, 23): 1}"], "challenge_test_list": [], "func_title": "def check_occurences(test_list):\r", "prompt_text_chinese": "写一个函数来检查在给定图元中出现类似次数的记录的出现。", "code_comment": "导入collections模块中的Counter类\n定义一个函数，用于检查列表中各元素出现的次数\n将列表中的每个元素进行排序，并将结果保存为元组，然后使用Counter类统计各元组的出现次数\n返回各元素出现次数的统计结果\n"}
{"prompt": "Write a python function to count number of non-empty substrings of a given string.", "canonical_solution": "def number_of_substrings(str): \r\n\tstr_len = len(str); \r\n\treturn int(str_len * (str_len + 1) / 2); ", "task_id": "Python/238", "test_setup": "", "test": ["assert number_of_substrings(\"abc\") == 6", "assert number_of_substrings(\"abcd\") == 10", "assert number_of_substrings(\"abcde\") == 15"], "challenge_test_list": [], "func_title": "def number_of_substrings(str): \r", "prompt_text_chinese": "写一个Python函数来计算一个给定字符串的非空子串的数量。", "code_comment": "定义一个函数，用于计算给定字符串的子串数量\n获取字符串的长度\n根据字符串的长度计算子串的数量，并将结果转换为整数后返回\n"}
{"prompt": "Write a function to find the number of possible sequences of length n such that each of the next element is greater than or equal to twice of the previous element but less than or equal to m.", "canonical_solution": "def get_total_number_of_sequences(m,n): \r\n\tT=[[0 for i in range(n+1)] for i in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tif i==0 or j==0: \r\n\t\t\t\tT[i][j]=0\r\n\t\t\telif i<j: \r\n\t\t\t\tT[i][j]=0\r\n\t\t\telif j==1: \r\n\t\t\t\tT[i][j]=i \r\n\t\t\telse: \r\n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \r\n\treturn T[m][n]", "task_id": "Python/239", "test_setup": "", "test": ["assert get_total_number_of_sequences(10, 4) == 4", "assert get_total_number_of_sequences(5, 2) == 6", "assert get_total_number_of_sequences(16, 3) == 84"], "challenge_test_list": [], "func_title": "def get_total_number_of_sequences(m,n): \r", "prompt_text_chinese": "写一个函数，找出长度为n的可能序列的数量，使每个下一个元素大于或等于前一个元素的两倍，但小于或等于m。", "code_comment": "定义一个函数，用于计算长度为n，由1~m之间的数字组成的序列的总数\n初始化一个二维列表T，用于存储子问题的解\n遍历T中的每个元素，求解子问题\n如果i为0或j为0，则无法生成序列，将T[i][j]设为0\n如果m小于j，则无法组成长度为j的序列，设T[i][j]的值为0\n如果j等于1，则只有一种可能，即将一个数字重复j次，T[i][j]等于i\n否则，当前序列的最后一个数可能是1i之间的任意一个数，因此需要将问题拆分成两个子问题，并将它们的解加起来\n返回T[m][n]，即长度为n，由1m之间的数字组成的序列的总数\n"}
{"prompt": "Write a function to replace the last element of the list with another list.", "canonical_solution": "def replace_list(list1,list2):\r\n list1[-1:] = list2\r\n replace_list=list1\r\n return replace_list\r\n", "task_id": "Python/240", "test_setup": "", "test": ["assert replace_list([1, 3, 5, 7, 9, 10],[2, 4, 6, 8])==[1, 3, 5, 7, 9, 2, 4, 6, 8]", "assert replace_list([1,2,3,4,5],[5,6,7,8])==[1,2,3,4,5,6,7,8]", "assert replace_list([\"red\",\"blue\",\"green\"],[\"yellow\"])==[\"red\",\"blue\",\"yellow\"]"], "challenge_test_list": [], "func_title": "def replace_list(list1,list2):\r", "prompt_text_chinese": "写一个函数，用另一个列表替换列表中的最后一个元素。", "code_comment": "定义一个函数，用于将列表list1的最后一个元素替换为列表list2\n将列表list1的最后一个元素替换为列表list2\n将替换后的列表list1赋值给replace_list，并返回replace_list\n"}
{"prompt": "Write a function to generate a 3d array having each element as '*'.", "canonical_solution": "def array_3d(m,n,o):\r\n array_3d = [[ ['*' for col in range(m)] for col in range(n)] for row in range(o)]\r\n return array_3d", "task_id": "Python/241", "test_setup": "", "test": ["assert array_3d(6,4,3)==[[['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*']]]", "assert array_3d(5,3,4)==[[['*', '*', '*', '*', '*'], ['*', '*', '*', '*','*'], ['*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*'],['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*']]]", "assert array_3d(1,2,3)==[[['*'],['*']],[['*'],['*']],[['*'],['*']]]"], "challenge_test_list": [], "func_title": "def array_3d(m,n,o):\r", "prompt_text_chinese": "写一个函数来生成一个三维数组，每个元素都是'*'。", "code_comment": "定义一个函数，用于创建一个3维数组\n创建一个3维列表array_3d，列表中的每个元素都是一个列表，每个列表中含有m个元素，初始值都为''\n返回创建的3维数组array_3d\n"}
{"prompt": "Write a function to count total characters in a string.", "canonical_solution": "def count_charac(str1):\r\n total = 0\r\n for i in str1:\r\n    total = total + 1\r\n return total", "task_id": "Python/242", "test_setup": "", "test": ["assert count_charac(\"python programming\")==18", "assert count_charac(\"language\")==8", "assert count_charac(\"words\")==5"], "challenge_test_list": [], "func_title": "def count_charac(str1):\r", "prompt_text_chinese": "写一个函数来计算一个字符串中的总字符数。", "code_comment": "定义一个函数，用于计算给定字符串的字符数\n初始化一个计数器total，用于记录字符串中的字符数\n遍历字符串str1中的每个字符，将计数器加1\n返回字符串中的字符数\n"}
{"prompt": "Write a function to sort the given list based on the occurrence of first element of tuples.", "canonical_solution": "def sort_on_occurence(lst): \r\n\tdct = {} \r\n\tfor i, j in lst: \r\n\t\tdct.setdefault(i, []).append(j) \r\n\treturn ([(i, *dict.fromkeys(j), len(j)) \r\n\t\t\t\tfor i, j in dct.items()]) ", "task_id": "Python/243", "test_setup": "", "test": ["assert sort_on_occurence([(1, 'Jake'), (2, 'Bob'), (1, 'Cara')]) == [(1, 'Jake', 'Cara', 2), (2, 'Bob', 1)]", "assert sort_on_occurence([('b', 'ball'), ('a', 'arm'), ('b', 'b'), ('a', 'ant')]) == [('b', 'ball', 'b', 2), ('a', 'arm', 'ant', 2)]", "assert sort_on_occurence([(2, 'Mark'), (3, 'Maze'), (2, 'Sara')]) == [(2, 'Mark', 'Sara', 2), (3, 'Maze', 1)]"], "challenge_test_list": [], "func_title": "def sort_on_occurence(lst): \r", "prompt_text_chinese": "写一个函数，根据元组中第一个元素的出现情况对给定的列表进行排序。", "code_comment": "定义一个函数，用于按照列表中元素出现的次数对列表进行排序\n定义一个字典dct，用于存储列表中每个元素出现的次数\n将字典dct中的元素转换为列表，并按照元素出现次数进行排序\n"}
{"prompt": "Write a python function to find the next perfect square greater than a given number.", "canonical_solution": "import math  \r\ndef next_Perfect_Square(N): \r\n    nextN = math.floor(math.sqrt(N)) + 1\r\n    return nextN * nextN ", "task_id": "Python/244", "test_setup": "", "test": ["assert next_Perfect_Square(35) == 36", "assert next_Perfect_Square(6) == 9", "assert next_Perfect_Square(9) == 16"], "challenge_test_list": [], "func_title": "def next_Perfect_Square(N): \r", "prompt_text_chinese": "写一个Python函数来寻找大于给定数字的下一个完全平方。", "code_comment": "导入math模块\n定义一个函数，用于获取指定数字N的下一个完全平方数\n计算N的平方根，并向下取整，得到N的下一个整数\n返回下一个完全平方数\n"}
{"prompt": "Write a function to find the maximum sum of bi-tonic sub-sequence for the given array.", "canonical_solution": "def max_sum(arr, n): \r\n\tMSIBS = arr[:] \r\n\tfor i in range(n): \r\n\t\tfor j in range(0, i): \r\n\t\t\tif arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: \r\n\t\t\t\tMSIBS[i] = MSIBS[j] + arr[i] \r\n\tMSDBS = arr[:] \r\n\tfor i in range(1, n + 1): \r\n\t\tfor j in range(1, i): \r\n\t\t\tif arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: \r\n\t\t\t\tMSDBS[-i] = MSDBS[-j] + arr[-i] \r\n\tmax_sum = float(\"-Inf\") \r\n\tfor i, j, k in zip(MSIBS, MSDBS, arr): \r\n\t\tmax_sum = max(max_sum, i + j - k) \r\n\treturn max_sum", "task_id": "Python/245", "test_setup": "", "test": ["assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9], 9) == 194", "assert max_sum([80, 60, 30, 40, 20, 10], 6) == 210", "assert max_sum([2, 3 ,14, 16, 21, 23, 29, 30], 8) == 138"], "challenge_test_list": [], "func_title": "def max_sum(arr, n): \r", "prompt_text_chinese": "写一个函数来寻找给定数组的双调子序列的最大和。", "code_comment": "定义一个函数，用于计算数组arr的最大子序列和\n初始化一个列表MSIBS，用于记录arr中以arr[i]结尾的最大子序列和\n初始化一个列表MSDBS，用于记录arr中以arr[-i]结尾的最大逆序子序列和\n初始化一个变量max_sum，用于记录最大子序列和\n返回最大子序列和\n"}
{"prompt": "Write a function for computing square roots using the babylonian method.", "canonical_solution": "def babylonian_squareroot(number):\r\n    if(number == 0):\r\n        return 0;\r\n    g = number/2.0;\r\n    g2 = g + 1;\r\n    while(g != g2):\r\n        n = number/ g;\r\n        g2 = g;\r\n        g = (g + n)/2;\r\n    return g;", "task_id": "Python/246", "test_setup": "", "test": ["assert babylonian_squareroot(10)==3.162277660168379", "assert babylonian_squareroot(2)==1.414213562373095", "assert babylonian_squareroot(9)==3.0"], "challenge_test_list": [], "func_title": "def babylonian_squareroot(number):\r", "prompt_text_chinese": "写一个用巴比伦法计算平方根的函数。", "code_comment": "定义一个函数，用于计算给定数字的平方根\n如果给定数字为0，则直接返回0\n初始化变量g和g2，g为number的一半，g2为g+1\n当g和g2的值不同时，进行迭代，直至g的值趋近于number的平方根\n计算number除以g的商\n更新g2的值为g\n更新g的值，g等于g加上number除以g的商再除以2\n返回number的平方根\n"}
{"prompt": "Write a function to find the longest palindromic subsequence in the given string.", "canonical_solution": "def lps(str): \r\n\tn = len(str) \r\n\tL = [[0 for x in range(n)] for x in range(n)] \r\n\tfor i in range(n): \r\n\t\tL[i][i] = 1\r\n\tfor cl in range(2, n+1): \r\n\t\tfor i in range(n-cl+1): \r\n\t\t\tj = i+cl-1\r\n\t\t\tif str[i] == str[j] and cl == 2: \r\n\t\t\t\tL[i][j] = 2\r\n\t\t\telif str[i] == str[j]: \r\n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\r\n\t\t\telse: \r\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \r\n\treturn L[0][n-1]", "task_id": "Python/247", "test_setup": "", "test": ["assert lps(\"TENS FOR TENS\") == 5 ", "assert lps(\"CARDIO FOR CARDS\") == 7", "assert lps(\"PART OF THE JOURNEY IS PART\") == 9 "], "challenge_test_list": [], "func_title": "def lps(str): \r", "prompt_text_chinese": "写一个函数来寻找给定字符串中最长的宫格子序列。", "code_comment": "定义一个函数，用于计算给定字符串的最长回文子序列的长度\n获取字符串的长度\n初始化一个二维列表L，用于记录最长回文子序列的长度\n遍历字符串中的每个字符，将长度为1的子序列的最长回文子序列长度设置为1\n遍历字符串中的每个字符，依次计算长度为2到n的子序列的最长回文子序列长度\n返回最长回文子序列的长度\n"}
{"prompt": "Write a function to calculate the harmonic sum of n-1.", "canonical_solution": "def harmonic_sum(n):\r\n  if n < 2:\r\n    return 1\r\n  else:\r\n    return 1 / n + (harmonic_sum(n - 1)) ", "task_id": "Python/248", "test_setup": "", "test": ["assert harmonic_sum(7) == 2.5928571428571425", "assert harmonic_sum(4) == 2.083333333333333", "assert harmonic_sum(19) == 3.547739657143682"], "challenge_test_list": [], "func_title": "def harmonic_sum(n):\r", "prompt_text_chinese": "写一个函数来计算n-1的谐和。", "code_comment": "定义一个函数，用于计算n个调和级数的和\n如果n小于2，则直接返回1\n否则，计算前n-1个调和级数的和，再加上第n个调和级数的倒数\n"}
{"prompt": "Write a function to find the intersection of two arrays using lambda function.", "canonical_solution": "def intersection_array(array_nums1,array_nums2):\r\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \r\n return result", "task_id": "Python/249", "test_setup": "", "test": ["assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[1, 2, 4, 8, 9])==[1, 2, 8, 9]", "assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[3,5,7,9])==[3,5,7,9]", "assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[10,20,30,40])==[10]"], "challenge_test_list": [], "func_title": "def intersection_array(array_nums1,array_nums2):\r", "prompt_text_chinese": "写一个函数，用lambda函数找到两个数组的交点。", "code_comment": "定义一个函数，用于计算两个数组的交集\n使用filter函数和lambda表达式，筛选出在array_nums2中也存在于array_nums1中的元素，并将它们放入一个新的列表中\n返回交集列表\n"}
{"prompt": "Write a python function to count the occcurences of an element in a tuple.", "canonical_solution": "def count_X(tup, x): \r\n    count = 0\r\n    for ele in tup: \r\n        if (ele == x): \r\n            count = count + 1\r\n    return count ", "task_id": "Python/250", "test_setup": "", "test": ["assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),4) == 0", "assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),10) == 3", "assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),8) == 4"], "challenge_test_list": [], "func_title": "def count_X(tup, x): \r", "prompt_text_chinese": "写一个Python函数来计算一个元组中一个元素的出现次数。", "code_comment": "定义一个函数，用于计算给定元组中元素x的出现次数\n初始化计数器count\n遍历元组中的每个元素，如果该元素等于x，则将计数器加1\n返回元素x在元组中的出现次数\n"}
{"prompt": "Write a function to insert an element before each element of a list.", "canonical_solution": "def insert_element(list,element):\r\n list = [v for elt in list for v in (element, elt)]\r\n return list", "task_id": "Python/251", "test_setup": "", "test": ["assert insert_element(['Red', 'Green', 'Black'] ,'c')==['c', 'Red', 'c', 'Green', 'c', 'Black'] ", "assert insert_element(['python', 'java'] ,'program')==['program', 'python', 'program', 'java'] ", "assert insert_element(['happy', 'sad'] ,'laugh')==['laugh', 'happy', 'laugh', 'sad'] "], "challenge_test_list": [], "func_title": "def insert_element(list,element):\r", "prompt_text_chinese": "写一个函数，在一个列表的每个元素之前插入一个元素。", "code_comment": "定义一个函数，用于将给定元素插入到列表的每个元素前面\n使用列表推导式，在原列表的每个元素前面插入给定元素，并将结果存储在列表中\n返回插入元素后的列表\n"}
{"prompt": "Write a python function to convert complex numbers to polar coordinates.", "canonical_solution": "import cmath  \r\ndef convert(numbers):    \r\n  num = cmath.polar(numbers)  \r\n  return (num) ", "task_id": "Python/252", "test_setup": "", "test": ["assert convert(1) == (1.0, 0.0)", "assert convert(4) == (4.0,0.0)", "assert convert(5) == (5.0,0.0)"], "challenge_test_list": [], "func_title": "def convert(numbers):    \r", "prompt_text_chinese": "写一个将复数转换为极坐标的Python函数。", "code_comment": "导入cmath模块\n定义一个函数，用于将给定的复数转换为极坐标形式\n调用cmath库中的polar函数，将复数转换为极坐标形式，并将结果存储在变量num中\n返回转换后的结果\n"}
{"prompt": "Write a python function to count integers from a given list.", "canonical_solution": "def count_integer(list1):\r\n    ctr = 0\r\n    for i in list1:\r\n        if isinstance(i, int):\r\n            ctr = ctr + 1\r\n    return ctr", "task_id": "Python/253", "test_setup": "", "test": ["assert count_integer([1,2,'abc',1.2]) == 2", "assert count_integer([1,2,3]) == 3", "assert count_integer([1,1.2,4,5.1]) == 2"], "challenge_test_list": [], "func_title": "def count_integer(list1):\r", "prompt_text_chinese": "编写一个Python函数，从一个给定的列表中计算整数。", "code_comment": "定义一个函数，用于计算给定列表中整数的数量\n初始化计数器ctr\n遍历列表中的每个元素，如果该元素是整数，则将计数器加1\n返回列表中整数的数量\n"}
{"prompt": "Write a function to find all words starting with 'a' or 'e' in a given string.", "canonical_solution": "import re\r\ndef words_ae(text):\r\n list = re.findall(\"[ae]\\w+\", text)\r\n return list", "task_id": "Python/254", "test_setup": "", "test": ["assert words_ae(\"python programe\")==['ame']", "assert words_ae(\"python programe language\")==['ame','anguage']", "assert words_ae(\"assert statement\")==['assert', 'atement']"], "challenge_test_list": [], "func_title": "def words_ae(text):\r", "prompt_text_chinese": "写一个函数，在给定的字符串中找到所有以'a'或'e'开头的单词。", "code_comment": "导入re模块\n定义一个函数，用于从文本中提取以a或e开头的单词\n使用re模块的findall函数，查找文本中所有以a或e开头的单词，并将结果存储在列表中\n返回提取出的单词列表\n"}
{"prompt": "Write a function to choose specified number of colours from three different colours and generate all the combinations with repetitions.", "canonical_solution": "from itertools import combinations_with_replacement \r\ndef combinations_colors(l, n):\r\n    return list(combinations_with_replacement(l,n))\r", "task_id": "Python/255", "test_setup": "", "test": ["assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],1)==[('Red',), ('Green',), ('Blue',)]", "assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],2)==[('Red', 'Red'), ('Red', 'Green'), ('Red', 'Blue'), ('Green', 'Green'), ('Green', 'Blue'), ('Blue', 'Blue')]", "assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],3)==[('Red', 'Red', 'Red'), ('Red', 'Red', 'Green'), ('Red', 'Red', 'Blue'), ('Red', 'Green', 'Green'), ('Red', 'Green', 'Blue'), ('Red', 'Blue', 'Blue'), ('Green', 'Green', 'Green'), ('Green', 'Green', 'Blue'), ('Green', 'Blue', 'Blue'), ('Blue', 'Blue', 'Blue')]"], "challenge_test_list": [], "func_title": "def combinations_colors(l, n):\r", "prompt_text_chinese": "编写一个函数，从三种不同的颜色中选择指定数量的颜色，并生成所有重复的组合。", "code_comment": "导入itertools模块中的combinations_with_replacement函数\n使用combinations_with_replacement函数，从列表l中选取n个元素的所有组合，包含重复元素\n返回组合的生成器对象\n"}
{"prompt": "Write a python function to count the number of prime numbers less than a given non-negative number.", "canonical_solution": "def count_Primes_nums(n):\r\n    ctr = 0\r\n    for num in range(n):\r\n        if num <= 1:\r\n            continue\r\n        for i in range(2,num):\r\n            if (num % i) == 0:\r\n                break\r\n        else:\r\n            ctr += 1\r\n    return ctr", "task_id": "Python/256", "test_setup": "", "test": ["assert count_Primes_nums(5) == 2", "assert count_Primes_nums(10) == 4", "assert count_Primes_nums(100) == 25"], "challenge_test_list": [], "func_title": "def count_Primes_nums(n):\r", "prompt_text_chinese": "写一个python函数，计算小于给定非负数的质数的数量。", "code_comment": "这段代码定义了一个函数 count_Primes_nums，接收一个整数参数 n，用于计算小于等于 n 的质数的个数。\n函数实现的过程：\n初始化计数器 ctr 值为 0\n遍历 0 到 n-1 之间的所有整数，并用 num 表示当前数字\n如果当前数字 num 小于等于 1，则跳过此次循环，继续遍历下一个数字\n否则，将当前数字 num 除以 2 到 num-1 之间的每个整数，如果可以整除，则退出循环\n如果 num 是质数，则将计数器 ctr 加 1\n最后，函数返回小于等于 n 的质数个数 ctr"}
{"prompt": "Write a function to swap two numbers.", "canonical_solution": "def swap_numbers(a,b):\r\n temp = a\r\n a = b\r\n b = temp\r\n return (a,b)", "task_id": "Python/257", "test_setup": "", "test": ["assert swap_numbers(10,20)==(20,10)", "assert swap_numbers(15,17)==(17,15)", "assert swap_numbers(100,200)==(200,100)"], "challenge_test_list": [], "func_title": "def swap_numbers(a,b):\r", "prompt_text_chinese": "写一个函数来交换两个数字。", "code_comment": "定义一个函数，用于交换两个变量的值\n将变量a的值赋给临时变量temp\n将变量b的值赋给变量a\n将临时变量temp的值赋给变量b\n返回交换后的结果\n"}
{"prompt": "Write a function to find number of odd elements in the given list using lambda function.", "canonical_solution": "def count_odd(array_nums):\r\n   count_odd = len(list(filter(lambda x: (x%2 != 0) , array_nums)))\r\n   return count_odd", "task_id": "Python/258", "test_setup": "", "test": ["assert count_odd([1, 2, 3, 5, 7, 8, 10])==4", "assert count_odd([10,15,14,13,-18,12,-20])==2", "assert count_odd([1, 2, 4, 8, 9])==2"], "challenge_test_list": [], "func_title": "def count_odd(array_nums):\r", "prompt_text_chinese": "写一个函数，用lambda函数找出给定列表中奇数元素的数量。", "code_comment": "定义一个函数，用于计算给定数组中奇数的数量\n使用filter函数和lambda表达式，筛选出数组中的奇数，并将其转换为列表形式，计算列表长度\n返回数组中奇数的数量\n"}
{"prompt": "Write a function to maximize the given two tuples.", "canonical_solution": "def maximize_elements(test_tup1, test_tup2):\r\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\r\n   for tup1, tup2 in zip(test_tup1, test_tup2))\r\n  return (res) ", "task_id": "Python/259", "test_setup": "", "test": ["assert maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 7), (4, 9), (2, 9), (7, 10))", "assert maximize_elements(((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) == ((7, 8), (5, 10), (3, 10), (8, 11))", "assert maximize_elements(((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) == ((8, 9), (6, 11), (4, 11), (9, 12))"], "challenge_test_list": [], "func_title": "def maximize_elements(test_tup1, test_tup2):\r", "prompt_text_chinese": "写一个函数来最大化给定的两个图元。", "code_comment": "定义一个函数，用于比较两个元组的每个位置上的元素，返回每个位置上元素的较大值所组成的元组\n使用zip函数将两个元组中相同位置上的元素组合起来，使用max函数对每对组合中的元素进行比较，返回较大值\n最后使用tuple函数将得到的所有元素组合成一个新的元组\n返回包含较大值元素的元组\n"}
{"prompt": "Write a function to find the nth newman–shanks–williams prime number.", "canonical_solution": "def newman_prime(n): \r\n\tif n == 0 or n == 1: \r\n\t\treturn 1\r\n\treturn 2 * newman_prime(n - 1) + newman_prime(n - 2)", "task_id": "Python/260", "test_setup": "", "test": ["assert newman_prime(3) == 7 ", "assert newman_prime(4) == 17", "assert newman_prime(5) == 41"], "challenge_test_list": [], "func_title": "def newman_prime(n): \r", "prompt_text_chinese": "写一个函数来寻找第n个纽曼-尚克斯-威廉斯素数。", "code_comment": "定义一个函数，用于计算Newman-Conway素数序列中第n个数的值\n如果n等于0或1，则返回1\n递归调用newman_prime函数，计算n-1和n-2位置上的数，并求和，最后乘以2\n"}
{"prompt": "Write a function to perform mathematical division operation across the given tuples.", "canonical_solution": "def division_elements(test_tup1, test_tup2):\r\n  res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res) ", "task_id": "Python/261", "test_setup": "", "test": ["assert division_elements((10, 4, 6, 9),(5, 2, 3, 3)) == (2, 2, 2, 3)", "assert division_elements((12, 6, 8, 16),(6, 3, 4, 4)) == (2, 2, 2, 4)", "assert division_elements((20, 14, 36, 18),(5, 7, 6, 9)) == (4, 2, 6, 2)"], "challenge_test_list": [], "func_title": "def division_elements(test_tup1, test_tup2):\r", "prompt_text_chinese": "写一个函数，对给定的图元进行数学除法运算。", "code_comment": "定义一个函数，用于计算两个元组中相同位置上元素的商，并返回包含商的元组\n使用zip函数将两个元组中相同位置上的元素组合起来，使用//运算符计算商，最后使用tuple函数将得到的所有商组合成一个新的元组\n返回包含商的元组\n"}
{"prompt": "Write a function to split a given list into two parts where the length of the first part of the list is given.", "canonical_solution": "def split_two_parts(list1, L):\r\n    return list1[:L], list1[L:]", "task_id": "Python/262", "test_setup": "", "test": ["assert split_two_parts([1,1,2,3,4,4,5,1],3)==([1, 1, 2], [3, 4, 4, 5, 1])", "assert split_two_parts(['a', 'b', 'c', 'd'],2)==(['a', 'b'], ['c', 'd'])", "assert split_two_parts(['p', 'y', 't', 'h', 'o', 'n'],4)==(['p', 'y', 't', 'h'], ['o', 'n'])"], "challenge_test_list": [], "func_title": "def split_two_parts(list1, L):\r", "prompt_text_chinese": "写一个函数，将给定的列表分成两部分，其中列表的第一部分的长度是给定的。", "code_comment": "定义一个函数split_two_parts，接收两个参数：list1和L\n返回list1列表中，从0开始到L-1的元素和从L开始到列表结尾的元素，组成一个元组\n"}
{"prompt": "Write a function to merge two dictionaries.", "canonical_solution": "def merge_dict(d1,d2):\r\n d = d1.copy()\r\n d.update(d2)\r\n return d", "task_id": "Python/263", "test_setup": "", "test": ["assert merge_dict({'a': 100, 'b': 200},{'x': 300, 'y': 200})=={'x': 300, 'y': 200, 'a': 100, 'b': 200}", "assert merge_dict({'a':900,'b':900,'d':900},{'a':900,'b':900,'d':900})=={'a':900,'b':900,'d':900,'a':900,'b':900,'d':900}", "assert merge_dict({'a':10,'b':20},{'x':30,'y':40})=={'x':30,'y':40,'a':10,'b':20}"], "challenge_test_list": [], "func_title": "def merge_dict(d1,d2):\r", "prompt_text_chinese": "写一个函数来合并两个字典。", "code_comment": "定义一个函数merge_dict，接收两个字典类型的参数：d1和d2\n复制字典d1，生成一个新的字典d\n将字典d2中的所有键值对更新到字典d中\n返回合并后的字典d\n"}
{"prompt": "Write a function to calculate a dog's age in dog's years.", "canonical_solution": "def dog_age(h_age):\r\n if h_age < 0:\r\n \texit()\r\n elif h_age <= 2:\r\n\t d_age = h_age * 10.5\r\n else:\r\n\t d_age = 21 + (h_age - 2)*4\r\n return d_age", "task_id": "Python/264", "test_setup": "", "test": ["assert dog_age(12)==61", "assert dog_age(15)==73", "assert dog_age(24)==109"], "challenge_test_list": [], "func_title": "def dog_age(h_age):\r", "prompt_text_chinese": "写一个函数来计算一只狗的年龄，以狗的年数计算。", "code_comment": "定义一个函数dog_age，接收一个参数：h_age，即狗的年龄\n如果输入的狗的年龄小于0，则直接退出函数\n如果狗的年龄小于等于2岁，则按照每年相当于人类7岁的比例计算出狗的年龄\n如果狗的年龄大于2岁，则按照前两年每年10.5岁，之后每年相当于人类4岁的比例计算出狗的年龄\n返回计算出来的狗的年龄\n"}
{"prompt": "Write a function to split a list for every nth element.", "canonical_solution": "def list_split(S, step):\r\n    return [S[i::step] for i in range(step)]", "task_id": "Python/265", "test_setup": "", "test": ["assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'],3)==[['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']] ", "assert list_split([1,2,3,4,5,6,7,8,9,10,11,12,13,14],3)==[[1,4,7,10,13], [2,5,8,11,14], [3,6,9,12]] ", "assert list_split(['python','java','C','C++','DBMS','SQL'],2)==[['python', 'C', 'DBMS'], ['java', 'C++', 'SQL']] "], "challenge_test_list": [], "func_title": "def list_split(S, step):\r", "prompt_text_chinese": "写一个函数来分割列表中的每N个元素。", "code_comment": "定义一个函数list_split，接收两个参数：S和step\n返回一个列表，其中包含step个元素，每个元素是从S中以step为步长取值得到的子序列\n"}
{"prompt": "Write a function to find the lateral surface area of a cube.", "canonical_solution": "def lateralsurface_cube(l):\r\n  LSA = 4 * (l * l)\r\n  return LSA", "task_id": "Python/266", "test_setup": "", "test": ["assert lateralsurface_cube(5)==100", "assert lateralsurface_cube(9)==324", "assert lateralsurface_cube(10)==400"], "challenge_test_list": [], "func_title": "def lateralsurface_cube(l):\r", "prompt_text_chinese": "写一个函数来求一个立方体的侧表面积。", "code_comment": "定义一个函数lateralsurface_cube，接收一个参数l，表示正方体的边长\n计算正方体的侧面积，公式为4 * (边长 * 边长)\n返回正方体的侧面积\n"}
{"prompt": "Write a python function to find the sum of squares of first n odd natural numbers.", "canonical_solution": "def square_Sum(n):  \r\n    return int(n*(4*n*n-1)/3) ", "task_id": "Python/267", "test_setup": "", "test": ["assert square_Sum(2) == 10", "assert square_Sum(3) == 35", "assert square_Sum(4) == 84"], "challenge_test_list": [], "func_title": "def square_Sum(n):  \r", "prompt_text_chinese": "写一个python函数，求前n个奇数自然数的平方之和。", "code_comment": "定义一个函数square_Sum，接收一个参数n，表示正整数的个数\n计算n个正整数的平方和，公式为：n*(4nn-1)/3\n将计算结果转换为整型并返回\n"}
{"prompt": "Write a function to find the n'th star number.", "canonical_solution": "def find_star_num(n): \r\n\treturn (6 * n * (n - 1) + 1) ", "task_id": "Python/268", "test_setup": "", "test": ["assert find_star_num(3) == 37", "assert find_star_num(4) == 73", "assert find_star_num(5) == 121"], "challenge_test_list": [], "func_title": "def find_star_num(n): \r", "prompt_text_chinese": "写一个函数来寻找第n个星号。", "code_comment": "定义一个函数find_star_num，接收一个参数n，表示星星的层数\n根据公式求解第n层星星的个数：6 * n * (n - 1) + 1\n返回计算结果\n"}
{"prompt": "Write a function to find the ascii value of a character.", "canonical_solution": "def ascii_value(k):\r\n  ch=k\r\n  return ord(ch)", "task_id": "Python/269", "test_setup": "", "test": ["assert ascii_value('A')==65", "assert ascii_value('R')==82", "assert ascii_value('S')==83"], "challenge_test_list": [], "func_title": "def ascii_value(k):\r", "prompt_text_chinese": "写一个函数来查找一个字符的ascii值。", "code_comment": "定义一个函数ascii_value，接收一个参数k，表示一个字符\n将参数k赋值给变量ch\n返回字符ch的ASCII码值\n"}
{"prompt": "Write a python function to find the sum of even numbers at even positions.", "canonical_solution": "def sum_even_and_even_index(arr,n):  \r\n    i = 0\r\n    sum = 0\r\n    for i in range(0,n,2): \r\n        if (arr[i] % 2 == 0) : \r\n            sum += arr[i]  \r\n    return sum", "task_id": "Python/270", "test_setup": "", "test": ["assert sum_even_and_even_index([5, 6, 12, 1, 18, 8],6) == 30", "assert sum_even_and_even_index([3, 20, 17, 9, 2, 10, 18, 13, 6, 18],10) == 26", "assert sum_even_and_even_index([5, 6, 12, 1],4) == 12"], "challenge_test_list": [], "func_title": "def sum_even_and_even_index(arr,n):  \r", "prompt_text_chinese": "写一个Python函数来求偶数位置的偶数之和。", "code_comment": "定义一个函数sum_even_and_even_index，接收两个参数：arr和n\n参数arr是一个整型数组，n表示这个数组的长度\n循环遍历数组arr中下标为偶数的元素\n如果下标为偶数的元素是偶数，则将其加入sum中\n返回sum的值\n"}
{"prompt": "Write a python function to find the sum of fifth power of first n even natural numbers.", "canonical_solution": "def even_Power_Sum(n): \r\n    sum = 0; \r\n    for i in range(1,n+1): \r\n        j = 2*i; \r\n        sum = sum + (j*j*j*j*j); \r\n    return sum; ", "task_id": "Python/271", "test_setup": "", "test": ["assert even_Power_Sum(2) == 1056", "assert even_Power_Sum(3) == 8832", "assert even_Power_Sum(1) == 32"], "challenge_test_list": [], "func_title": "def even_Power_Sum(n): \r", "prompt_text_chinese": "写一个Python函数来查找前n个偶数自然数的五次方之和。", "code_comment": "定义一个函数even_Power_Sum，接收一个参数n，表示需要计算多少个偶数的五次幂的和\n初始化变量sum的值为0\n循环遍历1到n之间的所有正整数\n将2 * i的值赋值给变量j\n将j的五次幂加入到变量sum中\n返回sum的值\n"}
{"prompt": "Write a function to perfom the rear element extraction from list of tuples records.", "canonical_solution": "def rear_extract(test_list):\r\n  res = [lis[-1] for lis in test_list]\r\n  return (res) ", "task_id": "Python/272", "test_setup": "", "test": ["assert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]", "assert rear_extract([(1, 'Sai', 36), (2, 'Ayesha', 25), (3, 'Salman', 45)]) == [36, 25, 45]", "assert rear_extract([(1, 'Sudeep', 14), (2, 'Vandana', 36), (3, 'Dawood', 56)]) == [14, 36, 56]"], "challenge_test_list": [], "func_title": "def rear_extract(test_list):\r", "prompt_text_chinese": "写一个函数来完成从图元记录列表中提取后置元素。", "code_comment": "定义一个函数rear_extract，接收一个参数test_list，表示一个二维列表\n从二维列表test_list中提取出每个子列表的最后一个元素，组成一个新的列表res\n返回列表res\n"}
{"prompt": "Write a function to substract the contents of one tuple with corresponding index of other tuple.", "canonical_solution": "def substract_elements(test_tup1, test_tup2):\r\n  res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\r\n  return (res) ", "task_id": "Python/273", "test_setup": "", "test": ["assert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)", "assert substract_elements((11, 2, 3), (24, 45 ,16)) == (-13, -43, -13)", "assert substract_elements((7, 18, 9), (10, 11, 12)) == (-3, 7, -3)"], "challenge_test_list": [], "func_title": "def substract_elements(test_tup1, test_tup2):\r", "prompt_text_chinese": "写一个函数，将一个元组的内容与另一个元组的相应索引相减。", "code_comment": "定义一个函数substract_elements，接收两个参数：test_tup1和test_tup2，分别表示两个元组\n使用map函数和lambda表达式对两个元组中的对应元素进行相减计算，得到的结果组成一个新的元组res\n返回元组res\n"}
{"prompt": "Write a python function to find sum of even index binomial coefficients.", "canonical_solution": "import math  \r\ndef even_binomial_Coeff_Sum( n): \r\n    return (1 << (n - 1)) ", "task_id": "Python/274", "test_setup": "", "test": ["assert even_binomial_Coeff_Sum(4) == 8", "assert even_binomial_Coeff_Sum(6) == 32", "assert even_binomial_Coeff_Sum(2) == 2"], "challenge_test_list": [], "func_title": "def even_binomial_Coeff_Sum( n): \r", "prompt_text_chinese": "写一个Python函数来寻找偶数指数的二项式系数之和。", "code_comment": "导入math模块\n定义一个函数even_binomial_Coeff_Sum，接收一个参数n，表示需要计算的二项式系数的和的项数\n计算2的n-1次方，并返回结果\n"}
{"prompt": "Write a python function to find the position of the last removed element from the given array.", "canonical_solution": "import math as mt \r\ndef get_Position(a,n,m): \r\n    for i in range(n): \r\n        a[i] = (a[i] // m + (a[i] % m != 0))  \r\n    result,maxx = -1,-1\r\n    for i in range(n - 1,-1,-1): \r\n        if (maxx < a[i]): \r\n            maxx = a[i] \r\n            result = i \r\n    return result + 1", "task_id": "Python/275", "test_setup": "", "test": ["assert get_Position([2,5,4],3,2) == 2", "assert get_Position([4,3],2,2) == 2", "assert get_Position([1,2,3,4],4,1) == 4"], "challenge_test_list": [], "func_title": "def get_Position(a,n,m): \r", "prompt_text_chinese": "编写一个Python函数，找出从给定数组中删除的最后一个元素的位置。", "code_comment": "导入math模块，并将其别名为mt\n定义一个函数get_Position，接收三个参数：a、n和m\n参数a是一个列表，n和m都表示整型数\n循环遍历列表a，并将每个元素除以m取整再加1\n初始化变量result和maxx的值为-1\n倒序遍历列表a\n如果当前元素的值大于变量maxx的值，则更新maxx和result的值\n返回result的值加1\n"}
{"prompt": "Write a function to find the volume of a cylinder.", "canonical_solution": "def volume_cylinder(r,h):\r\n  volume=3.1415*r*r*h\r\n  return volume", "task_id": "Python/276", "test_setup": "", "test": ["assert volume_cylinder(10,5)==1570.7500000000002", "assert volume_cylinder(4,5)==251.32000000000002", "assert volume_cylinder(4,10)==502.64000000000004"], "challenge_test_list": [], "func_title": "def volume_cylinder(r,h):\r", "prompt_text_chinese": "写一个函数来求一个圆柱体的体积。", "code_comment": "定义一个函数volume_cylinder，接收两个参数：r和h，表示圆柱体的底面半径和高\n根据圆柱体的体积公式计算体积\n返回计算结果\n"}
{"prompt": "Write a function to filter a dictionary based on values.", "canonical_solution": "def dict_filter(dict,n):\r\n result = {key:value for (key, value) in dict.items() if value >=n}\r\n return result", "task_id": "Python/277", "test_setup": "", "test": ["assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},170)=={'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190}", "assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},180)=={ 'Alden Cantrell': 180, 'Pierre Cox': 190}", "assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},190)=={ 'Pierre Cox': 190}"], "challenge_test_list": [], "func_title": "def dict_filter(dict,n):\r", "prompt_text_chinese": "写一个函数，根据数值过滤一个字典。", "code_comment": "定义一个函数dict_filter，接收两个参数：dict和n\n参数dict是一个字典，n表示筛选条件\n使用字典推导式筛选出字典中值大于等于n的键值对，并组成一个新的字典result\n返回新的字典result\n"}
{"prompt": "Write a function to find the element count that occurs before the record in the given tuple.", "canonical_solution": "def count_first_elements(test_tup):\r\n  for count, ele in enumerate(test_tup):\r\n    if isinstance(ele, tuple):\r\n      break\r\n  return (count) ", "task_id": "Python/278", "test_setup": "", "test": ["assert count_first_elements((1, 5, 7, (4, 6), 10) ) == 3", "assert count_first_elements((2, 9, (5, 7), 11) ) == 2", "assert count_first_elements((11, 15, 5, 8, (2, 3), 8) ) == 4"], "challenge_test_list": [], "func_title": "def count_first_elements(test_tup):\r", "prompt_text_chinese": "写一个函数来查找在给定元组中记录前出现的元素数。", "code_comment": "定义一个函数count_first_elements，接收一个参数test_tup，表示一个元组\n使用enumerate函数遍历元组test_tup中的每个元素\n判断当前元素是否为元组\n如果当前元素为元组，则退出循环\n返回当前元素在元组中的下标\n"}
{"prompt": "Write a function to find the nth decagonal number.", "canonical_solution": "def is_num_decagonal(n): \r\n\treturn 4 * n * n - 3 * n ", "task_id": "Python/279", "test_setup": "", "test": ["assert is_num_decagonal(3) == 27", "assert is_num_decagonal(7) == 175", "assert is_num_decagonal(10) == 370"], "challenge_test_list": [], "func_title": "def is_num_decagonal(n): \r", "prompt_text_chinese": "写一个函数来查找第n个十进制数字。", "code_comment": "定义一个函数is_num_decagonal，接收一个参数n，表示需要判断的数\n根据十边形数的计算公式判断n是否为十边形数，如果是，则返回True，否则返回False\n"}
{"prompt": "Write a function to search an element in the given array by using sequential search.", "canonical_solution": "def sequential_search(dlist, item):\r\n    pos = 0\r\n    found = False\r\n    while pos < len(dlist) and not found:\r\n        if dlist[pos] == item:\r\n            found = True\r\n        else:\r\n            pos = pos + 1\r\n    return found, pos", "task_id": "Python/280", "test_setup": "", "test": ["assert sequential_search([11,23,58,31,56,77,43,12,65,19],31) == (True, 3)", "assert sequential_search([12, 32, 45, 62, 35, 47, 44, 61],61) == (True, 7)", "assert sequential_search([9, 10, 17, 19, 22, 39, 48, 56],48) == (True, 6)"], "challenge_test_list": [], "func_title": "def sequential_search(dlist, item):\r", "prompt_text_chinese": "写一个函数，用顺序搜索法在给定的数组中搜索一个元素。", "code_comment": "定义一个函数sequential_search，接收两个参数：dlist和item\n参数dlist是一个列表，item表示需要查找的元素\n初始化变量pos的值为0，found的值为False\n当pos小于列表dlist的长度且found为False时进行循环\n如果列表dlist中下标为pos的元素等于item，则将found的值设为True\n否则将pos的值加1\n返回found和pos的值\n"}
{"prompt": "Write a python function to check if the elements of a given list are unique or not.", "canonical_solution": "def all_unique(test_list):\r\n    if len(test_list) > len(set(test_list)):\r\n        return False\r\n    return True", "task_id": "Python/281", "test_setup": "", "test": ["assert all_unique([1,2,3]) == True", "assert all_unique([1,2,1,2]) == False", "assert all_unique([1,2,3,4,5]) == True"], "challenge_test_list": [], "func_title": "def all_unique(test_list):\r", "prompt_text_chinese": "写一个python函数来检查一个给定列表的元素是否唯一。", "code_comment": "定义一个函数all_unique，接收一个参数test_list，表示一个列表\n如果列表中有重复元素，则返回False\n否则返回True\n"}
{"prompt": "Write a function to substaract two lists using map and lambda function.", "canonical_solution": "def sub_list(nums1,nums2):\r\n  result = map(lambda x, y: x - y, nums1, nums2)\r\n  return list(result)", "task_id": "Python/282", "test_setup": "", "test": ["assert sub_list([1, 2, 3],[4,5,6])==[-3,-3,-3]", "assert sub_list([1,2],[3,4])==[-2,-2]", "assert sub_list([90,120],[50,70])==[40,50]"], "challenge_test_list": [], "func_title": "def sub_list(nums1,nums2):\r", "prompt_text_chinese": "用map和lambda函数写一个函数来替代两个列表。", "code_comment": "定义一个函数sub_list，接收两个参数：nums1和nums2，都是列表\n使用lambda表达式对两个列表中的对应元素进行相减计算，得到的结果组成一个新的迭代器result\n将迭代器转换为列表，然后返回\n"}
{"prompt": "Write a python function to check whether the frequency of each digit is less than or equal to the digit itself.", "canonical_solution": "def validate(n): \r\n    for i in range(10): \r\n        temp = n;  \r\n        count = 0; \r\n        while (temp): \r\n            if (temp % 10 == i): \r\n                count+=1;  \r\n            if (count > i): \r\n                return False\r\n            temp //= 10; \r\n    return True", "task_id": "Python/283", "test_setup": "", "test": ["assert validate(1234) == True", "assert validate(51241) == False", "assert validate(321) == True"], "challenge_test_list": [], "func_title": "def validate(n): \r", "prompt_text_chinese": "写一个python函数来检查每个数字的频率是否小于或等于该数字本身。", "code_comment": "定义一个函数validate，接收一个参数n，表示需要验证的数\n循环遍历0~9的数字\n循环遍历n的每一位数字\n如果当前数字等于i，则将count加1\n如果count大于i，则返回False\n将temp除以10以便计算下一位数字\n如果所有数字的出现次数都小于等于该数字，则返回True\n"}
{"prompt": "Write a function to check whether all items of a list are equal to a given string.", "canonical_solution": "def check_element(list,element):\r\n  check_element=all(v== element for v in list)\r\n  return check_element", "task_id": "Python/284", "test_setup": "", "test": ["assert check_element([\"green\", \"orange\", \"black\", \"white\"],'blue')==False", "assert check_element([1,2,3,4],7)==False", "assert check_element([\"green\", \"green\", \"green\", \"green\"],'green')==True"], "challenge_test_list": [], "func_title": "def check_element(list,element):\r", "prompt_text_chinese": "写一个函数来检查一个列表中的所有项目是否等于一个给定的字符串。", "code_comment": "定义一个函数check_element，接收两个参数：list和element\n参数list是一个列表，element是需要检查的元素\n使用生成器表达式判断列表中的每个元素是否都等于element，得到的结果赋值给变量check_element\n返回check_element的值\n"}
{"prompt": "Write a function that matches a string that has an a followed by two to three 'b'.", "canonical_solution": "import re\r\ndef text_match_two_three(text):\r\n        patterns = 'ab{2,3}'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')", "task_id": "Python/285", "test_setup": "", "test": ["assert text_match_two_three(\"ac\")==('Not matched!')", "assert text_match_two_three(\"dc\")==('Not matched!')", "assert text_match_two_three(\"abbbba\")==('Found a match!')"], "challenge_test_list": [], "func_title": "def text_match_two_three(text):\r", "prompt_text_chinese": "写一个函数，匹配一个有一个a后面有两到三个'b'的字符串。", "code_comment": "导入re模块\n定义一个函数text_match_two_three，接收一个参数text，表示需要匹配的文本字符串\n定义一个匹配模式patterns，表示匹配连续出现2~3个字符a和一个字符b的子串\n使用re.search函数在text中查找是否有符合patterns模式的子串，如果有，则返回'Found a match!'，否则返回'Not matched!'\n"}
{"prompt": "Write a function to find the largest sum of contiguous array in the modified array which is formed by repeating the given array k times.", "canonical_solution": "def max_sub_array_sum_repeated(a, n, k): \r\n\tmax_so_far = -2147483648\r\n\tmax_ending_here = 0\r\n\tfor i in range(n*k): \r\n\t\tmax_ending_here = max_ending_here + a[i%n] \r\n\t\tif (max_so_far < max_ending_here): \r\n\t\t\tmax_so_far = max_ending_here \r\n\t\tif (max_ending_here < 0): \r\n\t\t\tmax_ending_here = 0\r\n\treturn max_so_far", "task_id": "Python/286", "test_setup": "", "test": ["assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30", "assert max_sub_array_sum_repeated([-1, 10, 20], 3, 2) == 59", "assert max_sub_array_sum_repeated([-1, -2, -3], 3, 3) == -1"], "challenge_test_list": [], "func_title": "def max_sub_array_sum_repeated(a, n, k): \r", "prompt_text_chinese": "写一个函数，找出由给定数组重复k次形成的修改数组中连续数组的最大总和。", "code_comment": "定义一个函数max_sub_array_sum_repeated，接收三个参数：a、n和k\n参数a是一个列表，表示需要求最大子数组和的列表\n参数n是一个整数，表示列表a的长度\n参数k是一个整数，表示需要重复a列表k次\n初始化变量max_so_far和max_ending_here的值\n循环遍历nk次\n计算当前连续子数组的和，将结果保存在变量max_ending_here中\n如果当前连续子数组的和max_ending_here大于max_so_far，则将max_so_far更新为max_ending_here\n如果max_ending_here小于0，则将其重置为0\n返回最大子数组的和max_so_far\n"}
{"prompt": "Write a python function to find the sum of squares of first n even natural numbers.", "canonical_solution": "def square_Sum(n):  \r\n    return int(2*n*(n+1)*(2*n+1)/3)", "task_id": "Python/287", "test_setup": "", "test": ["assert square_Sum(2) == 20", "assert square_Sum(3) == 56", "assert square_Sum(4) == 120"], "challenge_test_list": [], "func_title": "def square_Sum(n):  \r", "prompt_text_chinese": "写一个python函数，找出前n个偶数自然数的平方之和。", "code_comment": "定义一个函数square_Sum，接收一个参数n，表示需要计算的范围\n使用数学公式计算1~n的平方和\n"}
{"prompt": "Write a function to count array elements having modular inverse under given prime number p equal to itself.", "canonical_solution": "def modular_inverse(arr, N, P):\r\n\tcurrent_element = 0\r\n\tfor i in range(0, N):\r\n\t\tif ((arr[i] * arr[i]) % P == 1):\r\n\t\t\tcurrent_element = current_element + 1\r\n\treturn current_element", "task_id": "Python/288", "test_setup": "", "test": ["assert modular_inverse([ 1, 6, 4, 5 ], 4, 7) == 2", "assert modular_inverse([1, 3, 8, 12, 12], 5, 13) == 3", "assert modular_inverse([2, 3, 4, 5], 4, 6) == 1"], "challenge_test_list": [], "func_title": "def modular_inverse(arr, N, P):\r", "prompt_text_chinese": "写一个函数来计算在给定的素数p下具有模块逆运算的数组元素是否等于自己。", "code_comment": "定义一个函数modular_inverse，接收三个参数：arr、N和P\n参数arr是一个列表，表示需要计算的数组\n参数N是一个整数，表示列表arr的长度\n参数P是一个整数，表示计算中需要使用的质数\n初始化变量current_element的值为0\n循环遍历列表arr中的每个元素\n如果当前元素的平方模P等于1，则将current_element加1\n返回current_element的值\n"}
{"prompt": "Write a python function to calculate the number of odd days in a given year.", "canonical_solution": "def odd_Days(N): \r\n    hund1 = N // 100\r\n    hund4 = N // 400\r\n    leap = N >> 2\r\n    ordd = N - leap \r\n    if (hund1): \r\n        ordd += hund1 \r\n        leap -= hund1 \r\n    if (hund4): \r\n        ordd -= hund4 \r\n        leap += hund4 \r\n    days = ordd + leap * 2\r\n    odd = days % 7\r\n    return odd ", "task_id": "Python/289", "test_setup": "", "test": ["assert odd_Days(100) == 5", "assert odd_Days(50) ==6", "assert odd_Days(75) == 2"], "challenge_test_list": [], "func_title": "def odd_Days(N): \r", "prompt_text_chinese": "写一个Python函数来计算给定年份中奇数的天数。", "code_comment": "定义一个函数odd_Days，接收一个参数N，表示需要计算的年份\n计算N中以100为间隔的世纪数，将结果保存在变量hund1中\n计算N中以400为间隔的世纪数，将结果保存在变量hund4中\n计算从公元1年到N年中闰年的个数，将结果保存在变量leap中\n计算从公元1年到N年中非闰年的个数，将结果保存在变量ordd中\n如果hund1的值不为0，则将ordd加上hund1，同时将leap减去hund1\n如果hund4的值不为0，则将ordd减去hund4，同时将leap加上hund4\n计算从公元1年到N年中的总天数，将结果保存在变量days中\n计算从公元1年到N年中剩余的天数除以7的余数，将结果保存在变量odd中\n返回odd的值\n"}
{"prompt": "Write a function to find the list of lists with maximum length.", "canonical_solution": "def max_length(list1):\r\n    max_length = max(len(x) for x in  list1 )  \r\n    max_list = max((x) for x in   list1)\r\n    return(max_length, max_list)", "task_id": "Python/290", "test_setup": "", "test": ["assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])", "assert max_length([[1], [5, 7], [10, 12, 14,15]])==(4, [10, 12, 14,15])", "assert max_length([[5], [15,20,25]])==(3, [15,20,25])"], "challenge_test_list": [], "func_title": "def max_length(list1):\r", "prompt_text_chinese": "写一个函数，找出具有最大长度的列表。", "code_comment": "定义一个函数max_length，接收一个参数list1，表示需要处理的列表\n计算列表list1中元素的最大长度，将结果保存在变量max_length中\n找出列表list1中的最大元素，将结果保存在变量max_list中\n返回一个元组，包含max_length和max_list\n"}
{"prompt": "Write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.", "canonical_solution": "def count_no_of_ways(n, k): \r\n\tdp = [0] * (n + 1) \r\n\ttotal = k \r\n\tmod = 1000000007\r\n\tdp[1] = k \r\n\tdp[2] = k * k\t \r\n\tfor i in range(3,n+1): \r\n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \r\n\treturn dp[n]", "task_id": "Python/291", "test_setup": "", "test": ["assert count_no_of_ways(2, 4) == 16", "assert count_no_of_ways(3, 2) == 6", "assert count_no_of_ways(4, 4) == 228"], "challenge_test_list": [], "func_title": "def count_no_of_ways(n, k): \r", "prompt_text_chinese": "写一个函数，找出在给定的有n个柱子和k种颜色的栅栏中，最多只有2个相邻的柱子具有相同的颜色的涂色方法。", "code_comment": "定义一个函数count_no_of_ways，接收两个参数：n和k\n参数n是一个整数，表示需要计算的数的数量\n参数k是一个整数，表示每个数的取值范围\n创建一个长度为n+1的列表dp，将每个元素初始化为0\n初始化变量total的值为k\n初始化变量mod的值为1000000007\n将dp[1]的值初始化为k\n将dp[2]的值初始化为k*k\n循环遍历3~n+1的所有数\n使用动态规划的方法，计算dp[i]的值\n返回dp[n]的值\n"}
{"prompt": "Write a python function to find quotient of two numbers.", "canonical_solution": "def find(n,m):  \r\n    q = n//m \r\n    return (q)", "task_id": "Python/292", "test_setup": "", "test": ["assert find(10,3) == 3", "assert find(4,2) == 2", "assert find(20,5) == 4"], "challenge_test_list": [], "func_title": "def find(n,m):  \r", "prompt_text_chinese": "写一个Python函数来找出两个数字的商。", "code_comment": "定义一个函数find，接收两个参数：n和m\n参数n是一个整数，表示被除数\n参数m是一个整数，表示除数\n计算n除以m的结果，将结果保存在变量q中\n返回q的值\n"}
{"prompt": "Write a function to find the third side of a right angled triangle.", "canonical_solution": "import math\r\ndef otherside_rightangle(w,h):\r\n  s=math.sqrt((w*w)+(h*h))\r\n  return s", "task_id": "Python/293", "test_setup": "", "test": ["assert otherside_rightangle(7,8)==10.63014581273465", "assert otherside_rightangle(3,4)==5", "assert otherside_rightangle(7,15)==16.55294535724685"], "challenge_test_list": [], "func_title": "def otherside_rightangle(w,h):\r", "prompt_text_chinese": "写一个函数来寻找直角三角形的第三边。", "code_comment": "导入math模块\n定义一个函数otherside_rightangle，接收两个参数：w和h\n参数w是一个整数，表示直角三角形的宽度\n参数h是一个整数，表示直角三角形的高度\n使用勾股定理计算斜边的长度，将结果保存在变量s中\n返回s的值\n"}
{"prompt": "Write a function to find the maximum value in a given heterogeneous list.", "canonical_solution": "def max_val(listval):\r\n     max_val = max(i for i in listval if isinstance(i, int)) \r\n     return(max_val)", "task_id": "Python/294", "test_setup": "", "test": ["assert max_val(['Python', 3, 2, 4, 5, 'version'])==5", "assert max_val(['Python', 15, 20, 25])==25", "assert max_val(['Python', 30, 20, 40, 50, 'version'])==50"], "challenge_test_list": [], "func_title": "def max_val(listval):\r", "prompt_text_chinese": "写一个函数，找出给定异质列表中的最大值。", "code_comment": "定义一个函数max_val，接收一个参数listval，表示需要查找最大值的列表\n找出列表listval中所有整数型元素的最大值，并将结果保存在变量max_val中\n返回max_val的值\n"}
{"prompt": "Write a function to return the sum of all divisors of a number.", "canonical_solution": "def sum_div(number):\r\n    divisors = [1]\r\n    for i in range(2, number):\r\n        if (number % i)==0:\r\n            divisors.append(i)\r\n    return sum(divisors)", "task_id": "Python/295", "test_setup": "", "test": ["assert sum_div(8)==7", "assert sum_div(12)==16", "assert sum_div(7)==1"], "challenge_test_list": [], "func_title": "def sum_div(number):\r", "prompt_text_chinese": "写一个函数来返回一个数的所有除数之和。", "code_comment": "定义一个函数sum_div，接收一个参数number，表示需要计算的数\n创建一个列表divisors，将1添加为第一个元素\n循环遍历所有小于number的正整数\n如果number能够被i整除，则将i添加到divisors中\n计算divisors中所有元素的和，并返回结果\n"}
{"prompt": "Write a python function to count inversions in an array.", "canonical_solution": "def get_Inv_Count(arr,n): \r\n    inv_count = 0\r\n    for i in range(n): \r\n        for j in range(i + 1,n): \r\n            if (arr[i] > arr[j]): \r\n                inv_count += 1\r\n    return inv_count ", "task_id": "Python/296", "test_setup": "", "test": ["assert get_Inv_Count([1,20,6,4,5],5) == 5", "assert get_Inv_Count([1,2,1],3) == 1", "assert get_Inv_Count([1,2,5,6,1],5) == 3"], "challenge_test_list": [], "func_title": "def get_Inv_Count(arr,n): \r", "prompt_text_chinese": "写一个Python函数来计算一个数组中的反转数。", "code_comment": "定义一个函数get_Inv_Count，接收两个参数：arr和n\n参数arr是一个列表，表示需要计算逆序对的数列\n参数n是一个整数，表示数列arr的长度\n初始化变量inv_count的值为0，用于计算逆序对的个数\n使用两层循环来计算arr中逆序对的个数\n返回inv_count的值\n"}
{"prompt": "Write a function to flatten a given nested list structure.", "canonical_solution": "def flatten_list(list1):\r\n    result_list = []\r\n    if not list1: return result_list\r\n    stack = [list(list1)]\r\n    while stack:\r\n        c_num = stack.pop()\r\n        next = c_num.pop()\r\n        if c_num: stack.append(c_num)\r\n        if isinstance(next, list):\r\n            if next: stack.append(list(next))\r\n        else: result_list.append(next)\r\n    result_list.reverse()\r\n    return result_list ", "task_id": "Python/297", "test_setup": "", "test": ["assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]", "assert flatten_list([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]])==[10, 20, 40, 30, 56, 25, 10, 20, 33, 40]", "assert flatten_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])==[1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]"], "challenge_test_list": [], "func_title": "def flatten_list(list1):\r", "prompt_text_chinese": "写一个函数来平铺一个给定的嵌套列表结构。", "code_comment": "定义一个函数flatten_list，接收一个参数list1，表示需要展平的列表\n创建一个空列表result_list，用于保存展平后的结果\n如果传入的列表为空，直接返回result_list\n创建一个栈stack，将list1的拷贝添加到栈中\n循环遍历栈stack\n弹出栈顶元素，保存在变量c_num中\n弹出c_num的最后一个元素，保存在变量next中\n如果c_num不为空，则将c_num重新添加到栈中\n如果next是一个列表，则将next添加到栈中\n如果next不是列表，则将next添加到result_list中\n反转result_list，然后返回它\n"}
{"prompt": "Write a function to find the nested list elements which are present in another list.", "canonical_solution": "def intersection_nested_lists(l1, l2):\r\n    result = [[n for n in lst if n in l1] for lst in l2]\r\n    return result", "task_id": "Python/298", "test_setup": "", "test": ["assert intersection_nested_lists( [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],[[12, 18, 23, 25, 45], [7, 11, 19, 24, 28], [1, 5, 8, 18, 15, 16]])==[[12], [7, 11], [1, 5, 8]]", "assert intersection_nested_lists([[2, 3, 1], [4, 5], [6, 8]], [[4, 5], [6, 8]])==[[], []]", "assert intersection_nested_lists(['john','amal','joel','george'],[['john'],['jack','john','mary'],['howard','john'],['jude']])==[['john'], ['john'], ['john'], []]"], "challenge_test_list": [], "func_title": "def intersection_nested_lists(l1, l2):\r", "prompt_text_chinese": "写一个函数来查找存在于另一个列表中的嵌套列表元素。", "code_comment": "定义一个函数intersection_nested_lists，接收两个参数：l1和l2\n参数l1是一个列表，表示需要求交集的列表1\n参数l2是一个嵌套列表，表示需要求交集的列表2，其中每个子列表都需要和l1求交集\n创建一个新列表result，用于保存求得的交集\n对于l2中的每个子列表lst，将其中和l1有交集的元素添加到result列表中\n返回result列表\n"}
{"prompt": "Write a function to calculate the maximum aggregate from the list of tuples.", "canonical_solution": "from collections import defaultdict\r\ndef max_aggregate(stdata):\r\n    temp = defaultdict(int)\r\n    for name, marks in stdata:\r\n        temp[name] += marks\r\n    return max(temp.items(), key=lambda x: x[1])", "task_id": "Python/299", "test_setup": "", "test": ["assert max_aggregate([('Juan Whelan',90),('Sabah Colley',88),('Peter Nichols',7),('Juan Whelan',122),('Sabah Colley',84)])==('Juan Whelan', 212)", "assert max_aggregate([('Juan Whelan',50),('Sabah Colley',48),('Peter Nichols',37),('Juan Whelan',22),('Sabah Colley',14)])==('Juan Whelan', 72)", "assert max_aggregate([('Juan Whelan',10),('Sabah Colley',20),('Peter Nichols',30),('Juan Whelan',40),('Sabah Colley',50)])==('Sabah Colley', 70)"], "challenge_test_list": [], "func_title": "def max_aggregate(stdata):\r", "prompt_text_chinese": "写一个函数，从图元列表中计算出最大集合。", "code_comment": "导入collections模块中的defaultdict类\n定义一个函数max_aggregate，接收一个参数stdata，表示学生的姓名和成绩\n创建一个defaultdict对象temp，用于保存每个学生的总成绩\n遍历stdata中的每个元素\n将学生的成绩累加到temp[name]中\n使用max函数找出temp中成绩最高的学生，返回结果\nmax函数的items方法将temp转换成一个元素为元组的迭代器，\n元组的第一个元素是键，第二个元素是值\nkey参数指定按照字典中的value来比较大小\n"}
{"prompt": "Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.", "canonical_solution": "def count_binary_seq(n): \r\n\tnCr = 1\r\n\tres = 1\r\n\tfor r in range(1, n + 1): \r\n\t\tnCr = (nCr * (n + 1 - r)) / r \r\n\t\tres += nCr * nCr \r\n\treturn res ", "task_id": "Python/300", "test_setup": "", "test": ["assert count_binary_seq(1) == 2.0", "assert count_binary_seq(2) == 6.0", "assert count_binary_seq(3) == 20.0"], "challenge_test_list": [], "func_title": "def count_binary_seq(n): \r", "prompt_text_chinese": "写一个函数，找出所有长度为2n的二进制序列的数量，使前n位之和与后n位之和相同。", "code_comment": "定义一个函数count_binary_seq，接收一个参数n，表示二进制序列的长度\n初始化变量nCr和res的值都为1\n循环遍历1到n\n根据公式计算组合数nCr\n根据公式计算二进制序列的数量，并将结果累加到res中\n返回计算结果res\n"}
{"prompt": "Write a function to find the depth of a dictionary.", "canonical_solution": "def dict_depth(d):\r\n    if isinstance(d, dict):\r\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\r\n    return 0", "task_id": "Python/301", "test_setup": "", "test": ["assert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4", "assert dict_depth({'a':1, 'b': {'c':'python'}})==2", "assert dict_depth({1: 'Sun', 2: {3: {4:'Mon'}}})==3"], "challenge_test_list": [], "func_title": "def dict_depth(d):\r", "prompt_text_chinese": "写一个函数来查找字典的深度。", "code_comment": "定义一个函数dict_depth，接收一个参数d，表示需要求深度的字典\n如果d是一个字典，则计算d的深度\n如果d不为空，则计算d中各个值的深度的最大值，并返回1加上该最大值\n如果d为空，则返回0\n如果d不是一个字典，则返回0\n"}
{"prompt": "Write a python function to find the most significant bit number which is also a set bit.", "canonical_solution": "def set_Bit_Number(n): \r\n    if (n == 0): \r\n        return 0; \r\n    msb = 0; \r\n    n = int(n / 2); \r\n    while (n > 0): \r\n        n = int(n / 2); \r\n        msb += 1; \r\n    return (1 << msb)", "task_id": "Python/302", "test_setup": "", "test": ["assert set_Bit_Number(6) == 4", "assert set_Bit_Number(10) == 8", "assert set_Bit_Number(18) == 16"], "challenge_test_list": [], "func_title": "def set_Bit_Number(n): \r", "prompt_text_chinese": "写一个Python函数来寻找最重要的位数，它也是一个被设定的位数。", "code_comment": "定义一个函数set_Bit_Number，接收一个参数n，表示需要计算的数\n如果n等于0，则返回0\n初始化变量msb的值为0\n将n除以2，得到商，并将n赋值为商\n循环计算n的最高有效位的位置msb\n返回2的msb次幂\n"}
{"prompt": "Write a python function to check whether the count of inversion of two types are same or not.", "canonical_solution": "import sys \r\ndef solve(a,n):   \r\n    mx = -sys.maxsize - 1\r\n    for j in range(1,n):  \r\n        if (mx > a[j]):  \r\n            return False  \r\n        mx = max(mx,a[j - 1])    \r\n    return True", "task_id": "Python/303", "test_setup": "", "test": ["assert solve([1,0,2],3) == True", "assert solve([1,2,0],3) == False", "assert solve([1,2,1],3) == True"], "challenge_test_list": [], "func_title": "def solve(a,n):   \r", "prompt_text_chinese": "写一个python函数来检查两种类型的反转数是否相同。", "code_comment": "导入sys模块\n定义一个函数solve，接收两个参数a和n\n参数a是一个列表，表示需要判断的序列\n参数n是一个整数，表示序列的长度\n初始化变量mx为系统整型最小值\n循环遍历1到n-1\n如果mx大于a[j]，则返回False\n将mx更新为a[j-1]和mx中的较大值\n如果循环结束仍未返回False，则返回True\n"}
{"prompt": "Write a python function to find element at a given index after number of rotations.", "canonical_solution": "def find_Element(arr,ranges,rotations,index) :  \r\n    for i in range(rotations - 1,-1,-1 ) : \r\n        left = ranges[i][0] \r\n        right = ranges[i][1] \r\n        if (left <= index and right >= index) : \r\n            if (index == left) : \r\n                index = right \r\n            else : \r\n                index = index - 1 \r\n    return arr[index] ", "task_id": "Python/304", "test_setup": "", "test": ["assert find_Element([1,2,3,4,5],[[0,2],[0,3]],2,1) == 3", "assert find_Element([1,2,3,4],[[0,1],[0,2]],1,2) == 3", "assert find_Element([1,2,3,4,5,6],[[0,1],[0,2]],1,1) == 1"], "challenge_test_list": [], "func_title": "def find_Element(arr,ranges,rotations,index) :  \r", "prompt_text_chinese": "写一个Python函数，在给定的索引上找到经过旋转次数的元素。", "code_comment": "定义一个函数find_Element，接收4个参数arr、ranges、rotations和index\n参数arr是一个列表，表示需要查找的数组\n参数ranges是一个嵌套列表，表示每一轮旋转操作的范围\n参数rotations是一个整数，表示旋转的轮数\n参数index是一个整数，表示需要查找的元素的下标\n循环遍历rotations-1到0，进行逆序的旋转操作\n获取当前轮的旋转范围\n如果需要查找的元素在当前旋转范围内，则进行对应的下标变换\n返回arr中下标为index的元素\n"}
{"prompt": "Write a function to match two words from a list of words starting with letter 'p'.", "canonical_solution": "import re\r\ndef start_withp(words):\r\n for w in words:\r\n        m = re.match(\"(P\\w+)\\W(P\\w+)\", w)\r\n        if m:\r\n            return m.groups()", "task_id": "Python/305", "test_setup": "", "test": ["assert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"])==('Python', 'PHP')", "assert start_withp([\"Python Programming\",\"Java Programming\"])==('Python','Programming')", "assert start_withp([\"Pqrst Pqr\",\"qrstuv\"])==('Pqrst','Pqr')"], "challenge_test_list": [], "func_title": "def start_withp(words):\r", "prompt_text_chinese": "写一个函数，从一个以字母 \"p \"开头的单词列表中匹配两个单词。", "code_comment": "导入re模块\n定义一个函数start_withp，接收一个参数words，表示需要匹配的单词列表\n遍历words中的每个单词\n使用正则表达式匹配以P开头的单词，并返回第一个匹配结果的两个词\n"}
{"prompt": "Write a function to find the maximum sum of increasing subsequence from prefix till ith index and also including a given kth element which is after i, i.e., k > i .", "canonical_solution": "def max_sum_increasing_subseq(a, n, index, k):\r\n\tdp = [[0 for i in range(n)] \r\n\t\t\tfor i in range(n)]\r\n\tfor i in range(n):\r\n\t\tif a[i] > a[0]:\r\n\t\t\tdp[0][i] = a[i] + a[0]\r\n\t\telse:\r\n\t\t\tdp[0][i] = a[i]\r\n\tfor i in range(1, n):\r\n\t\tfor j in range(n):\r\n\t\t\tif a[j] > a[i] and j > i:\r\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\r\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\r\n\t\t\t\telse:\r\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\r\n\t\t\telse:\r\n\t\t\t\tdp[i][j] = dp[i - 1][j]\r\n\treturn dp[index][k]", "task_id": "Python/306", "test_setup": "", "test": ["assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11", "assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 2, 5) == 7", "assert max_sum_increasing_subseq([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71"], "challenge_test_list": [], "func_title": "def max_sum_increasing_subseq(a, n, index, k):\r", "prompt_text_chinese": "写一个函数，找出从前缀到第i个索引的递增子序列的最大和，同时包括给定的第i个元素，即k>i。", "code_comment": "定义一个函数max_sum_increasing_subseq，接收四个参数a、n、index和k\n参数a是一个列表，表示需要查找的序列\n参数n是一个整数，表示序列的长度\n参数index是一个整数，表示查找的结果中的第一个数在原序列中的下标\n参数k是一个整数，表示查找的结果中的第二个数在原序列中的下标\n初始化dp二维列表的值为0\n计算dp[0]的值\n计算dp[i][j]的值，其中i从1到n-1，j从0到n-1\n如果a[j]大于a[i]并且j>i，则有两种选择：\n1. 将a[j]加入dp[i-1][i]中，成为dp[i][j]\n2. 不将a[j]加入dp[i-1][i]中，继承dp[i-1][j]的值成为dp[i][j]\n如果a[j]小于等于a[i]或j<=i，则直接继承dp[i-1][j]的值成为dp[i][j]\n返回dp[index][k]\n"}
{"prompt": "Write a function to get a colon of a tuple.", "canonical_solution": "from copy import deepcopy\r\ndef colon_tuplex(tuplex,m,n):\r\n  tuplex_colon = deepcopy(tuplex)\r\n  tuplex_colon[m].append(n)\r\n  return tuplex_colon", "task_id": "Python/307", "test_setup": "", "test": ["assert colon_tuplex((\"HELLO\", 5, [], True) ,2,50)==(\"HELLO\", 5, [50], True) ", "assert colon_tuplex((\"HELLO\", 5, [], True) ,2,100)==((\"HELLO\", 5, [100],True))", "assert colon_tuplex((\"HELLO\", 5, [], True) ,2,500)==(\"HELLO\", 5, [500], True)"], "challenge_test_list": [], "func_title": "def colon_tuplex(tuplex,m,n):\r", "prompt_text_chinese": "写一个函数来获取一个元组的冒号。", "code_comment": "导入copy模块中的deepcopy函数\n定义一个函数colon_tuplex，接收三个参数tuplex、m和n\n参数tuplex是一个元组，表示需要添加元素的元组\n参数m和n是两个整数，表示需要添加元素的位置和元素值\n使用deepcopy函数创建tuplex的副本\n在tuplex_colon的第m个位置添加元素n\n返回添加元素后的tuplex_colon\n"}
{"prompt": "Write a function to find the specified number of largest products from two given lists.", "canonical_solution": "def large_product(nums1, nums2, N):\r\n    result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]\r\n    return result", "task_id": "Python/308", "test_setup": "", "test": ["assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)==[60, 54, 50]", "assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],4)==[60, 54, 50, 48]", "assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],5)==[60, 54, 50, 48, 45]"], "challenge_test_list": [], "func_title": "def large_product(nums1, nums2, N):\r", "prompt_text_chinese": "写一个函数，从两个给定的列表中找出指定数量的最大产品。", "code_comment": "定义一个函数large_product，接收三个参数nums1、nums2和N\n参数nums1和nums2分别是两个列表，表示需要计算乘积的两个数集\n参数N是一个整数，指定需要返回的乘积结果的个数\n计算nums1和nums2的笛卡尔积，并计算得到乘积列表，并按照降序排序\n返回乘积列表的前N个元素\n"}
{"prompt": "Write a python function to find the maximum of two numbers.", "canonical_solution": "def maximum(a,b):   \r\n    if a >= b: \r\n        return a \r\n    else: \r\n        return b ", "task_id": "Python/309", "test_setup": "", "test": ["assert maximum(5,10) == 10", "assert maximum(-1,-2) == -1", "assert maximum(9,7) == 9"], "challenge_test_list": [], "func_title": "def maximum(a,b):   \r", "prompt_text_chinese": "写一个Python函数来寻找两个数字的最大值。", "code_comment": "定义一个函数maximum，接收两个参数a和b，表示需要比较大小的两个数\n如果a大于等于b，则返回a\n如果a小于b，则返回b\n"}
{"prompt": "Write a function to convert a given string to a tuple.", "canonical_solution": "def string_to_tuple(str1):\r\n    result = tuple(x for x in str1 if not x.isspace()) \r\n    return result", "task_id": "Python/310", "test_setup": "", "test": ["assert string_to_tuple(\"python 3.0\")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')", "assert string_to_tuple(\"item1\")==('i', 't', 'e', 'm', '1')", "assert string_to_tuple(\"15.10\")==('1', '5', '.', '1', '0')"], "challenge_test_list": [], "func_title": "def string_to_tuple(str1):\r", "prompt_text_chinese": "写一个函数，将给定的字符串转换为元组。", "code_comment": "定义一个函数string_to_tuple，接收一个参数str1，表示需要转换为元组的字符串\n使用列表解析将字符串中除空格以外的字符转换成元组的元素\n返回转换后的元组\n"}
{"prompt": "Write a python function to set the left most unset bit.", "canonical_solution": "def set_left_most_unset_bit(n): \r\n    if not (n & (n + 1)): \r\n        return n \r\n    pos, temp, count = 0, n, 0 \r\n    while temp: \r\n        if not (temp & 1): \r\n            pos = count      \r\n        count += 1; temp>>=1\r\n    return (n | (1 << (pos))) ", "task_id": "Python/311", "test_setup": "", "test": ["assert set_left_most_unset_bit(10) == 14", "assert set_left_most_unset_bit(12) == 14", "assert set_left_most_unset_bit(15) == 15"], "challenge_test_list": [], "func_title": "def set_left_most_unset_bit(n): \r", "prompt_text_chinese": "写一个Python函数来设置最左边的未设置位。", "code_comment": "如果n+1与n按位与的结果为0，则n为形如2^n-1的数，则返回n本身\n否则，找到n从左到右第一个为0的二进制位，将该位设为1，然后返回结果\n"}
{"prompt": "Write a function to find the volume of a cone.", "canonical_solution": "import math\r\ndef volume_cone(r,h):\r\n  volume = (1.0/3) * math.pi * r * r * h\r\n  return volume", "task_id": "Python/312", "test_setup": "", "test": ["assert volume_cone(5,12)==314.15926535897927", "assert volume_cone(10,15)==1570.7963267948965", "assert volume_cone(19,17)==6426.651371693521"], "challenge_test_list": [], "func_title": "def volume_cone(r,h):\r", "prompt_text_chinese": "写一个函数来求一个圆锥体的体积。", "code_comment": "导入math模块\n定义一个函数volume_cone，接收两个参数r和h，表示圆锥的底面半径和高\n计算圆锥的体积\n返回计算结果\n"}
{"prompt": "Write a python function to print positive numbers in a list.", "canonical_solution": "def pos_nos(list1):\r\n  for num in list1: \r\n    if num >= 0: \r\n       return num ", "task_id": "Python/313", "test_setup": "", "test": ["assert pos_nos([-1,-2,1,2]) == 1,2", "assert pos_nos([3,4,-5]) == 3,4", "assert pos_nos([-2,-3,1]) == 1"], "challenge_test_list": [], "func_title": "def pos_nos(list1):\r", "prompt_text_chinese": "写一个Python函数来打印一个列表中的正数。", "code_comment": "遍历list1中的每个元素num\n如果num大于等于0，则返回num\n"}
{"prompt": "Write a function to find out the maximum sum such that no two chosen numbers are adjacent for the given rectangular grid of dimension 2 x n.", "canonical_solution": "def max_sum_rectangular_grid(grid, n) : \r\n\tincl = max(grid[0][0], grid[1][0]) \r\n\texcl = 0\r\n\tfor i in range(1, n) : \r\n\t\texcl_new = max(excl, incl) \r\n\t\tincl = excl + max(grid[0][i], grid[1][i]) \r\n\t\texcl = excl_new \r\n\treturn max(excl, incl)", "task_id": "Python/314", "test_setup": "", "test": ["assert max_sum_rectangular_grid([ [1, 4, 5], [2, 0, 0 ] ], 3) == 7", "assert max_sum_rectangular_grid([ [ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10] ], 5) == 24", "assert max_sum_rectangular_grid([ [7, 9, 11, 15, 19], [21, 25, 28, 31, 32] ], 5) == 81"], "challenge_test_list": [], "func_title": "def max_sum_rectangular_grid(grid, n) : \r", "prompt_text_chinese": "写一个函数，找出在给定的尺寸为2 x n的矩形网格中，没有两个选定的数字相邻的最大和。", "code_comment": "定义一个函数max_sum_rectangular_grid，接收两个参数grid和n\n参数grid是一个二维列表，表示需要查找的矩形网格\n参数n是一个整数，表示矩形网格的列数\n初始化incl和excl的值\n遍历网格的列，计算incl和excl的值\n计算不包括当前列的最大和\n计算包括当前列的最大和\n更新excl\n返回incl和excl中的最大值\n"}
{"prompt": "Write a python function to find the first maximum length of even word.", "canonical_solution": "def find_Max_Len_Even(str): \r\n    n = len(str) \r\n    i = 0\r\n    currlen = 0\r\n    maxlen = 0\r\n    st = -1\r\n    while (i < n): \r\n        if (str[i] == ' '): \r\n            if (currlen % 2 == 0): \r\n                if (maxlen < currlen): \r\n                    maxlen = currlen \r\n                    st = i - currlen \r\n            currlen = 0 \r\n        else : \r\n            currlen += 1\r\n        i += 1\r\n    if (currlen % 2 == 0): \r\n        if (maxlen < currlen): \r\n            maxlen = currlen \r\n            st = i - currlen \r\n    if (st == -1): \r\n        return \"-1\" \r\n    return str[st: st + maxlen] ", "task_id": "Python/315", "test_setup": "", "test": ["assert find_Max_Len_Even(\"python language\") == \"language\"", "assert find_Max_Len_Even(\"maximum even length\") == \"length\"", "assert find_Max_Len_Even(\"eve\") == \"-1\""], "challenge_test_list": [], "func_title": "def find_Max_Len_Even(str): \r", "prompt_text_chinese": "写一个python函数，找出偶数字的第一个最大长度。", "code_comment": "定义一个函数find_Max_Len_Even，接收一个参数str，表示需要查找偶数长度的最长子串的字符串\n计算字符串的长度\n初始化i\n初始化currlen\n初始化maxlen\n初始化st\n遍历字符串中的每个字符\n如果当前字符为空格，则需要重新计算currlen\n如果currlen是偶数，则更新maxlen和st的值\n重置currlen\n更新currlen\n更新i\n如果最后一个单词的长度是偶数，则更新maxlen和st的值\n如果st仍为-1，则返回-1\n返回偶数长度的最长子串\n"}
{"prompt": "Write a function to find the index of the last occurrence of a given number in a sorted array.", "canonical_solution": "def find_last_occurrence(A, x):\r\n    (left, right) = (0, len(A) - 1)\r\n    result = -1\r\n    while left <= right:\r\n        mid = (left + right) // 2\r\n        if x == A[mid]:\r\n            result = mid\r\n            left = mid + 1\r\n        elif x < A[mid]:\r\n            right = mid - 1\r\n        else:\r\n            left = mid + 1\r\n    return result ", "task_id": "Python/316", "test_setup": "", "test": ["assert find_last_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 3", "assert find_last_occurrence([2, 3, 5, 8, 6, 6, 8, 9, 9, 9], 9) == 9", "assert find_last_occurrence([2, 2, 1, 5, 6, 6, 6, 9, 9, 9], 6) == 6"], "challenge_test_list": [], "func_title": "def find_last_occurrence(A, x):\r", "prompt_text_chinese": "写一个函数来寻找一个排序数组中最后出现的数字的索引。", "code_comment": "定义一个函数find_last_occurrence，接收两个参数A和x\n参数A是一个升序排列的列表，表示需要查找的数列\n参数x是一个整数，表示需要查找的数\n初始化left和right的值\n初始化result的值\n使用二分查找法查找x在A中的最后一次出现的位置\n计算中间位置\n如果x等于A[mid]，则更新result的值，并在A[mid+1:]中继续查找\n如果x小于A[mid]，则在A[:mid]中继续查找\n如果x大于A[mid]，则在A[mid+1:]中继续查找\n返回结果\n"}
{"prompt": "Write a function to reflect the modified run-length encoding from a list.", "canonical_solution": "from itertools import groupby\r\ndef modified_encode(alist):\r\n        def ctr_ele(el):\r\n            if len(el)>1: return [len(el), el[0]]\r\n            else: return el[0]\r\n        return [ctr_ele(list(group)) for key, group in groupby(alist)]", "task_id": "Python/317", "test_setup": "", "test": ["assert modified_encode([1,1,2,3,4,4,5,1])==[[2, 1], 2, 3, [2, 4], 5, 1]", "assert modified_encode('automatically')==['a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'a', [2, 'l'], 'y']", "assert modified_encode('python')==['p', 'y', 't', 'h', 'o', 'n']"], "challenge_test_list": [], "func_title": "def modified_encode(alist):\r", "prompt_text_chinese": "写一个函数，从一个列表中反映修改后的运行长度编码。", "code_comment": "导入itertools模块中的groupby函数\n定义一个函数modified_encode，接收一个参数alist，表示需要进行编码处理的列表\n定义一个嵌套函数ctr_ele，用于处理列表中的元素\n如果元素重复出现了，则返回一个包含元素出现次数和元素本身的列表\n否则，返回元素本身\n对alist中的元素进行编码处理\n"}
{"prompt": "Write a python function to find the maximum volume of a cuboid with given sum of sides.", "canonical_solution": "def max_volume (s): \r\n    maxvalue = 0\r\n    i = 1\r\n    for i in range(s - 1): \r\n        j = 1\r\n        for j in range(s): \r\n            k = s - i - j \r\n            maxvalue = max(maxvalue, i * j * k)         \r\n    return maxvalue ", "task_id": "Python/318", "test_setup": "", "test": ["assert max_volume(8) == 18", "assert max_volume(4) == 2", "assert max_volume(1) == 0"], "challenge_test_list": [], "func_title": "def max_volume (s): \r", "prompt_text_chinese": "写一个Python函数，找出给定边数的长方体的最大体积。", "code_comment": "定义一个函数max_volume，接收一个参数s，表示正方体的边长\n初始化maxvalue的值\n初始化i的值\n遍历正方体的三条边，计算体积的最大值\n初始化j的值\n根据正方体的三条边计算第三条边的长度k\n计算体积的最大值\n返回计算结果\n"}
{"prompt": "Write a function to find all five characters long word in the given string by using regex.", "canonical_solution": "import re\r\ndef find_long_word(text):\r\n  return (re.findall(r\"\\b\\w{5}\\b\", text))", "task_id": "Python/319", "test_setup": "", "test": ["assert find_long_word('Please move back to strem') == ['strem']", "assert find_long_word('4K Ultra HD streaming player') == ['Ultra']", "assert find_long_word('Streaming Media Player') == ['Media']"], "challenge_test_list": [], "func_title": "def find_long_word(text):\r", "prompt_text_chinese": "写一个函数，通过使用regex在给定的字符串中找到所有五个字符的长词。", "code_comment": "导入re模块\n定义一个函数find_long_word，接收一个参数text，表示需要查找的文本字符串\n使用正则表达式查找长度为5的单词并返回结果\n"}
{"prompt": "Write a function to calculate the difference between the squared sum of first n natural numbers and the sum of squared first n natural numbers.", "canonical_solution": "def sum_difference(n):\r\n    sumofsquares = 0\r\n    squareofsum = 0\r\n    for num in range(1, n+1):\r\n        sumofsquares += num * num\r\n        squareofsum += num\r\n    squareofsum = squareofsum ** 2\r\n    return squareofsum - sumofsquares", "task_id": "Python/320", "test_setup": "", "test": ["assert sum_difference(12)==5434", "assert sum_difference(20)==41230", "assert sum_difference(54)==2151270"], "challenge_test_list": [], "func_title": "def sum_difference(n):\r", "prompt_text_chinese": "写一个函数来计算前n个自然数的平方和与前n个自然数的平方和之间的差。", "code_comment": "定义一个函数sum_difference，接收一个参数n，表示自然数的范围\n初始化平方和\n初始化和的平方\n遍历1到n之间的每一个自然数\n累加每个自然数的平方\n累加每个自然数\n计算和的平方\n计算和的平方与平方和之间的差值并返回结果\n"}
{"prompt": "Write a function to find the demlo number for the given number.", "canonical_solution": "def find_demlo(s): \r\n\tl = len(s) \r\n\tres = \"\" \r\n\tfor i in range(1,l+1): \r\n\t\tres = res + str(i) \r\n\tfor i in range(l-1,0,-1): \r\n\t\tres = res + str(i) \r\n\treturn res \t", "task_id": "Python/321", "test_setup": "", "test": ["assert find_demlo(\"111111\") == '12345654321'", "assert find_demlo(\"1111\") == '1234321'", "assert find_demlo(\"13333122222\") == '123456789101110987654321'"], "challenge_test_list": [], "func_title": "def find_demlo(s): \r", "prompt_text_chinese": "写一个函数来寻找给定数的demlo数。", "code_comment": "定义一个函数find_demlo，接收一个参数s，表示需要进行处理的字符串\n计算字符串的长度\n初始化结果字符串\n生成一个1到l的序列，并将序列中的数转换成字符串拼接到结果字符串的末尾\n生成一个l-1到1的序列，并将序列中的数转换成字符串拼接到结果字符串的末尾\n返回结果字符串\n"}
{"prompt": "Write a function to find all index positions of the minimum values in a given list.", "canonical_solution": "def position_min(list1):\r\n    min_val = min(list1)\r\n    min_result = [i for i, j in enumerate(list1) if j == min_val]\r\n    return min_result", "task_id": "Python/322", "test_setup": "", "test": ["assert position_min([12,33,23,10,67,89,45,667,23,12,11,10,54])==[3,11]", "assert position_min([1,2,2,2,4,4,4,5,5,5,5])==[0]", "assert position_min([2,1,5,6,8,3,4,9,10,11,8,12])==[1]"], "challenge_test_list": [], "func_title": "def position_min(list1):\r", "prompt_text_chinese": "写一个函数来查找给定列表中最小值的所有索引位置。", "code_comment": "定义一个函数名为position_min\n函数有一个参数list1，表示一个列表\n获得列表中最小的元素值\n使用列表推导式获得所有最小元素值的索引\n返回所有最小元素值的索引\n"}
{"prompt": "Write a function to re-arrange the given array in alternating positive and negative items.", "canonical_solution": "def right_rotate(arr, n, out_of_place, cur):\r\n\ttemp = arr[cur]\r\n\tfor i in range(cur, out_of_place, -1):\r\n\t\tarr[i] = arr[i - 1]\r\n\tarr[out_of_place] = temp\r\n\treturn arr\r\ndef re_arrange(arr, n):\r\n\tout_of_place = -1\r\n\tfor index in range(n):\r\n\t\tif (out_of_place >= 0):\r\n\t\t\tif ((arr[index] >= 0 and arr[out_of_place] < 0) or\r\n\t\t\t(arr[index] < 0 and arr[out_of_place] >= 0)):\r\n\t\t\t\tarr = right_rotate(arr, n, out_of_place, index)\r\n\t\t\t\tif (index-out_of_place > 2):\r\n\t\t\t\t\tout_of_place += 2\r\n\t\t\t\telse:\r\n\t\t\t\t\tout_of_place = - 1\r\n\t\tif (out_of_place == -1):\r\n\t\t\tif ((arr[index] >= 0 and index % 2 == 0) or\r\n\t\t\t (arr[index] < 0 and index % 2 == 1)):\r\n\t\t\t\tout_of_place = index\r\n\treturn arr", "task_id": "Python/323", "test_setup": "", "test": ["assert re_arrange([-5, -2, 5, 2, 4,\t7, 1, 8, 0, -8], 10) == [-5, 5, -2, 2, -8, 4, 7, 1, 8, 0]", "assert re_arrange([1, 2, 3, -4, -1, 4], 6) == [-4, 1, -1, 2, 3, 4]", "assert re_arrange([4, 7, 9, 77, -4, 5, -3, -9], 8) == [-4, 4, -3, 7, -9, 9, 77, 5]"], "challenge_test_list": [], "func_title": "def right_rotate(arr, n, out_of_place, cur):\r", "prompt_text_chinese": "写一个函数来重新排列给定的数组中交替出现的正项和负项。", "code_comment": "定义一个名为right_rotate的函数\n函数有四个参数，分别是arr、n、out_of_place、cur，其中：\narr表示一个列表，n表示列表的长度，out_of_place表示不合法的索引位置，cur表示当前索引位置\n保存当前索引位置的值\n将out_of_place到cur-1位置的元素都向右移动一位\n将原来保存的值赋值给out_of_place位置\n返回修改后的列表arr\n定义一个名为re_arrange的函数\n函数有两个参数，分别是arr、n，其中：\narr表示一个列表，n表示列表的长度\n初始化一个不合法的索引位置out_of_place为-1\n遍历列表中的每一个元素\n如果out_of_place位置是不合法的\n如果当前元素和out_of_place位置的元素符号不同\n调用right_rotate函数将out_of_place到index位置的元素旋转\n如果旋转的距离超过两个元素，则out_of_place需要向右移动两个位置\n否则将out_of_place重置为-1\n如果out_of_place位置是合法的\n如果当前元素和索引位置的奇偶性相同\n将out_of_place设置为当前索引位置\n返回修改后的列表arr\n"}
{"prompt": "Write a function to extract the sum of alternate chains of tuples.", "canonical_solution": "def sum_of_alternates(test_tuple):\r\n  sum1 = 0\r\n  sum2 = 0\r\n  for idx, ele in enumerate(test_tuple):\r\n    if idx % 2:\r\n      sum1 += ele\r\n    else:\r\n      sum2 += ele\r\n  return ((sum1),(sum2)) ", "task_id": "Python/324", "test_setup": "", "test": ["assert sum_of_alternates((5, 6, 3, 6, 10, 34)) == (46, 18)", "assert sum_of_alternates((1, 2, 3, 4, 5)) == (6, 9)", "assert sum_of_alternates((6, 7, 8, 9, 4, 5)) == (21, 18)"], "challenge_test_list": [], "func_title": "def sum_of_alternates(test_tuple):\r", "prompt_text_chinese": "写一个函数来提取图元的交替链之和。", "code_comment": "定义一个名为sum_of_alternates的函数\n函数有一个参数test_tuple，表示一个元组\n初始化两个和为0\n遍历元组中的每一个元素和对应的索引\n如果索引是奇数，则将元素加到sum1中\n如果索引是偶数，则将元素加到sum2中\n返回一个元组，元组第一个元素为sum1，第二个元素为sum2\n"}
{"prompt": "Write a python function to find the minimum number of squares whose sum is equal to a given number.", "canonical_solution": "def get_Min_Squares(n):\r\n    if n <= 3:\r\n        return n;\r\n    res = n \r\n    for x in range(1,n + 1):\r\n        temp = x * x;\r\n        if temp > n:\r\n            break\r\n        else:\r\n            res = min(res,1 + get_Min_Squares(n  - temp)) \r\n    return res;", "task_id": "Python/325", "test_setup": "", "test": ["assert get_Min_Squares(6) == 3", "assert get_Min_Squares(2) == 2", "assert get_Min_Squares(4) == 1"], "challenge_test_list": [], "func_title": "def get_Min_Squares(n):\r", "prompt_text_chinese": "写一个Python函数，找出和等于给定数的最小方块数。", "code_comment": "定义一个名为get_Min_Squares的函数\n函数有一个参数n，表示一个正整数\n如果n小于等于3，则返回n本身\n初始化res为n\n遍历1到n之间的所有正整数x\n计算x的平方\n如果x的平方大于n，则跳出循环\n否则计算1 + get_Min_Squares(n - temp)的最小值并赋值给res\n返回res\n"}
{"prompt": "Write a function to get the word with most number of occurrences in the given strings list.", "canonical_solution": "from collections import defaultdict \r\n\r\ndef most_occurrences(test_list):\r\n  temp = defaultdict(int)\r\n  for sub in test_list:\r\n    for wrd in sub.split():\r\n      temp[wrd] += 1\r\n  res = max(temp, key=temp.get)\r\n  return (str(res)) ", "task_id": "Python/326", "test_setup": "", "test": ["assert most_occurrences([\"UTS is best for RTF\", \"RTF love UTS\", \"UTS is best\"] ) == 'UTS'", "assert most_occurrences([\"Its been a great year\", \"this year is so worse\", \"this year is okay\"] ) == 'year'", "assert most_occurrences([\"Families can be reunited\", \"people can be reunited\", \"Tasks can be achieved \"] ) == 'can'"], "challenge_test_list": [], "func_title": "def most_occurrences(test_list):\r", "prompt_text_chinese": "写一个函数来获取在给定的字符串列表中出现次数最多的词。", "code_comment": "导入collections模块中的defaultdict类\n定义一个名为most_occurrences的函数\n函数有一个参数test_list，表示一个列表，其中每个元素是由空格分隔的字符串\n初始化一个defaultdict对象temp，每个键的默认值都是0\n遍历test_list中的每一个元素sub\n将sub分割成一个个单词，遍历每个单词wrd\n将temp[wrd]的值加1\n获取temp中值最大的键，并赋值给res\n将res转换成字符串并返回\n"}
{"prompt": "Write a function to print check if the triangle is isosceles or not.", "canonical_solution": "def check_isosceles(x,y,z):\r\n  if x==y or y==z or z==x:\r\n\t   return True\r\n  else:\r\n     return False", "task_id": "Python/327", "test_setup": "", "test": ["assert check_isosceles(6,8,12)==False ", "assert check_isosceles(6,6,12)==True", "assert check_isosceles(6,16,20)==False"], "challenge_test_list": [], "func_title": "def check_isosceles(x,y,z):\r", "prompt_text_chinese": "写一个函数来打印检查三角形是否是等腰三角形。", "code_comment": "定义一个名为check_isosceles的函数\n函数有三个参数x、y、z，分别表示三角形的三条边长\n如果x、y、z中有任意两个数值相等\n则返回True\n否则返回False\n"}
{"prompt": "Write a function to rotate a given list by specified number of items to the left direction.", "canonical_solution": "def rotate_left(list1,m,n):\r\n  result =  list1[m:]+list1[:n]\r\n  return result", "task_id": "Python/328", "test_setup": "", "test": ["assert rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],3,4)==[4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4]", "assert rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],2,2)==[3, 4, 5, 6, 7, 8, 9, 10, 1, 2]", "assert rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],5,2)==[6, 7, 8, 9, 10, 1, 2]"], "challenge_test_list": [], "func_title": "def rotate_left(list1,m,n):\r", "prompt_text_chinese": "编写一个函数，将给定的列表向左旋转指定数量的项目。", "code_comment": "定义一个名为rotate_left的函数\n函数有三个参数，分别是list1、m、n，其中：\nlist1表示一个列表\nm表示旋转开始的位置，n表示旋转结束的位置\n将列表从m位置分割成两个部分，其中前一部分为m到末尾，后一部分为开始到n\n然后将这两部分拼接起来，得到旋转后的结果\n返回旋转后的结果\n"}
{"prompt": "Write a python function to count negative numbers in a list.", "canonical_solution": "def neg_count(list):\r\n  neg_count= 0\r\n  for num in list: \r\n    if num <= 0: \r\n      neg_count += 1\r\n  return neg_count ", "task_id": "Python/329", "test_setup": "", "test": ["assert neg_count([-1,-2,3,-4,-5]) == 4", "assert neg_count([1,2,3]) == 0", "assert neg_count([1,2,-3,-10,20]) == 2"], "challenge_test_list": [], "func_title": "def neg_count(list):\r", "prompt_text_chinese": "写一个Python函数来计算一个列表中的负数。", "code_comment": "定义一个名为neg_count的函数\n函数有一个参数list，表示一个列表\n初始化负数计数器neg_count为0\n遍历列表中的每一个元素num\n如果num小于等于0\n则将neg_count加1\n返回neg_count\n"}
{"prompt": "Write a function to find all three, four, five characters long words in the given string by using regex.", "canonical_solution": "import re\r\ndef find_char(text):\r\n  return (re.findall(r\"\\b\\w{3,5}\\b\", text))", "task_id": "Python/330", "test_setup": "", "test": ["assert find_char('For the four consumer complaints contact manager AKR reddy') == ['For', 'the', 'four', 'AKR', 'reddy']", "assert find_char('Certain service are subject to change MSR') == ['are', 'MSR']", "assert find_char('Third party legal desclaimers') == ['Third', 'party', 'legal']"], "challenge_test_list": [], "func_title": "def find_char(text):\r", "prompt_text_chinese": "写一个函数，通过使用regex在给定的字符串中找到所有3、4、5个字符的单词。", "code_comment": "导入re模块\n定义一个名为find_char的函数\n函数有一个参数text，表示一个字符串\n使用正则表达式查找text中所有长度在3到5之间的单词，并返回一个列表\n"}
{"prompt": "Write a python function to count unset bits of a given number.", "canonical_solution": "def count_unset_bits(n): \r\n    count = 0\r\n    x = 1\r\n    while(x < n + 1): \r\n        if ((x & n) == 0): \r\n            count += 1\r\n        x = x << 1\r\n    return count  ", "task_id": "Python/331", "test_setup": "", "test": ["assert count_unset_bits(2) == 1", "assert count_unset_bits(4) == 2", "assert count_unset_bits(6) == 1"], "challenge_test_list": [], "func_title": "def count_unset_bits(n): \r", "prompt_text_chinese": "写一个Python函数来计算一个给定数字的未设置位。", "code_comment": "定义一个名为count_unset_bits的函数\n函数有一个参数n，表示一个正整数\n初始化未设置的位计数器count为0，初始化x为1\n当x小于n+1时，执行循环\n如果x和n按位与的结果等于0\n则将count加1\n将x左移一位\n返回未设置的位计数器count\n"}
{"prompt": "Write a function to count character frequency of a given string.", "canonical_solution": "def char_frequency(str1):\r\n    dict = {}\r\n    for n in str1:\r\n        keys = dict.keys()\r\n        if n in keys:\r\n            dict[n] += 1\r\n        else:\r\n            dict[n] = 1\r\n    return dict", "task_id": "Python/332", "test_setup": "", "test": ["assert char_frequency('python')=={'p': 1, 'y': 1, 't': 1, 'h': 1, 'o': 1, 'n': 1}", "assert char_frequency('program')=={'p': 1, 'r': 2, 'o': 1, 'g': 1, 'a': 1, 'm': 1}", "assert char_frequency('language')=={'l': 1, 'a': 2, 'n': 1, 'g': 2, 'u': 1, 'e': 1}"], "challenge_test_list": [], "func_title": "def char_frequency(str1):\r", "prompt_text_chinese": "写一个函数来计算给定字符串的字符频率。", "code_comment": "定义一个名为char_frequency的函数\n函数有一个参数str1，表示一个字符串\n初始化一个空字典dict\n遍历字符串中的每个字符n\n获取字典中所有的键keys\n如果字符n在字典的键中\n将字典中n对应的值加1\n如果字符n不在字典的键中\n将字典中n的值赋为1\n返回字典dict\n"}
{"prompt": "Write a python function to sort a list according to the second element in sublist.", "canonical_solution": "def Sort(sub_li): \r\n    sub_li.sort(key = lambda x: x[1]) \r\n    return sub_li ", "task_id": "Python/333", "test_setup": "", "test": ["assert Sort([['a', 10], ['b', 5], ['c', 20], ['d', 15]]) == [['b', 5], ['a', 10], ['d', 15], ['c', 20]]", "assert Sort([['452', 10], ['256', 5], ['100', 20], ['135', 15]]) == [['256', 5], ['452', 10], ['135', 15], ['100', 20]]", "assert Sort([['rishi', 10], ['akhil', 5], ['ramya', 20], ['gaur', 15]]) == [['akhil', 5], ['rishi', 10], ['gaur', 15], ['ramya', 20]]"], "challenge_test_list": [], "func_title": "def Sort(sub_li): \r", "prompt_text_chinese": "编写一个Python函数，根据子列表中的第二个元素对列表进行排序。", "code_comment": "定义一个名为Sort的函数\n函数有一个参数sub_li，表示一个列表，其中每个元素也是一个列表，有两个元素\n对sub_li中的每个子列表按照第二个元素的值进行排序\n返回排序后的sub_li\n"}
{"prompt": "Write a python function to check whether the triangle is valid or not if sides are given.", "canonical_solution": "def check_Validity(a,b,c):  \r\n    if (a + b <= c) or (a + c <= b) or (b + c <= a) : \r\n        return False\r\n    else: \r\n        return True        ", "task_id": "Python/334", "test_setup": "", "test": ["assert check_Validity(1,2,3) == False", "assert check_Validity(2,3,5) == False", "assert check_Validity(7,10,5) == True"], "challenge_test_list": [], "func_title": "def check_Validity(a,b,c):  \r", "prompt_text_chinese": "写一个python函数，在给定边的情况下检查三角形是否有效。", "code_comment": "定义一个名为check_Validity的函数\n函数有三个参数a、b、c，表示三角形的三条边长\n如果任意两条边之和小于等于第三条边\n则返回False\n否则返回True\n"}
{"prompt": "Write a function to find the sum of arithmetic progression.", "canonical_solution": "def ap_sum(a,n,d):\r\n  total = (n * (2 * a + (n - 1) * d)) / 2\r\n  return total", "task_id": "Python/335", "test_setup": "", "test": ["assert ap_sum(1,5,2)==25", "assert ap_sum(2,6,4)==72", "assert ap_sum(1,4,5)==34"], "challenge_test_list": [], "func_title": "def ap_sum(a,n,d):\r", "prompt_text_chinese": "写一个函数来寻找算术级数的和。", "code_comment": "定义一个名为ap_sum的函数\n函数有三个参数a、n、d，分别表示等差数列的首项、项数和公差\n计算等差数列的总和\n返回总和\n"}
{"prompt": "Write a function to check whether the given month name contains 28 days or not.", "canonical_solution": "def check_monthnum(monthname1):\r\n  if monthname1 == \"February\":\r\n    return True\r\n  else:\r\n    return False", "task_id": "Python/336", "test_setup": "", "test": ["assert check_monthnum(\"February\")==True", "assert check_monthnum(\"January\")==False", "assert check_monthnum(\"March\")==False"], "challenge_test_list": [], "func_title": "def check_monthnum(monthname1):\r", "prompt_text_chinese": "写一个函数来检查给定的月份名称是否包含28天。", "code_comment": "定义一个名为check_monthnum的函数\n函数有一个参数monthname1，表示一个月份的字符串\n如果monthname1是2月份\n则返回True\n否则返回False\n"}
{"prompt": "Write a function that matches a word at the end of a string, with optional punctuation.", "canonical_solution": "import re\r\ndef text_match_word(text):\r\n        patterns = '\\w+\\S*$'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return 'Not matched!'", "task_id": "Python/337", "test_setup": "", "test": ["assert text_match_word(\"python.\")==('Found a match!')", "assert text_match_word(\"python.\")==('Found a match!')", "assert text_match_word(\"  lang  .\")==('Not matched!')"], "challenge_test_list": [], "func_title": "def text_match_word(text):\r", "prompt_text_chinese": "写一个函数，在一个字符串的末尾匹配一个单词，并可选择标点符号。", "code_comment": "导入re模块\n定义一个名为text_match_word的函数\n函数有一个参数text，表示一个字符串\n定义一个正则表达式模式patterns，用于匹配最后一个单词\n如果text中匹配到了正则表达式模式patterns的内容\n则返回'Found a match!'\n如果text中未匹配到正则表达式模式patterns的内容\n则返回'Not matched!'\n"}
{"prompt": "Write a python function to count the number of substrings with same first and last characters.", "canonical_solution": "def check_Equality(s): \r\n    return (ord(s[0]) == ord(s[len(s) - 1])); \r\ndef count_Substring_With_Equal_Ends(s): \r\n    result = 0; \r\n    n = len(s); \r\n    for i in range(n):\r\n        for j in range(1,n-i+1): \r\n            if (check_Equality(s[i:i+j])): \r\n                result+=1; \r\n    return result; ", "task_id": "Python/338", "test_setup": "", "test": ["assert count_Substring_With_Equal_Ends('aba') == 4", "assert count_Substring_With_Equal_Ends('abcab') == 7", "assert count_Substring_With_Equal_Ends('abc') == 3"], "challenge_test_list": [], "func_title": "def check_Equality(s): \r", "prompt_text_chinese": "写一个Python函数，计算首尾字符相同的子字符串的数量。", "code_comment": "定义一个名为check_Equality的函数\n函数有一个参数s，表示一个字符串\n函数用于判断s的首字母和尾字母是否相同，如果相同则返回True，否则返回False\n定义一个名为count_Substring_With_Equal_Ends的函数\n函数有一个参数s，表示一个字符串\n函数用于统计s中以相同字母结尾的子串的数量，并返回该数量\n枚举s中的所有子串\n如果子串的首字母和尾字母相同\n则将结果加1\n返回结果\n"}
{"prompt": "Write a python function to find the maximum occuring divisor in an interval.", "canonical_solution": "def find_Divisor(x,y):  \r\n    if (x==y): \r\n        return y \r\n    return 2", "task_id": "Python/339", "test_setup": "", "test": ["assert find_Divisor(2,2) == 2", "assert find_Divisor(2,5) == 2", "assert find_Divisor(5,10) == 2"], "challenge_test_list": [], "func_title": "def find_Divisor(x,y):  \r", "prompt_text_chinese": "写一个Python函数，找出在一个区间内出现的最大除数。", "code_comment": "定义一个名为find_Divisor的函数\n函数有两个参数x、y，表示两个整数\n如果x等于y，则返回y\n否则返回2\n"}
{"prompt": "Write a python function to find the sum of the three lowest positive numbers from a given list of numbers.", "canonical_solution": "def sum_three_smallest_nums(lst):\r\n\treturn sum(sorted([x for x in lst if x > 0])[:3])", "task_id": "Python/340", "test_setup": "", "test": ["assert sum_three_smallest_nums([10,20,30,40,50,60,7]) == 37", "assert sum_three_smallest_nums([1,2,3,4,5]) == 6", "assert sum_three_smallest_nums([0,1,2,3,4,5]) == 6"], "challenge_test_list": [], "func_title": "def sum_three_smallest_nums(lst):\r", "prompt_text_chinese": "编写一个Python函数，从给定的数字列表中找出三个最低正数之和。", "code_comment": "定义一个名为sum_three_smallest_nums的函数\n函数有一个参数lst，表示一个整数列表\n先过滤出lst中所有的正整数，然后将它们排序，并取前三个\n最后将这三个数相加，返回结果\n"}
{"prompt": "Write a function to convert the given set into ordered tuples.", "canonical_solution": "def set_to_tuple(s):\r\n  t = tuple(sorted(s))\r\n  return (t)", "task_id": "Python/341", "test_setup": "", "test": ["assert set_to_tuple({1, 2, 3, 4, 5}) == (1, 2, 3, 4, 5)", "assert set_to_tuple({6, 7, 8, 9, 10, 11}) == (6, 7, 8, 9, 10, 11)", "assert set_to_tuple({12, 13, 14, 15, 16}) == (12, 13, 14, 15, 16)"], "challenge_test_list": [], "func_title": "def set_to_tuple(s):\r", "prompt_text_chinese": "写一个函数，将给定的集合转换为有序图元。", "code_comment": "定义一个名为set_to_tuple的函数\n函数有一个参数s，表示一个集合\n函数用于将集合s转换为一个元组，返回该元组\n首先将集合s中的元素排序\n然后将排序后的元素构造成一个元组t\n返回元组t\n"}
{"prompt": "Write a function to find the smallest range that includes at-least one element from each of the given arrays.", "canonical_solution": "from heapq import heappop, heappush\r\nclass Node:\r\n    def __init__(self, value, list_num, index):\r\n        self.value = value\r\n        self.list_num = list_num\r\n        self.index = index\r\n    def __lt__(self, other):\r\n        return self.value < other.value\r\ndef find_minimum_range(list):\r\n    high = float('-inf')\r\n    p = (0, float('inf'))\r\n    pq = []\r\n    for i in range(len(list)):\r\n        heappush(pq, Node(list[i][0], i, 0))\r\n        high = max(high, list[i][0])\r\n    while True:\r\n        top = heappop(pq)\r\n        low = top.value\r\n        i = top.list_num\r\n        j = top.index\r\n        if high - low < p[1] - p[0]:\r\n            p = (low, high)\r\n        if j == len(list[i]) - 1:\r\n            return p\r\n        heappush(pq, Node(list[i][j + 1], i, j + 1))\r\n        high = max(high, list[i][j + 1])", "task_id": "Python/342", "test_setup": "", "test": ["assert find_minimum_range([[3, 6, 8, 10, 15], [1, 5, 12], [4, 8, 15, 16], [2, 6]]) == (4, 6)", "assert find_minimum_range([[ 2, 3, 4, 8, 10, 15 ], [1, 5, 12], [7, 8, 15, 16], [3, 6]]) == (4, 7)", "assert find_minimum_range([[4, 7, 9, 11, 16], [2, 6, 13], [5, 9, 16, 17], [3, 7]]) == (5, 7)"], "challenge_test_list": [], "func_title": "def find_minimum_range(list):\r", "prompt_text_chinese": "写一个函数，从给定的数组中找出最小的范围，其中至少包括一个元素。", "code_comment": "导入必要的模块\n定义一个名为Node的类\n类的初始化函数，有三个参数value、list_num、index，分别表示一个值、所在列表的编号和值在列表中的索引\n类的比较函数，用于比较两个Node对象的value值的大小，从而用于堆排序\n定义一个名为find_minimum_range的函数\n函数有一个参数list，表示一个由多个列表组成的列表\n函数用于求出所有列表中的数的最小区间，并以元组的形式返回该区间的起止值\n定义最大值high、最小区间p、以及用于堆排序的pq\n首先将每个列表的首项加入到pq中，并记录下最大值high\n不断从pq中取出最小的元素，并计算该元素所在列表的最小值low\n记录下最小区间p，然后将该元素所在列表的下一个元素加入到pq中\n如果该元素所在列表已经到达了末尾，则函数返回最小区间p\n"}
{"prompt": "Write a function to calculate the number of digits and letters in a string.", "canonical_solution": "def dig_let(s):\r\n d=l=0\r\n for c in s:\r\n    if c.isdigit():\r\n        d=d+1\r\n    elif c.isalpha():\r\n        l=l+1\r\n    else:\r\n        pass\r\n return (l,d)", "task_id": "Python/343", "test_setup": "", "test": ["assert dig_let(\"python\")==(6,0)", "assert dig_let(\"program\")==(7,0)", "assert dig_let(\"python3.0\")==(6,2)"], "challenge_test_list": [], "func_title": "def dig_let(s):\r", "prompt_text_chinese": "写一个函数来计算一个字符串中的数字和字母的数量。", "code_comment": "定义一个名为dig_let的函数\n函数有一个参数s，表示一个字符串\n函数用于统计字符串s中数字和字母的个数，返回一个元组，元组的第一个元素为字母的个数，第二个元素为数字的个数\n初始化字母和数字的个数为0\n遍历字符串s中的每一个字符\n如果该字符为数字，则数字个数加1\n如果该字符为字母，则字母个数加1\n如果该字符既不是数字也不是字母，则不做任何操作\n返回一个元组，元组的第一个元素为字母的个数，第二个元素为数字的个数\n"}
{"prompt": "Write a python function to find number of elements with odd factors in a given range.", "canonical_solution": "def count_Odd_Squares(n,m): \r\n    return int(m**0.5) - int((n-1)**0.5) ", "task_id": "Python/344", "test_setup": "", "test": ["assert count_Odd_Squares(5,100) == 8", "assert count_Odd_Squares(8,65) == 6", "assert count_Odd_Squares(2,5) == 1"], "challenge_test_list": [], "func_title": "def count_Odd_Squares(n,m): \r", "prompt_text_chinese": "写一个Python函数，找出给定范围内具有奇数因子的元素的数量。", "code_comment": "定义一个名为count_Odd_Squares的函数\n函数有两个参数n、m，表示两个整数\n函数用于计算在n和m之间（包括n和m），有多少个奇数的平方数，并返回该数量\n计算m的平方根\n减去n-1的平方根\n取整数部分\n即为n和m之间（包括n和m），有多少个奇数的平方数\n"}
{"prompt": "Write a function to find the difference between two consecutive numbers in a given list.", "canonical_solution": "def diff_consecutivenums(nums):\r\n    result = [b-a for a, b in zip(nums[:-1], nums[1:])]\r\n    return result", "task_id": "Python/345", "test_setup": "", "test": ["assert diff_consecutivenums([1, 1, 3, 4, 4, 5, 6, 7])==[0, 2, 1, 0, 1, 1, 1]", "assert diff_consecutivenums([4, 5, 8, 9, 6, 10])==[1, 3, 1, -3, 4]", "assert diff_consecutivenums([0, 1, 2, 3, 4, 4, 4, 4, 5, 7])==[1, 1, 1, 1, 0, 0, 0, 1, 2]"], "challenge_test_list": [], "func_title": "def diff_consecutivenums(nums):\r", "prompt_text_chinese": "写一个函数来查找给定列表中两个连续数字的差。", "code_comment": "定义一个名为diff_consecutivenums的函数\n函数有一个参数nums，表示一个整数列表\n函数用于计算列表中每两个相邻元素之间的差值，并将差值构成一个新的列表返回\n使用zip函数将列表nums中相邻的两个元素进行组合，得到一个由元组构成的列表\n对于每个元组(a, b)，计算b-a的值，并将其加入到结果列表result中\n返回结果列表result\n"}
{"prompt": "Write a function to find entringer number e(n, k).", "canonical_solution": "def zigzag(n, k): \r\n\tif (n == 0 and k == 0): \r\n\t\treturn 1\r\n\tif (k == 0): \r\n\t\treturn 0\r\n\treturn zigzag(n, k - 1) + zigzag(n - 1, n - k)", "task_id": "Python/346", "test_setup": "", "test": ["assert zigzag(4, 3) == 5", "assert zigzag(4, 2) == 4", "assert zigzag(3, 1) == 1"], "challenge_test_list": [], "func_title": "def zigzag(n, k): \r", "prompt_text_chinese": "写一个函数来查找托林格数e(n, k)。", "code_comment": "定义一个名为zigzag的函数\n函数有两个参数n、k，表示两个整数\n函数用于计算ZigZag数，返回该数的值\n如果n和k都等于0，则ZigZag数为1\n如果k等于0，则ZigZag数为0\n否则，根据ZigZag数的递推公式，返回递归求解的结果\n"}
{"prompt": "Write a python function to count the number of squares in a rectangle.", "canonical_solution": "def count_Squares(m,n): \r\n    if (n < m): \r\n        temp = m \r\n        m = n \r\n        n = temp \r\n    return n * (n + 1) * (3 * m - n + 1) // 6", "task_id": "Python/347", "test_setup": "", "test": ["assert count_Squares(4,3) == 20", "assert count_Squares(1,2) == 2", "assert count_Squares(2,2) == 5"], "challenge_test_list": [], "func_title": "def count_Squares(m,n): \r", "prompt_text_chinese": "写一个Python函数来计算矩形中的正方形的数量。", "code_comment": "定义一个名为count_Squares的函数\n函数有两个参数m、n，表示两个整数\n函数用于计算在m*n的矩形中，正方形的个数，并返回该数量\n如果n小于m，则交换m和n的值\n根据正方形个数的公式，计算正方形的个数，并返回结果\n"}
{"prompt": "Write a function to count sequences of given length having non-negative prefix sums that can be generated by given values.", "canonical_solution": "def bin_coff(n, r): \r\n\tval = 1\r\n\tif (r > (n - r)): \r\n\t\tr = (n - r) \r\n\tfor i in range(0, r): \r\n\t\tval *= (n - i) \r\n\t\tval //= (i + 1) \r\n\treturn val \r\ndef find_ways(M): \r\n\tn = M // 2\r\n\ta = bin_coff(2 * n, n) \r\n\tb = a // (n + 1) \r\n\treturn (b) ", "task_id": "Python/348", "test_setup": "", "test": ["assert find_ways(4) == 2", "assert find_ways(6) == 5", "assert find_ways(8) == 14"], "challenge_test_list": [], "func_title": "def bin_coff(n, r): \r", "prompt_text_chinese": "写一个函数来计算具有非负前缀和的给定长度的序列，这些序列可以由给定值产生。", "code_comment": "定义一个名为bin_coff的函数\n函数有两个参数n、r，表示两个整数\n函数用于计算组合数C(n, r)，返回计算结果\n初始化计算结果为1\n如果r大于n-r，则将r的值替换为n-r，以优化计算\n根据组合数的公式，计算组合数C(n, r)的值\n返回计算结果\n定义一个名为find_ways的函数\n函数有一个参数M，表示一个整数\n函数用于计算将M个人分成若干组，每组至少有两个人的方案数，并返回方案数\n首先将M的一半记为n\n根据组合数的公式，计算组合数C(2n, n)的值\n将该组合数除以n+1，得到将M个人分成若干组，每组至少有两个人的方案数\n返回方案数\n"}
{"prompt": "Write a python function to check whether the given string is a binary string or not.", "canonical_solution": "def check(string) :\r\n    p = set(string) \r\n    s = {'0', '1'} \r\n    if s == p or p == {'0'} or p == {'1'}: \r\n        return (\"Yes\") \r\n    else : \r\n        return (\"No\") ", "task_id": "Python/349", "test_setup": "", "test": ["assert check(\"01010101010\") == \"Yes\"", "assert check(\"name0\") == \"No\"", "assert check(\"101\") == \"Yes\""], "challenge_test_list": [], "func_title": "def check(string) :\r", "prompt_text_chinese": "写一个python函数，检查给定的字符串是否是二进制字符串。", "code_comment": "定义一个名为check的函数\n函数有一个参数string，表示一个字符串\n函数用于检查字符串中是否只包含0和1两个字符，或者只包含0或1字符，并返回检查结果\n将字符串中的所有字符放入集合p中\n定义一个集合s，表示只包含0和1两个字符的集合\n如果p等于s，或者p等于{'0'}，或者p等于{'1'}，则返回\"Yes\"，否则返回\"No\"\n"}
{"prompt": "Write a python function to minimize the length of the string by removing occurrence of only one character.", "canonical_solution": "def minimum_Length(s) : \r\n    maxOcc = 0\r\n    n = len(s) \r\n    arr = [0]*26\r\n    for i in range(n) : \r\n        arr[ord(s[i]) -ord('a')] += 1\r\n    for i in range(26) : \r\n        if arr[i] > maxOcc : \r\n            maxOcc = arr[i] \r\n    return n - maxOcc ", "task_id": "Python/350", "test_setup": "", "test": ["assert minimum_Length(\"mnm\") == 1", "assert minimum_Length(\"abcda\") == 3", "assert minimum_Length(\"abcb\") == 2"], "challenge_test_list": [], "func_title": "def minimum_Length(s) : \r", "prompt_text_chinese": "编写一个Python函数，通过删除出现的一个字符来尽量减少字符串的长度。", "code_comment": "定义一个名为minimum_Length的函数\n函数有一个参数s，表示一个字符串\n函数用于计算将字符串s中的某个字符全部删除后，可以得到的最短字符串的长度，并返回该长度\n初始化最大出现次数为0\n获取字符串s的长度n\n初始化一个长度为26的列表arr，用于统计每个字符出现的次数\n遍历字符串s中的每个字符，统计每个字符出现的次数\n在arr列表中查找最大出现次数maxOcc\n返回n减去最大出现次数maxOcc所得到的差值\n"}
{"prompt": "Write a python function to find the first element occurring k times in a given array.", "canonical_solution": "def first_Element(arr,n,k): \r\n    count_map = {}; \r\n    for i in range(0, n): \r\n        if(arr[i] in count_map.keys()): \r\n            count_map[arr[i]] += 1\r\n        else: \r\n            count_map[arr[i]] = 1\r\n        i += 1\r\n    for i in range(0, n):  \r\n        if (count_map[arr[i]] == k): \r\n            return arr[i] \r\n        i += 1 \r\n    return -1", "task_id": "Python/351", "test_setup": "", "test": ["assert first_Element([0,1,2,3,4,5],6,1) == 0", "assert first_Element([1,2,1,3,4],5,2) == 1", "assert first_Element([2,3,4,3,5,7,1,2,3,5],10,2) == 2"], "challenge_test_list": [], "func_title": "def first_Element(arr,n,k): \r", "prompt_text_chinese": "写一个Python函数，找出在给定数组中出现k次的第一个元素。", "code_comment": "定义一个名为first_Element的函数\n函数有三个参数arr、n、k，表示一个整数数组、数组长度和一个整数\n函数用于查找数组arr中第一个出现次数为k的元素，并返回该元素的值\n初始化一个字典count_map，用于统计每个元素出现的次数\n遍历数组arr，统计每个元素出现的次数\n遍历数组arr，查找第一个出现次数为k的元素\n如果没有找到满足条件的元素，则返回-1\n"}
{"prompt": "Write a python function to check whether all the characters in a given string are unique.", "canonical_solution": "def unique_Characters(str):\r\n    for i in range(len(str)):\r\n        for j in range(i + 1,len(str)): \r\n            if (str[i] == str[j]):\r\n                return False;\r\n    return True;", "task_id": "Python/352", "test_setup": "", "test": ["assert unique_Characters('aba') == False", "assert unique_Characters('abc') == True", "assert unique_Characters('abab') == False"], "challenge_test_list": [], "func_title": "def unique_Characters(str):\r", "prompt_text_chinese": "写一个python函数来检查给定字符串中的所有字符是否是唯一的。", "code_comment": "定义一个名为unique_Characters的函数\n函数有一个参数str，表示一个字符串\n函数用于判断字符串str中是否包含重复的字符，如果不包含，则返回True，否则返回False\n遍历字符串中的每个字符\n再次遍历字符串中的后续字符，查找是否有与当前字符相同的字符\n如果找到了相同的字符，则返回False\n如果没有找到相同的字符，则返回True\n"}
{"prompt": "Write a function to remove a specified column from a given nested list.", "canonical_solution": "def remove_column(list1, n):\r\n   for i in list1: \r\n    del i[n] \r\n   return list1", "task_id": "Python/353", "test_setup": "", "test": ["assert remove_column([[1, 2, 3], [2, 4, 5], [1, 1, 1]],0)==[[2, 3], [4, 5], [1, 1]]", "assert remove_column([[1, 2, 3], [-2, 4, -5], [1, -1, 1]],2)==[[1, 2], [-2, 4], [1, -1]]", "assert remove_column([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]],0)==[[3], [7], [3], [15, 17], [7], [11]]"], "challenge_test_list": [], "func_title": "def remove_column(list1, n):\r", "prompt_text_chinese": "写一个函数，从给定的嵌套列表中删除一个指定的列。", "code_comment": "定义一个名为remove_column的函数\n函数有两个参数list1、n，表示一个二维列表和一个整数\n函数用于删除二维列表list1中所有子列表的第n个元素，并返回新的二维列表\n遍历list1中的每个子列表\n删除每个子列表中的第n个元素\n返回新的二维列表\n"}
{"prompt": "Write a function to find t-nth term of arithemetic progression.", "canonical_solution": "def tn_ap(a,n,d):\r\n  tn = a + (n - 1) * d\r\n  return tn", "task_id": "Python/354", "test_setup": "", "test": ["assert tn_ap(1,5,2)==9", "assert tn_ap(2,6,4)==22", "assert tn_ap(1,4,5)==16"], "challenge_test_list": [], "func_title": "def tn_ap(a,n,d):\r", "prompt_text_chinese": "写一个函数来查找数列的第t-n项。", "code_comment": "定义一个名为tn_ap的函数\n函数有三个参数a、n、d，表示一个等差数列的首项、项数和公差\n函数用于计算等差数列的第n项，返回计算结果\n计算等差数列的第n项tn，并将其赋值给变量tn\n返回tn\n"}
{"prompt": "Write a python function to count the number of rectangles in a circle of radius r.", "canonical_solution": "def count_Rectangles(radius):  \r\n    rectangles = 0 \r\n    diameter = 2 * radius \r\n    diameterSquare = diameter * diameter \r\n    for a in range(1, 2 * radius):  \r\n        for b in range(1, 2 * radius): \r\n            diagnalLengthSquare = (a * a +  b * b)  \r\n            if (diagnalLengthSquare <= diameterSquare) : \r\n                rectangles += 1\r\n    return rectangles ", "task_id": "Python/355", "test_setup": "", "test": ["assert count_Rectangles(2) == 8", "assert count_Rectangles(1) == 1", "assert count_Rectangles(0) == 0"], "challenge_test_list": [], "func_title": "def count_Rectangles(radius):  \r", "prompt_text_chinese": "写一个Python函数来计算半径为r的圆中矩形的数量。", "code_comment": "定义一个名为count_Rectangles的函数\n函数有一个参数radius，表示一个整数\n函数用于计算以半径radius为边长的正方形组成的矩形中，可以找到的所有正方形的个数，并返回该数量\n初始化矩形的数量为0\n计算正方形的直径，即等于两倍的半径\n计算直径的平方\n遍历所有可能的正方形的边长a和b\n计算正方形对角线的长度的平方\n如果正方形对角线的长度的平方小于等于直径的平方，则正方形可以被包含在矩形中，增加计数器rectangles的值\n返回正方形数量的计数器rectangles的值\n"}
{"prompt": "Write a function to find the third angle of a triangle using two angles.", "canonical_solution": "def find_angle(a,b):\r\n c = 180 - (a + b)\r\n return c\r\n", "task_id": "Python/356", "test_setup": "", "test": ["assert find_angle(47,89)==44", "assert find_angle(45,95)==40", "assert find_angle(50,40)==90"], "challenge_test_list": [], "func_title": "def find_angle(a,b):\r", "prompt_text_chinese": "写一个函数，用两个角找到三角形的第三个角。", "code_comment": "定义一个名为find_angle的函数\n函数有两个参数a、b，表示两个角的度数\n函数用于计算第三个角的度数，并返回计算结果\n计算第三个角的度数c，即等于180减去前两个角的度数之和\n返回第三个角的度数c\n"}
{"prompt": "Write a function to find the maximum element of all the given tuple records.", "canonical_solution": "def find_max(test_list):\r\n  res = max(int(j) for i in test_list for j in i)\r\n  return (res) ", "task_id": "Python/357", "test_setup": "", "test": ["assert find_max([(2, 4), (6, 7), (5, 1), (6, 10), (8, 7)]) == 10", "assert find_max([(3, 5), (7, 8), (6, 2), (7, 11), (9, 8)]) == 11", "assert find_max([(4, 6), (8, 9), (7, 3), (8, 12), (10, 9)]) == 12"], "challenge_test_list": [], "func_title": "def find_max(test_list):\r", "prompt_text_chinese": "写一个函数，找出所有给定元组记录的最大元素。", "code_comment": "定义一个名为find_max的函数\n函数有一个参数test_list，表示一个二维列表\n函数用于查找二维列表test_list中所有元素中的最大值，并返回该最大值\n使用生成器表达式获取二维列表中的所有元素，并将其转换为整数\n然后使用max函数查找其中的最大值，并将其赋值给变量res\n返回res，即为所有元素中的最大值\n"}
{"prompt": "Write a function to find modulo division of two lists using map and lambda function.", "canonical_solution": "def moddiv_list(nums1,nums2):\r\n  result = map(lambda x, y: x % y, nums1, nums2)\r\n  return list(result)", "task_id": "Python/358", "test_setup": "", "test": ["assert moddiv_list([4,5,6],[1, 2, 3])==[0, 1, 0]", "assert moddiv_list([3,2],[1,4])==[0, 2]", "assert moddiv_list([90,120],[50,70])==[40, 50]"], "challenge_test_list": [], "func_title": "def moddiv_list(nums1,nums2):\r", "prompt_text_chinese": "写一个函数，用map和lambda函数找出两个列表的模除。", "code_comment": "定义一个名为moddiv_list的函数\n函数有两个参数nums1、nums2，表示两个整数列表\n函数用于计算nums1中每个元素对nums2中对应位置的元素取模所得的值，并将结果存储在列表result中，最后返回该列表\n使用map函数和lambda表达式计算nums1中每个元素对nums2中对应位置的元素取模所得的值，并将结果存储在result中\n将result转换为列表类型，并返回该列表\n"}
{"prompt": "Write a python function to check whether one root of the quadratic equation is twice of the other or not.", "canonical_solution": "def Check_Solution(a,b,c): \r\n    if (2*b*b == 9*a*c): \r\n        return (\"Yes\"); \r\n    else: \r\n        return (\"No\"); ", "task_id": "Python/359", "test_setup": "", "test": ["assert Check_Solution(1,3,2) == \"Yes\"", "assert Check_Solution(1,2,3) == \"No\"", "assert Check_Solution(1,-5,6) == \"No\""], "challenge_test_list": [], "func_title": "def Check_Solution(a,b,c): \r", "prompt_text_chinese": "写一个python函数来检查二次方程的一个根是否是另一个根的两倍。", "code_comment": "定义一个名为Check_Solution的函数\n函数有三个参数a、b、c，表示三个实数\n函数用于检查是否满足2bb等于9ac的关系，如果满足，则返回\"Yes\"，否则返回\"No\"\n如果满足2bb等于9ac的关系，则返回\"Yes\"\n如果不满足2bb等于9ac的关系，则返回\"No\"\n"}
{"prompt": "Write a function to find the n’th carol number.", "canonical_solution": "def get_carol(n): \r\n\tresult = (2**n) - 1\r\n\treturn result * result - 2", "task_id": "Python/360", "test_setup": "", "test": ["assert get_carol(2) == 7", "assert get_carol(4) == 223", "assert get_carol(5) == 959"], "challenge_test_list": [], "func_title": "def get_carol(n): \r", "prompt_text_chinese": "写一个函数来寻找第n个卡罗尔数。", "code_comment": "定义一个名为get_carol的函数\n函数有一个参数n，表示一个整数\n函数用于计算第n个Carol数，并返回计算结果\n计算第n个Carol数的值，即为2的n次方减1，再将该值的平方减去2，并将结果赋值给变量result\n返回计算结果result\n"}
{"prompt": "Write a function to remove empty lists from a given list of lists.", "canonical_solution": "def remove_empty(list1):\r\n  remove_empty = [x for x in list1 if x]\r\n  return remove_empty", "task_id": "Python/361", "test_setup": "", "test": ["assert remove_empty([[], [], [], 'Red', 'Green', [1,2], 'Blue', [], []])==['Red', 'Green', [1, 2], 'Blue']", "assert remove_empty([[], [], [],[],[], 'Green', [1,2], 'Blue', [], []])==[ 'Green', [1, 2], 'Blue']", "assert remove_empty([[], [], [], 'Python',[],[], 'programming', 'language',[],[],[], [], []])==['Python', 'programming', 'language']"], "challenge_test_list": [], "func_title": "def remove_empty(list1):\r", "prompt_text_chinese": "写一个函数，从一个给定的列表中删除空列表。", "code_comment": "定义一个名为remove_empty的函数\n函数有一个参数list1，表示一个列表\n函数用于删除列表list1中的空元素，并返回新的列表remove_empty\n使用列表推导式遍历list1中的所有元素，将非空元素添加到新的列表中，并将该列表赋值给变量remove_empty\n返回新的列表remove_empty\n"}
{"prompt": "Write a python function to find the item with maximum occurrences in a given list.", "canonical_solution": "def max_occurrences(nums):\r\n    max_val = 0\r\n    result = nums[0] \r\n    for i in nums:\r\n        occu = nums.count(i)\r\n        if occu > max_val:\r\n            max_val = occu\r\n            result = i \r\n    return result", "task_id": "Python/362", "test_setup": "", "test": ["assert max_occurrences([1,2,3,1,2,3,12,4,2]) ==  2", "assert max_occurrences([1,2,6,7,0,1,0,1,0]) == 1,0", "assert max_occurrences([1,2,3,1,2,4,1]) == 1"], "challenge_test_list": [], "func_title": "def max_occurrences(nums):\r", "prompt_text_chinese": "写一个Python函数，找出在给定列表中出现次数最多的项目。", "code_comment": "定义一个名为max_occurrences的函数\n函数有一个参数nums，表示一个整数列表\n函数用于查找列表nums中出现次数最多的元素，并返回该元素\n初始化出现次数最多的元素的计数器max_val为0，和结果变量result为nums列表的第一个元素\n遍历nums列表中的每个元素i\n计算元素i在nums列表中出现的次数occu\n如果元素i在nums列表中出现的次数occu大于最大值max_val，则将最大值max_val更新为occu，并将结果变量result更新为元素i\n返回结果变量result，即为出现次数最多的元素\n"}
{"prompt": "Write a function to add the k elements to each element in the tuple.", "canonical_solution": "def add_K_element(test_list, K):\r\n  res = [tuple(j + K for j in sub ) for sub in test_list]\r\n  return (res) ", "task_id": "Python/363", "test_setup": "", "test": ["assert add_K_element([(1, 3, 4), (2, 4, 6), (3, 8, 1)], 4) == [(5, 7, 8), (6, 8, 10), (7, 12, 5)]", "assert add_K_element([(1, 2, 3), (4, 5, 6), (7, 8, 9)], 8) == [(9, 10, 11), (12, 13, 14), (15, 16, 17)]", "assert add_K_element([(11, 12, 13), (14, 15, 16), (17, 18, 19)], 9) == [(20, 21, 22), (23, 24, 25), (26, 27, 28)]"], "challenge_test_list": [], "func_title": "def add_K_element(test_list, K):\r", "prompt_text_chinese": "写一个函数，将k元素添加到元组中的每个元素上。", "code_comment": "定义一个名为add_K_element的函数\n函数有两个参数test_list、K，表示一个二维列表和一个整数\n函数用于将二维列表test_list中的所有元素都加上整数K，并返回新的二维列表res\n使用列表推导式遍历test_list中的每个子列表，并将其中的所有元素都加上K，然后将所得到的新的子列表转换成元组类型，最终将所有元组组成一个新的列表，并将其赋值给变量res\n返回新的二维列表res\n"}
{"prompt": "Write a function to find the number of flips required to make the given binary string a sequence of alternate characters.", "canonical_solution": "def make_flip(ch): \r\n\treturn '1' if (ch == '0') else '0'\r\ndef get_flip_with_starting_charcter(str, expected): \r\n\tflip_count = 0\r\n\tfor i in range(len( str)): \r\n\t\tif (str[i] != expected): \r\n\t\t\tflip_count += 1\r\n\t\texpected = make_flip(expected) \r\n\treturn flip_count \r\ndef min_flip_to_make_string_alternate(str): \r\n\treturn min(get_flip_with_starting_charcter(str, '0'),get_flip_with_starting_charcter(str, '1')) ", "task_id": "Python/364", "test_setup": "", "test": ["assert min_flip_to_make_string_alternate(\"0001010111\") == 2", "assert min_flip_to_make_string_alternate(\"001\") == 1", "assert min_flip_to_make_string_alternate(\"010111011\") == 2 "], "challenge_test_list": [], "func_title": "def make_flip(ch): \r", "prompt_text_chinese": "写一个函数，找出使给定二进制字符串成为交替字符序列所需的翻转次数。", "code_comment": "定义一个名为make_flip的函数\n函数有一个参数ch，表示一个字符\n函数用于将字符ch翻转，即'0'变成'1'，'1'变成'0'，然后返回翻转后的结果\n如果字符ch是'0'，则返回'1'，否则返回'0'\n定义一个名为get_flip_with_starting_charcter的函数\n函数有两个参数str、expected，表示一个字符串和一个字符\n函数用于从字符串str的第一个字符开始，计算将其余所有字符都翻转成与expected相同的字符所需的翻转次数，并返回计算结果\n初始化翻转次数的计数器flip_count为0\n遍历字符串str中的每个字符\n如果当前字符不等于expected，则将翻转次数的计数器flip_count加1\n将expected翻转，即调用make_flip函数，得到新的expected值\n返回翻转次数的计数器flip_count\n定义一个名为min_flip_to_make_string_alternate的函数\n函数有一个参数str，表示一个字符串\n函数用于计算将字符串str变成交替的字符序列所需的最小翻转次数，并返回计算结果\n分别计算假设字符串str的第一个字符是'0'和'1'时，将字符串变成交替的字符序列所需的翻转次数\n并返回两个翻转次数中的较小值\n"}
{"prompt": "Write a python function to count the number of digits of a given number.", "canonical_solution": "def count_Digit(n):\r\n    count = 0\r\n    while n != 0:\r\n        n //= 10\r\n        count += 1\r\n    return count", "task_id": "Python/365", "test_setup": "", "test": ["assert count_Digit(12345) == 5", "assert count_Digit(11223305) == 8", "assert count_Digit(4123459) == 7"], "challenge_test_list": [], "func_title": "def count_Digit(n):\r", "prompt_text_chinese": "写一个python函数来计算给定数字的位数。", "code_comment": "定义一个名为count_Digit的函数\n函数有一个参数n，表示一个整数\n函数用于计算整数n的位数，并返回计算结果\n初始化位数的计数器count为0\n当n不等于0时，执行循环体内的语句\n将n除以10的整数部分赋值给n，相当于将n的个位数去除\n将位数的计数器count加1，相当于统计一位数字\n返回位数的计数器count\n"}
{"prompt": "Write a python function to find the largest product of the pair of adjacent elements from a given list of integers.", "canonical_solution": "def adjacent_num_product(list_nums):\r\n    return max(a*b for a, b in zip(list_nums, list_nums[1:]))", "task_id": "Python/366", "test_setup": "", "test": ["assert adjacent_num_product([1,2,3,4,5,6]) == 30", "assert adjacent_num_product([1,2,3,4,5]) == 20", "assert adjacent_num_product([2,3]) == 6"], "challenge_test_list": [], "func_title": "def adjacent_num_product(list_nums):\r", "prompt_text_chinese": "写一个python函数，从给定的整数列表中找出一对相邻元素的最大乘积。", "code_comment": "定义一个名为adjacent_num_product的函数\n函数有一个参数list_nums，表示一个整数列表\n函数用于计算列表list_nums中相邻两个元素的乘积，并返回最大的乘积值\n使用zip函数将列表list_nums和list_nums中删除第一个元素后的剩余元素组合成一个新的元组序列\n然后使用列表推导式计算相邻两个元素的乘积，并将所有乘积所组成的新列表中的最大值作为函数的返回值\n"}
{"prompt": "Write a function to check if a binary tree is balanced or not.", "canonical_solution": "class Node: \r\n\tdef __init__(self, data): \r\n\t\tself.data = data \r\n\t\tself.left = None\r\n\t\tself.right = None\r\ndef get_height(root): \r\n\tif root is None: \r\n\t\treturn 0\r\n\treturn max(get_height(root.left), get_height(root.right)) + 1\r\ndef is_tree_balanced(root): \r\n\tif root is None: \r\n\t\treturn True\r\n\tlh = get_height(root.left) \r\n\trh = get_height(root.right) \r\n\tif (abs(lh - rh) <= 1) and is_tree_balanced( \r\n\troot.left) is True and is_tree_balanced( root.right) is True: \r\n\t\treturn True\r\n\treturn False", "task_id": "Python/367", "test_setup": "root = Node(1) \r\nroot.left = Node(2) \r\nroot.right = Node(3) \r\nroot.left.left = Node(4) \r\nroot.left.right = Node(5) \r\nroot.left.left.left = Node(8) \r\nroot1 = Node(1) \r\nroot1.left = Node(2) \r\nroot1.right = Node(3) \r\nroot1.left.left = Node(4) \r\nroot1.left.right = Node(5) \r\nroot1.right.left = Node(6) \r\nroot1.left.left.left = Node(7)\r\nroot2 = Node(1) \r\nroot2.left = Node(2) \r\nroot2.right = Node(3) \r\nroot2.left.left = Node(4) \r\nroot2.left.right = Node(5)\r\nroot2.left.left.left = Node(7)", "test": ["assert is_tree_balanced(root) == False", "assert is_tree_balanced(root1) == True", "assert is_tree_balanced(root2) == False "], "challenge_test_list": [], "func_title": "def get_height(root): \r", "prompt_text_chinese": "写一个函数来检查一个二叉树是否平衡。", "code_comment": "定义一个名为Node的类\n类的构造函数，有一个参数data，表示节点中存储的数据\n初始化节点存储的数据为data\n初始化节点的左子节点和右子节点为None\n定义一个名为get_height的函数\n函数有一个参数root，表示一棵二叉树的根节点\n函数用于计算二叉树的高度，并返回计算结果\n如果根节点为None，则返回0\n否则，计算左子节点的高度和右子节点的高度中的较大值，并加1，即为二叉树的高度\n定义一个名为is_tree_balanced的函数\n函数有一个参数root，表示一棵二叉树的根节点\n函数用于检查二叉树是否平衡，并返回检查结果\n如果根节点为None，则返回True\n计算左子树和右子树的高度\n如果左子树和右子树的高度差不超过1，并且左子树和右子树都是平衡的，则返回True，否则返回False\n"}
{"prompt": "Write a function to repeat the given tuple n times.", "canonical_solution": "def repeat_tuples(test_tup, N):\r\n  res = ((test_tup, ) * N)\r\n  return (res) ", "task_id": "Python/368", "test_setup": "", "test": ["assert repeat_tuples((1, 3), 4) == ((1, 3), (1, 3), (1, 3), (1, 3))", "assert repeat_tuples((1, 2), 3) == ((1, 2), (1, 2), (1, 2))", "assert repeat_tuples((3, 4), 5) == ((3, 4), (3, 4), (3, 4), (3, 4), (3, 4))"], "challenge_test_list": [], "func_title": "def repeat_tuples(test_tup, N):\r", "prompt_text_chinese": "写一个函数来重复给定的元组n次。", "code_comment": "定义一个函数 repeat_tuples，接收两个参数 test_tup 和 N\n将 test_tup 重复 N 次并赋值给 res\n返回 res\n"}
{"prompt": "Write a function to find the lateral surface area of cuboid", "canonical_solution": "def lateralsurface_cuboid(l,w,h):\r\n  LSA = 2*h*(l+w)\r\n  return LSA", "task_id": "Python/369", "test_setup": "", "test": ["assert lateralsurface_cuboid(8,5,6)==156", "assert lateralsurface_cuboid(7,9,10)==320", "assert lateralsurface_cuboid(10,20,30)==1800"], "challenge_test_list": [], "func_title": "def lateralsurface_cuboid(l,w,h):\r", "prompt_text_chinese": "写一个函数来求长方体的侧表面积。", "code_comment": "定义一个函数 lateralsurface_cuboid，接收三个参数 l、w、h，分别代表长、宽、高\n计算长方体的侧面积，并赋值给 LSA\n返回侧面积 LSA\n"}
{"prompt": "Write a function to sort a tuple by its float element.", "canonical_solution": "def float_sort(price):\r\n  float_sort=sorted(price, key=lambda x: float(x[1]), reverse=True)\r\n  return float_sort", "task_id": "Python/370", "test_setup": "", "test": ["assert float_sort([('item1', '12.20'), ('item2', '15.10'), ('item3', '24.5')])==[('item3', '24.5'), ('item2', '15.10'), ('item1', '12.20')] ", "assert float_sort([('item1', '15'), ('item2', '10'), ('item3', '20')])==[('item3', '20'), ('item1', '15'), ('item2', '10')] ", "assert float_sort([('item1', '5'), ('item2', '10'), ('item3', '14')])==[('item3', '14'), ('item2', '10'), ('item1', '5')] "], "challenge_test_list": [], "func_title": "def float_sort(price):\r", "prompt_text_chinese": "写一个函数对一个元组按其浮点元素进行排序。", "code_comment": "定义一个函数 float_sort，接收一个参数 price，该参数是一个列表\n对 price 列表进行排序，排序的依据是列表中每个元素的第二个位置（下标为 1）转为 float 类型之后的大小，\n并且按照降序（从大到小）排序。排序结果赋值给 float_sort\n返回排序后的列表 float_sort\n"}
{"prompt": "Write a function to find the smallest missing element in a sorted array.", "canonical_solution": "def smallest_missing(A, left_element, right_element):\r\n    if left_element > right_element:\r\n        return left_element\r\n    mid = left_element + (right_element - left_element) // 2\r\n    if A[mid] == mid:\r\n        return smallest_missing(A, mid + 1, right_element)\r\n    else:\r\n        return smallest_missing(A, left_element, mid - 1)", "task_id": "Python/371", "test_setup": "", "test": ["assert smallest_missing([0, 1, 2, 3, 4, 5, 6], 0, 6) == 7", "assert smallest_missing([0, 1, 2, 6, 9, 11, 15], 0, 6) == 3", "assert smallest_missing([1, 2, 3, 4, 6, 9, 11, 15], 0, 7) == 0"], "challenge_test_list": [], "func_title": "def smallest_missing(A, left_element, right_element):\r", "prompt_text_chinese": "写一个函数来找出排序后的数组中最小的缺失元素。", "code_comment": "定义一个函数 smallest_missing，接收三个参数 A、left_element 和 right_element，其中 A 是一个列表，\nleft_element 和 right_element 分别代表左右边界的下标。\n如果左边界下标大于右边界下标，说明已经找到最小的丢失的数，返回左边界下标\n计算中间位置下标 mid\n如果中间位置下标对应的值等于 mid，说明左侧没有缺失数，从 mid+1 开始向右查找\n如果中间位置下标对应的值不等于 mid，说明左侧可能存在缺失数，从 left_element 开始向 mid-1 查找\n"}
{"prompt": "Write a function to sort a given list of elements in ascending order using heap queue algorithm.", "canonical_solution": "import heapq as hq\r\ndef heap_assending(nums):\r\n  hq.heapify(nums)\r\n  s_result = [hq.heappop(nums) for i in range(len(nums))]\r\n  return s_result", "task_id": "Python/372", "test_setup": "", "test": ["assert heap_assending([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1])==[1, 2, 3, 4, 7, 8, 9, 9, 10, 14, 18]", "assert heap_assending([25, 35, 22, 85, 14, 65, 75, 25, 58])==[14, 22, 25, 25, 35, 58, 65, 75, 85]", "assert heap_assending([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"], "challenge_test_list": [], "func_title": "def heap_assending(nums):\r", "prompt_text_chinese": "写一个函数，用堆队列算法对一个给定的元素列表按升序排序。", "code_comment": "导入 heapq 模块，并将其命名为 hq\n定义一个函数 heap_assending，接收一个参数 nums，该参数是一个列表\n将 nums 转为最小堆\n从最小堆中取出元素，并按照升序排序，结果赋值给 s_result\n返回排序后的列表 s_result\n"}
{"prompt": "Write a function to find the volume of a cuboid.", "canonical_solution": "def volume_cuboid(l,w,h):\r\n  volume=l*w*h\r\n  return volume", "task_id": "Python/373", "test_setup": "", "test": ["assert volume_cuboid(1,2,3)==6", "assert volume_cuboid(5,7,9)==315", "assert volume_cuboid(10,15,21)==3150"], "challenge_test_list": [], "func_title": "def volume_cuboid(l,w,h):\r", "prompt_text_chinese": "写一个函数来寻找长方体的体积。", "code_comment": "定义一个函数 volume_cuboid，接收三个参数 l、w、h，分别代表长、宽、高\n计算长方体的体积，并赋值给 volume\n返回体积 volume\n"}
{"prompt": "Write a function to print all permutations of a given string including duplicates.", "canonical_solution": "def permute_string(str):\r\n    if len(str) == 0:\r\n        return ['']\r\n    prev_list = permute_string(str[1:len(str)])\r\n    next_list = []\r\n    for i in range(0,len(prev_list)):\r\n        for j in range(0,len(str)):\r\n            new_str = prev_list[i][0:j]+str[0]+prev_list[i][j:len(str)-1]\r\n            if new_str not in next_list:\r\n                next_list.append(new_str)\r\n    return next_list", "task_id": "Python/374", "test_setup": "", "test": ["assert permute_string('ab')==['ab', 'ba']", "assert permute_string('abc')==['abc', 'bac', 'bca', 'acb', 'cab', 'cba']", "assert permute_string('abcd')==['abcd', 'bacd', 'bcad', 'bcda', 'acbd', 'cabd', 'cbad', 'cbda', 'acdb', 'cadb', 'cdab', 'cdba', 'abdc', 'badc', 'bdac', 'bdca', 'adbc', 'dabc', 'dbac', 'dbca', 'adcb', 'dacb', 'dcab', 'dcba']"], "challenge_test_list": [], "func_title": "def permute_string(str):\r", "prompt_text_chinese": "写一个函数来打印一个给定字符串的所有排列组合，包括重复的排列组合。", "code_comment": "定义一个函数 permute_string，接收一个参数 str，该参数代表要进行全排列的字符串\n如果字符串为空，返回一个包含空字符串的列表\n递归调用 permute_string 函数，返回 str[1:] 的全排列列表，并赋值给 prev_list\n定义一个空列表 next_list\n遍历 prev_list 中的每一个元素\n遍历字符串 str 中的每一个字符\n构造一个新的字符串 new_str，将 str 中的第 j 个字符插入到 prev_list[i] 的各个位置中得到\n如果新构造的字符串不在 next_list 中，就将其添加到 next_list 中\n返回包含所有排列结果的列表 next_list\n"}
{"prompt": "Write a function to round the given number to the nearest multiple of a specific number.", "canonical_solution": "def round_num(n,m):\r\n    a = (n //m) * m\r\n    b = a + m\r\n    return (b if n - a > b - n else a)", "task_id": "Python/375", "test_setup": "", "test": ["assert round_num(4722,10)==4720", "assert round_num(1111,5)==1110", "assert round_num(219,2)==218"], "challenge_test_list": [], "func_title": "def round_num(n,m):\r", "prompt_text_chinese": "写一个函数，将给定的数字四舍五入到一个特定数字的最近倍数。", "code_comment": "定义一个函数 round_num，接收两个参数 n 和 m，其中 n 和 m 都是整数\n计算 n 除以 m 的商并向下取整，再乘以 m 得到 a\n计算 a 加上 m 得到 b\n如果 n 减去 a 的结果大于 b 减去 n 的结果，返回 b，否则返回 a\n"}
{"prompt": "Write a function to remove tuple elements that occur more than once and replace the duplicates with some custom value.", "canonical_solution": "def remove_replica(test_tup):\r\n  temp = set()\r\n  res = tuple(ele if ele not in temp and not temp.add(ele) \r\n\t\t\t\telse 'MSP' for ele in test_tup)\r\n  return (res)", "task_id": "Python/376", "test_setup": "", "test": ["assert remove_replica((1, 1, 4, 4, 4, 5, 5, 6, 7, 7)) == (1, 'MSP', 4, 'MSP', 'MSP', 5, 'MSP', 6, 7, 'MSP')", "assert remove_replica((2, 3, 4, 4, 5, 6, 6, 7, 8, 9, 9)) == (2, 3, 4, 'MSP', 5, 6, 'MSP', 7, 8, 9, 'MSP')", "assert remove_replica((2, 2, 5, 4, 5, 7, 5, 6, 7, 7)) == (2, 'MSP', 5, 4, 'MSP', 7, 'MSP', 6, 'MSP', 'MSP')"], "challenge_test_list": [], "func_title": "def remove_replica(test_tup):\r", "prompt_text_chinese": "写一个函数，删除出现过一次以上的元组元素，并用一些自定义的值来替换重复的元素。", "code_comment": "定义一个函数 remove_replica，接收一个参数 test_tup，该参数是一个元组\n创建一个空集合 temp\n遍历元组中的每个元素，如果不在 temp 中，就将其添加到 temp 中，并加入结果元组 res 中；\n如果已经在 temp 中，就将 'MSP' 加入结果元组 res 中\n返回去重后的元组 res\n"}
{"prompt": "Write a python function to remove all occurrences of a character in a given string.", "canonical_solution": "def remove_Char(s,c) :  \r\n    counts = s.count(c) \r\n    s = list(s) \r\n    while counts :  \r\n        s.remove(c) \r\n        counts -= 1 \r\n    s = '' . join(s)   \r\n    return (s) ", "task_id": "Python/377", "test_setup": "", "test": ["assert remove_Char(\"aba\",'a') == \"b\"", "assert remove_Char(\"toggle\",'g') == \"tole\"", "assert remove_Char(\"aabbc\",'b') == \"aac\""], "challenge_test_list": [], "func_title": "def remove_Char(s,c) :  \r", "prompt_text_chinese": "编写一个Python函数，删除给定字符串中的所有字符的出现次数。", "code_comment": "定义一个函数 remove_Char，接收两个参数 s 和 c，其中 s 是一个字符串，c 是一个要删除的字符\n计算 s 中 c 出现的次数\n将 s 转为列表\n循环将 c 从 s 中删除，直到 counts 为 0\n将列表 s 转为字符串\n返回删除后的字符串 s\n"}
{"prompt": "Write a python function to shift last element to first position in the given list.", "canonical_solution": "def move_first(test_list):\r\n  test_list = test_list[-1:] + test_list[:-1]  \r\n  return test_list", "task_id": "Python/378", "test_setup": "", "test": ["assert move_first([1,2,3,4]) == [4,1,2,3]", "assert move_first([0,1,2,3]) == [3,0,1,2]", "assert move_first([9,8,7,1]) == [1,9,8,7]"], "challenge_test_list": [], "func_title": "def move_first(test_list):\r", "prompt_text_chinese": "写一个Python函数，将给定列表中的最后一个元素转移到第一个位置。", "code_comment": "定义一个函数 move_first，接收一个参数 test_list，该参数是一个列表\n将 test_list 的最后一个元素移到列表的第一个位置\n返回移动后的列表\n"}
{"prompt": "Write a function to find the surface area of a cuboid.", "canonical_solution": "def surfacearea_cuboid(l,w,h):\r\n  SA = 2*(l*w + l * h + w * h)\r\n  return SA", "task_id": "Python/379", "test_setup": "", "test": ["assert surfacearea_cuboid(1,2,3)==22", "assert surfacearea_cuboid(5,7,9)==286", "assert surfacearea_cuboid(10,15,21)==1350"], "challenge_test_list": [], "func_title": "def surfacearea_cuboid(l,w,h):\r", "prompt_text_chinese": "写一个函数来求一个长方体的表面积。", "code_comment": "定义一个函数 surfacearea_cuboid，接收三个参数 l、w、h，分别代表长、宽、高\n计算长方体的表面积，并赋值给 SA\n返回表面积 SA\n"}
{"prompt": "Write a function to generate a two-dimensional array.", "canonical_solution": "def multi_list(rownum,colnum):\r\n  multi_list = [[0 for col in range(colnum)] for row in range(rownum)]\r\n  for row in range(rownum):\r\n    for col in range(colnum):\r\n        multi_list[row][col]= row*col\r\n  return multi_list\r\n", "task_id": "Python/380", "test_setup": "", "test": ["assert multi_list(3,4)==[[0, 0, 0, 0], [0, 1, 2, 3], [0, 2, 4, 6]] ", "assert multi_list(5,7)==[[0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6], [0, 2, 4, 6, 8, 10, 12], [0, 3, 6, 9, 12, 15, 18], [0, 4, 8, 12, 16, 20, 24]]", "assert multi_list(10,15)==[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28], [0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42], [0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56], [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70], [0, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84], [0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91, 98], [0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112], [0, 9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99, 108, 117, 126]]"], "challenge_test_list": [], "func_title": "def multi_list(rownum,colnum):\r", "prompt_text_chinese": "写一个函数来生成一个二维数组。", "code_comment": "定义一个函数 multi_list，接收两个参数 rownum 和 colnum，分别代表行数和列数\n创建一个 rownum 行，colnum 列的二维列表 multi_list，所有元素都初始化为 0\n将 multi_list 中每个元素赋值为其所在行号和列号的乘积\n返回乘积列表 multi_list\n"}
{"prompt": "Write a function to sort a list of lists by a given index of the inner list.", "canonical_solution": "from operator import itemgetter\r\ndef index_on_inner_list(list_data, index_no):\r\n    result = sorted(list_data, key=itemgetter(index_no))\r\n    return result", "task_id": "Python/381", "test_setup": "", "test": ["assert index_on_inner_list([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,0)==[('Beau Turnbull', 94, 98), ('Brady Kent', 97, 96), ('Greyson Fulton', 98, 99), ('Wyatt Knott', 91, 94)]", "assert index_on_inner_list([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,1)==[('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98), ('Brady Kent', 97, 96), ('Greyson Fulton', 98, 99)]", "assert index_on_inner_list([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,2)==[('Wyatt Knott', 91, 94), ('Brady Kent', 97, 96), ('Beau Turnbull', 94, 98), ('Greyson Fulton', 98, 99)]"], "challenge_test_list": [], "func_title": "def index_on_inner_list(list_data, index_no):\r", "prompt_text_chinese": "写一个函数，按内部列表的给定索引对列表进行排序。", "code_comment": "从 operator 模块中导入 itemgetter 函数\n定义一个函数 index_on_inner_list，接收两个参数 list_data 和 index_no，其中 list_data 是一个列表，\n其中每个元素都是一个列表，index_no 是内部列表中要排序的索引\n调用 sorted 函数按照内部列表中的指定索引进行排序，排序结果赋值给 result\n返回排序后的列表 result\n"}
{"prompt": "Write a function to find the number of rotations in a circularly sorted array.", "canonical_solution": "def find_rotation_count(A):\r\n    (left, right) = (0, len(A) - 1)\r\n    while left <= right:\r\n        if A[left] <= A[right]:\r\n            return left\r\n        mid = (left + right) // 2\r\n        next = (mid + 1) % len(A)\r\n        prev = (mid - 1 + len(A)) % len(A)\r\n        if A[mid] <= A[next] and A[mid] <= A[prev]:\r\n            return mid\r\n        elif A[mid] <= A[right]:\r\n            right = mid - 1\r\n        elif A[mid] >= A[left]:\r\n            left = mid + 1\r\n    return -1", "task_id": "Python/382", "test_setup": "", "test": ["assert find_rotation_count([8, 9, 10, 1, 2, 3, 4, 5, 6, 7]) == 3", "assert find_rotation_count([8, 9, 10,2, 5, 6]) == 3", "assert find_rotation_count([2, 5, 6, 8, 9, 10]) == 0"], "challenge_test_list": [], "func_title": "def find_rotation_count(A):\r", "prompt_text_chinese": "写一个函数，找出循环排序的数组中的旋转次数。", "code_comment": "定义一个函数 find_rotation_count，接收一个参数 A，该参数是一个列表\n定义变量 left 和 right，分别表示旋转的左右两个端点\n如果最左侧元素小于等于最右侧元素，说明列表已经按照升序排列，返回 left\n计算 mid 为 left 和 right 的平均数\n计算 mid 的下一个元素和上一个元素的位置\n如果 mid 是一个局部最小值，返回 mid\n如果 mid 右侧的元素比 mid 小，说明最小值在左侧，将 right 更新为 mid - 1\n如果 mid 左侧的元素比 mid 大，说明最小值在右侧，将 left 更新为 mid + 1\n如果循环结束还没有找到局部最小值，返回 -1\n"}
{"prompt": "Write a python function to toggle all odd bits of a given number.", "canonical_solution": "def even_bit_toggle_number(n) : \r\n    res = 0; count = 0; temp = n    \r\n    while(temp > 0 ) : \r\n        if (count % 2 == 0) : \r\n            res = res | (1 << count)      \r\n        count = count + 1\r\n        temp >>= 1 \r\n    return n ^ res ", "task_id": "Python/383", "test_setup": "", "test": ["assert even_bit_toggle_number(10) == 15", "assert even_bit_toggle_number(20) == 1", "assert even_bit_toggle_number(30) == 11"], "challenge_test_list": [], "func_title": "def even_bit_toggle_number(n) : \r", "prompt_text_chinese": "写一个python函数来切换一个给定数字的所有奇数位。", "code_comment": "定义一个函数 even_bit_toggle_number，接收一个参数 n，该参数是一个整数\n对 n 的每一位进行处理\n如果当前位是偶数位，将 res 的第 count 位置为 1\n将 temp 右移一位\n将 n 和 res 逐位异或，得到每个奇数位上的位相反、偶数位上的位不变的数\n"}
{"prompt": "Write a python function to find the frequency of the smallest value in a given array.", "canonical_solution": "def frequency_Of_Smallest(n,arr): \r\n    mn = arr[0] \r\n    freq = 1\r\n    for i in range(1,n): \r\n        if (arr[i] < mn): \r\n            mn = arr[i] \r\n            freq = 1\r\n        elif (arr[i] == mn): \r\n            freq += 1\r\n    return freq ", "task_id": "Python/384", "test_setup": "", "test": ["assert frequency_Of_Smallest(5,[1,2,3,4,3]) == 1", "assert frequency_Of_Smallest(7,[3,1,2,5,6,2,3]) == 1", "assert frequency_Of_Smallest(7,[3,3,6,3,7,4,9]) == 3"], "challenge_test_list": [], "func_title": "def frequency_Of_Smallest(n,arr): \r", "prompt_text_chinese": "写一个python函数来查找给定数组中最小值的频率。", "code_comment": "定义一个函数 frequency_Of_Smallest，接收两个参数 n 和 arr，其中 n 是一个整数，arr 是一个整数列表\n初始化 mn 为列表的第一个元素\n初始化 freq 为 1\n遍历列表 arr，找到最小值，并计算最小值出现的频率\n返回最小值出现的频率 freq\n"}
{"prompt": "Write a function to find the n'th perrin number using recursion.", "canonical_solution": "def get_perrin(n):\r\n  if (n == 0):\r\n    return 3\r\n  if (n == 1):\r\n    return 0\r\n  if (n == 2):\r\n    return 2 \r\n  return get_perrin(n - 2) + get_perrin(n - 3)", "task_id": "Python/385", "test_setup": "", "test": ["assert get_perrin(9) == 12", "assert get_perrin(4) == 2", "assert get_perrin(6) == 5"], "challenge_test_list": [], "func_title": "def get_perrin(n):\r", "prompt_text_chinese": "写一个函数，用递归法找到第n个佩林数。", "code_comment": "定义一个函数 get_perrin，接收一个参数 n，该参数是一个整数\n当 n 等于 0 时，返回 3\n当 n 等于 1 时，返回 0\n当 n 等于 2 时，返回 2\n当 n 大于 2 时，递归调用 get_perrin 函数，并返回 get_perrin(n - 2) + get_perrin(n - 3) 的结果\n"}
{"prompt": "Write a function to find out the minimum no of swaps required for bracket balancing in the given string.", "canonical_solution": "def swap_count(s):\r\n\tchars = s\r\n\tcount_left = 0\r\n\tcount_right = 0\r\n\tswap = 0\r\n\timbalance = 0; \r\n\tfor i in range(len(chars)):\r\n\t\tif chars[i] == '[':\r\n\t\t\tcount_left += 1\r\n\t\t\tif imbalance > 0:\r\n\t\t\t\tswap += imbalance\r\n\t\t\t\timbalance -= 1\r\n\t\telif chars[i] == ']':\r\n\t\t\tcount_right += 1\r\n\t\t\timbalance = (count_right - count_left) \r\n\treturn swap", "task_id": "Python/386", "test_setup": "", "test": ["assert swap_count(\"[]][][\") == 2", "assert swap_count(\"[[][]]\") == 0", "assert swap_count(\"[[][]]][\") == 1"], "challenge_test_list": [], "func_title": "def swap_count(s):\r", "prompt_text_chinese": "写一个函数，找出给定字符串中括号平衡所需的最小互换次数。", "code_comment": "定义一个函数 swap_count，接收一个参数 s，该参数是一个字符串\n将字符串赋值给 chars\n初始化 count_left 为 0\n初始化 count_right 为 0\n初始化 swap 为 0\n初始化 imbalance 为 0\n如果当前字符是 '['，count_left 加 1\n如果当前字符之前有未匹配的 ']'，则进行交换，并将 imbalance 减 1\n如果当前字符是 ']'，count_right 加 1\n计算当前右括号和左括号的差值，作为 imbalance\n返回最小交换次数\n"}
{"prompt": "Write a python function to check whether the hexadecimal number is even or odd.", "canonical_solution": "def even_or_odd(N): \r\n    l = len(N) \r\n    if (N[l-1] =='0'or N[l-1] =='2'or \r\n        N[l-1] =='4'or N[l-1] =='6'or \r\n        N[l-1] =='8'or N[l-1] =='A'or \r\n        N[l-1] =='C'or N[l-1] =='E'): \r\n        return (\"Even\") \r\n    else: \r\n        return (\"Odd\") ", "task_id": "Python/387", "test_setup": "", "test": ["assert even_or_odd(\"AB3454D\") ==\"Odd\"", "assert even_or_odd(\"ABC\") == \"Even\"", "assert even_or_odd(\"AAD\") == \"Odd\""], "challenge_test_list": [], "func_title": "def even_or_odd(N): \r", "prompt_text_chinese": "写一个python函数来检查十六进制数字是偶数还是奇数。", "code_comment": "定义一个函数 even_or_odd，接收一个参数 N，该参数是一个字符串\n获取字符串 N 的长度 l\n如果 N 的最后一位是 0、2、4、6、8、A、C、E 中的一个，返回 \"Even\"\n否则返回 \"Odd\"\n"}
{"prompt": "Write a python function to find the highest power of 2 that is less than or equal to n.", "canonical_solution": "def highest_Power_of_2(n): \r\n    res = 0; \r\n    for i in range(n, 0, -1): \r\n        if ((i & (i - 1)) == 0): \r\n            res = i; \r\n            break; \r\n    return res; ", "task_id": "Python/388", "test_setup": "", "test": ["assert highest_Power_of_2(10) == 8", "assert highest_Power_of_2(19) == 16", "assert highest_Power_of_2(32) == 32"], "challenge_test_list": [], "func_title": "def highest_Power_of_2(n): \r", "prompt_text_chinese": "写一个python函数，找出小于或等于n的2的最高次幂。", "code_comment": "定义一个函数 highest_Power_of_2，接收一个参数 n，该参数是一个整数\n初始化 res 为 0\n从 n 开始递减遍历\n如果 i & (i - 1) 的值为 0，说明 i 是 2 的幂，将 res 赋值为 i 并跳出循环\n返回 2 的最高幂次方\n"}
{"prompt": "Write a function to find the n'th lucas number.", "canonical_solution": "def find_lucas(n): \r\n\tif (n == 0): \r\n\t\treturn 2\r\n\tif (n == 1): \r\n\t\treturn 1\r\n\treturn find_lucas(n - 1) + find_lucas(n - 2) ", "task_id": "Python/389", "test_setup": "", "test": ["assert find_lucas(9) == 76", "assert find_lucas(4) == 7", "assert find_lucas(3) == 4"], "challenge_test_list": [], "func_title": "def find_lucas(n): \r", "prompt_text_chinese": "写一个函数来寻找第n个卢卡斯数。", "code_comment": "定义一个函数 find_lucas，接收一个参数 n，该参数是一个整数\n如果 n 等于 0，返回 2\n如果 n 等于 1，返回 1\n如果 n 大于 1，递归调用 find_lucas(n - 1) 和 find_lucas(n - 2)，并返回它们的和\n"}
{"prompt": "Write a function to insert a given string at the beginning of all items in a list.", "canonical_solution": "def add_string(list,string):\r\n add_string=[string.format(i) for i in  list]\r\n return add_string", "task_id": "Python/390", "test_setup": "", "test": ["assert add_string([1,2,3,4],'temp{0}')==['temp1', 'temp2', 'temp3', 'temp4']", "assert add_string(['a','b','c','d'], 'python{0}')==[ 'pythona', 'pythonb', 'pythonc', 'pythond']", "assert add_string([5,6,7,8],'string{0}')==['string5', 'string6', 'string7', 'string8']"], "challenge_test_list": [], "func_title": "def add_string(list,string):\r", "prompt_text_chinese": "写一个函数，在一个列表的所有项目的开头插入一个给定的字符串。", "code_comment": "定义一个函数 add_string，接收两个参数 list 和 string，其中 list 是一个列表，string 是一个字符串模板\n对列表 list 中的每个元素进行操作，将字符串模板 string 中的占位符用元素的值替换\n返回替换后的列表\n"}
{"prompt": "Write a function to convert more than one list to nested dictionary.", "canonical_solution": "def convert_list_dictionary(l1, l2, l3):\r\n     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]\r\n     return result", "task_id": "Python/391", "test_setup": "", "test": ["assert convert_list_dictionary([\"S001\", \"S002\", \"S003\", \"S004\"],[\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"] ,[85, 98, 89, 92])==[{'S001': {'Adina Park': 85}}, {'S002': {'Leyton Marsh': 98}}, {'S003': {'Duncan Boyle': 89}}, {'S004': {'Saim Richards': 92}}]", "assert convert_list_dictionary([\"abc\",\"def\",\"ghi\",\"jkl\"],[\"python\",\"program\",\"language\",\"programs\"],[100,200,300,400])==[{'abc':{'python':100}},{'def':{'program':200}},{'ghi':{'language':300}},{'jkl':{'programs':400}}]", "assert convert_list_dictionary([\"A1\",\"A2\",\"A3\",\"A4\"],[\"java\",\"C\",\"C++\",\"DBMS\"],[10,20,30,40])==[{'A1':{'java':10}},{'A2':{'C':20}},{'A3':{'C++':30}},{'A4':{'DBMS':40}}]"], "challenge_test_list": [], "func_title": "def convert_list_dictionary(l1, l2, l3):\r", "prompt_text_chinese": "写一个函数，将一个以上的列表转换为嵌套字典。", "code_comment": "定义一个函数 convert_list_dictionary，接收三个参数 l1、l2、l3，分别是三个列表\n使用 zip 函数将 l1、l2、l3 中相同位置的元素组合成一个元组，然后遍历这些元组，将其转换为字典的形式并存入列表 result 中\n返回转换后的列表 result\n"}
{"prompt": "Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).", "canonical_solution": "def get_max_sum (n):\r\n\tres = list()\r\n\tres.append(0)\r\n\tres.append(1)\r\n\ti = 2\r\n\twhile i<n + 1:\r\n\t\tres.append(max(i, (res[int(i / 2)] \r\n\t\t\t\t\t\t+ res[int(i / 3)] +\r\n\t\t\t\t\t\t\tres[int(i / 4)]\r\n\t\t\t\t\t\t+ res[int(i / 5)])))\r\n\t\ti = i + 1\r\n\treturn res[n]", "task_id": "Python/392", "test_setup": "", "test": ["assert get_max_sum(60) == 106", "assert get_max_sum(10) == 12", "assert get_max_sum(2) == 2"], "challenge_test_list": [], "func_title": "def get_max_sum (n):\r", "prompt_text_chinese": "写一个函数，通过使用给定的方程f(n)=max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)找到可能的最大和。", "code_comment": "定义一个函数 get_max_sum，接收一个参数 n，该参数是一个整数\n创建一个空列表 res\n将 0 添加到列表 res 中\n将 1 添加到列表 res 中\n初始化 i 为 2\n当 i 小于等于 n 时，遍历列表并计算每个元素的最大值，并将最大值添加到列表 res 中\ni 加 1\n返回列表 res 的第 n 个元素\n"}
{"prompt": "Write a function to find the list with maximum length using lambda function.", "canonical_solution": "def max_length_list(input_list):\r\n    max_length = max(len(x) for x in input_list )   \r\n    max_list = max(input_list, key = lambda i: len(i))    \r\n    return(max_length, max_list)", "task_id": "Python/393", "test_setup": "", "test": ["assert max_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])", "assert max_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(5,[1,2,3,4,5])", "assert max_length_list([[3,4,5],[6,7,8,9],[10,11,12]])==(4,[6,7,8,9])"], "challenge_test_list": [], "func_title": "def max_length_list(input_list):\r", "prompt_text_chinese": "写一个函数，用lambda函数找出具有最大长度的列表。", "code_comment": "定义一个函数 max_length_list，接收一个参数 input_list，该参数是一个列表\n计算列表中元素的最大长度\n找到最长的列表\n返回最大长度和最长的列表\n"}
{"prompt": "Write a function to check if given tuple is distinct or not.", "canonical_solution": "def check_distinct(test_tup):\r\n  res = True\r\n  temp = set()\r\n  for ele in test_tup:\r\n    if ele in temp:\r\n      res = False\r\n      break\r\n    temp.add(ele)\r\n  return (res) ", "task_id": "Python/394", "test_setup": "", "test": ["assert check_distinct((1, 4, 5, 6, 1, 4)) == False", "assert check_distinct((1, 4, 5, 6)) == True", "assert check_distinct((2, 3, 4, 5, 6)) == True"], "challenge_test_list": [], "func_title": "def check_distinct(test_tup):\r", "prompt_text_chinese": "写一个函数来检查给定的元组是否是独立的。", "code_comment": "定义一个函数 check_distinct，接收一个参数 test_tup，该参数是一个元组\n初始化 res 为 True\n创建一个空集合 temp\n遍历元组 test_tup 中的每个元素，如果该元素已经存在于集合 temp 中，则将 res 设置为 False，并跳出循环\n将元素加入集合 temp 中\n返回 res 的值\n"}
{"prompt": "Write a python function to find the first non-repeated character in a given string.", "canonical_solution": "def first_non_repeating_character(str1):\r\n  char_order = []\r\n  ctr = {}\r\n  for c in str1:\r\n    if c in ctr:\r\n      ctr[c] += 1\r\n    else:\r\n      ctr[c] = 1 \r\n      char_order.append(c)\r\n  for c in char_order:\r\n    if ctr[c] == 1:\r\n      return c\r\n  return None", "task_id": "Python/395", "test_setup": "", "test": ["assert first_non_repeating_character(\"abcabc\") == None", "assert first_non_repeating_character(\"abc\") == \"a\"", "assert first_non_repeating_character(\"ababc\") == \"c\""], "challenge_test_list": [], "func_title": "def first_non_repeating_character(str1):\r", "prompt_text_chinese": "写一个Python函数来查找给定字符串中第一个不重复的字符。", "code_comment": "定义一个函数 first_non_repeating_character，接收一个参数 str1，该参数是一个字符串\n创建一个空列表 char_order，用于记录字符串中出现的字符的顺序\n创建一个空字典 ctr，用于记录字符串中每个字符出现的次数\n遍历字符串 str1 中的每个字符，如果该字符在 ctr 中已经存在，则将其出现次数加 1，否则将其出现次数初始化为 1，并将其添加到 char_order 中\n遍历 char_order 中的每个字符，如果该字符在 ctr 中的出现次数为 1，则返回该字符\n如果没有找到只出现一次的字符，则返回 None\n"}
{"prompt": "Write a function to check whether the given string starts and ends with the same character or not using regex.", "canonical_solution": "import re  \r\nregex = r'^[a-z]$|^([a-z]).*\\1$'\r\ndef check_char(string): \r\n\tif(re.search(regex, string)): \r\n\t\treturn \"Valid\" \r\n\telse: \r\n\t\treturn \"Invalid\" ", "task_id": "Python/396", "test_setup": "", "test": ["assert check_char(\"abba\") == \"Valid\"", "assert check_char(\"a\") == \"Valid\"", "assert check_char(\"abcd\") == \"Invalid\""], "challenge_test_list": [], "func_title": "def check_char(string): \r", "prompt_text_chinese": "写一个函数，用regex检查给定的字符串是否以相同的字符开始和结束。", "code_comment": "导入 re 模块\n定义一个正则表达式，用于匹配只有一个小写字母或者包含重复字母的字符串\n"}
{"prompt": "Write a function to find the median of three specific numbers.", "canonical_solution": "def median_numbers(a,b,c):\r\n if a > b:\r\n    if a < c:\r\n        median = a\r\n    elif b > c:\r\n        median = b\r\n    else:\r\n        median = c\r\n else:\r\n    if a > c:\r\n        median = a\r\n    elif b < c:\r\n        median = b\r\n    else:\r\n        median = c\r\n return median", "task_id": "Python/397", "test_setup": "", "test": ["assert median_numbers(25,55,65)==55.0", "assert median_numbers(20,10,30)==20.0", "assert median_numbers(15,45,75)==45.0"], "challenge_test_list": [], "func_title": "def median_numbers(a,b,c):\r", "prompt_text_chinese": "写一个函数来寻找三个特定数字的中位数。", "code_comment": "定义一个函数 median_numbers，接收三个参数 a、b、c，这三个参数都是整数\n如果 a 大于 b，则比较 a 和 c，如果 a 小于 c，则将 a 赋值给 median；如果 b 大于 c，则将 b 赋值给 median；否则将 c 赋值给 median\n如果 a 不大于 b，则比较 a 和 c，如果 a 大于 c，则将 a 赋值给 median；如果 b 小于 c，则将 b 赋值给 median；否则将 c 赋值给 median\n返回 median 的值\n"}
{"prompt": "Write a function to compute the sum of digits of each number of a given list.", "canonical_solution": "def sum_of_digits(nums):\r\n    return sum(int(el) for n in nums for el in str(n) if el.isdigit())", "task_id": "Python/398", "test_setup": "", "test": ["assert sum_of_digits([10,2,56])==14", "assert sum_of_digits([[10,20,4,5,'b',70,'a']])==19", "assert sum_of_digits([10,20,-4,5,-70])==19"], "challenge_test_list": [], "func_title": "def sum_of_digits(nums):\r", "prompt_text_chinese": "写一个函数来计算一个给定列表中每个数字的位数之和。", "code_comment": "定义一个函数 sum_of_digits，接收一个参数 nums，该参数是一个列表，列表中的元素都是整数\n使用两个 for 循环和一个条件判断，将列表中所有整数的各个位上的数字相加\n"}
{"prompt": "Write a function to perform the mathematical bitwise xor operation across the given tuples.", "canonical_solution": "def bitwise_xor(test_tup1, test_tup2):\r\n  res = tuple(ele1 ^ ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res) ", "task_id": "Python/399", "test_setup": "", "test": ["assert bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)", "assert bitwise_xor((11, 5, 7, 10), (6, 3, 4, 4)) == (13, 6, 3, 14)", "assert bitwise_xor((12, 6, 8, 11), (7, 4, 5, 6)) == (11, 2, 13, 13)"], "challenge_test_list": [], "func_title": "def bitwise_xor(test_tup1, test_tup2):\r", "prompt_text_chinese": "写一个函数，在给定的图元中进行数学上的位xor操作。", "code_comment": "定义一个函数 bitwise_xor，接收两个参数 test_tup1 和 test_tup2，这两个参数都是元组\n使用 zip 函数将两个元组中相同位置的元素组合成一个元组，然后使用按位异或运算符 ^ 对它们进行计算，并将计算结果存入一个新的元组 res 中\n返回新的元组 res\n"}
{"prompt": "Write a function to extract the frequency of unique tuples in the given list order irrespective.", "canonical_solution": "def extract_freq(test_list):\r\n  res = len(list(set(tuple(sorted(sub)) for sub in test_list)))\r\n  return (res)", "task_id": "Python/400", "test_setup": "", "test": ["assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3", "assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4", "assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4"], "challenge_test_list": [], "func_title": "def extract_freq(test_list):\r", "prompt_text_chinese": "写一个函数来提取给定列表中唯一图元的频率，而不论其顺序。", "code_comment": "定义一个函数 extract_freq，接收一个参数 test_list，该参数是一个列表，列表中的元素也是列表\n使用列表解析式和 set 函数，将列表中的每个子列表进行排序后，去除重复后，存入一个新的列表中，并返回列表的长度\n返回新列表的长度"}
{"prompt": "Write a function to perform index wise addition of tuple elements in the given two nested tuples.", "canonical_solution": "def add_nested_tuples(test_tup1, test_tup2):\r\n  res = tuple(tuple(a + b for a, b in zip(tup1, tup2))\r\n   for tup1, tup2 in zip(test_tup1, test_tup2))\r\n  return (res) ", "task_id": "Python/401", "test_setup": "", "test": ["assert add_nested_tuples(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((7, 10), (7, 14), (3, 10), (8, 13))", "assert add_nested_tuples(((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) == ((9, 12), (9, 16), (5, 12), (10, 15))", "assert add_nested_tuples(((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) == ((11, 14), (11, 18), (7, 14), (12, 17))"], "challenge_test_list": [], "func_title": "def add_nested_tuples(test_tup1, test_tup2):\r", "prompt_text_chinese": "写一个函数，对给定的两个嵌套图元中的图元执行索引加法。", "code_comment": "定义一个函数 add_nested_tuples，接收两个参数 test_tup1 和 test_tup2，这两个参数都是由元组嵌套而成的元组\n使用 zip 函数将两个元组中相同位置的元素组合成一个元组，然后使用列表解析式和 zip 函数将每个元组中相同位置的元素相加，并存入一个新的元组中\n返回新的元组"}
{"prompt": "Write a function to compute the value of ncr%p.", "canonical_solution": "def ncr_modp(n, r, p): \r\n    C = [0 for i in range(r+1)]   \r\n    C[0] = 1\r\n    for i in range(1, n+1): \r\n        for j in range(min(i, r), 0, -1): \r\n            C[j] = (C[j] + C[j-1]) % p   \r\n    return C[r] ", "task_id": "Python/402", "test_setup": "", "test": ["assert ncr_modp(10,2,13)==6", "assert ncr_modp(15,12,43)==25", "assert ncr_modp(17,9,18)==10"], "challenge_test_list": [], "func_title": "def ncr_modp(n, r, p): \r", "prompt_text_chinese": "写一个函数来计算ncr%p的值。", "code_comment": "定义一个函数 ncr_modp，接收三个参数 n、r、p，这三个参数都是整数\n创建一个长度为 r+1 的列表 C，列表中的每个元素都是 0\n将列表 C 的第一个元素设置为 1\n使用两个 for 循环，计算组合数 C[i][j]，并将其存入列表 C 的第 j 个元素中\n返回 C[r] 的值"}
{"prompt": "Write a function to check if a url is valid or not using regex.", "canonical_solution": "import re\r\ndef is_valid_URL(str):\r\n\tregex = (\"((http|https)://)(www.)?\" +\r\n\t\t\t\"[a-zA-Z0-9@:%._\\\\+~#?&//=]\" +\r\n\t\t\t\"{2,256}\\\\.[a-z]\" +\r\n\t\t\t\"{2,6}\\\\b([-a-zA-Z0-9@:%\" +\r\n\t\t\t\"._\\\\+~#?&//=]*)\")\r\n\tp = re.compile(regex)\r\n\tif (str == None):\r\n\t\treturn False\r\n\tif(re.search(p, str)):\r\n\t\treturn True\r\n\telse:\r\n\t\treturn False", "task_id": "Python/403", "test_setup": "", "test": ["assert is_valid_URL(\"https://www.google.com\") == True", "assert is_valid_URL(\"https:/www.gmail.com\") == False", "assert is_valid_URL(\"https:// www.redit.com\") == False"], "challenge_test_list": [], "func_title": "def is_valid_URL(str):\r", "prompt_text_chinese": "写一个函数，使用regex检查一个url是否有效。", "code_comment": "导入 re 模块\n定义一个函数 is_valid_URL，接收一个参数 str，该参数是一个字符串\n定义一个正则表达式 regex，用于匹配 URL，该正则表达式中包含了协议、域名、路径等信息\n使用 re.compile 函数编译正则表达式\n如果参数 str 为 None，则返回 False\n如果参数 str 匹配正则表达式，则返回 True，否则返回 False\n"}
{"prompt": "Write a python function to find the minimum of two numbers.", "canonical_solution": "def minimum(a,b):   \r\n    if a <= b: \r\n        return a \r\n    else: \r\n        return b ", "task_id": "Python/404", "test_setup": "", "test": ["assert minimum(1,2) == 1", "assert minimum(-5,-4) == -5", "assert minimum(0,0) == 0"], "challenge_test_list": [], "func_title": "def minimum(a,b):   \r", "prompt_text_chinese": "写一个Python函数来寻找两个数字的最小值。", "code_comment": "定义一个函数 minimum，接收两个参数 a 和 b，这两个参数都是整数\n如果 a 小于等于 b，则返回 a，否则返回 b\n"}
{"prompt": "Write a function to check whether an element exists within a tuple.", "canonical_solution": "def check_tuplex(tuplex,tuple1): \r\n  if tuple1 in tuplex:\r\n    return True\r\n  else:\r\n     return False", "task_id": "Python/405", "test_setup": "", "test": ["assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),'r')==True", "assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),'5')==False", "assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\",\"e\"),3)==True"], "challenge_test_list": [], "func_title": "def check_tuplex(tuplex,tuple1): \r", "prompt_text_chinese": "写一个函数来检查一个元素是否存在于一个元组中。", "code_comment": "定义一个函数 check_tuplex，接收两个参数 tuplex 和 tuple1，这两个参数都是元组\n如果 tuple1 在 tuplex 中，则返回 True，否则返回 False\n"}
{"prompt": "Write a python function to find the parity of a given number.", "canonical_solution": "def find_Parity(x): \r\n    y = x ^ (x >> 1); \r\n    y = y ^ (y >> 2); \r\n    y = y ^ (y >> 4); \r\n    y = y ^ (y >> 8); \r\n    y = y ^ (y >> 16); \r\n    if (y & 1): \r\n        return (\"Odd Parity\"); \r\n    return (\"Even Parity\"); ", "task_id": "Python/406", "test_setup": "", "test": ["assert find_Parity(12) == \"Even Parity\"", "assert find_Parity(7) == \"Odd Parity\"", "assert find_Parity(10) == \"Even Parity\""], "challenge_test_list": [], "func_title": "def find_Parity(x): \r", "prompt_text_chinese": "写一个Python函数来查找一个给定数字的奇偶性。", "code_comment": "定义一个函数 find_Parity，接收一个参数 x，该参数是一个整数\n将 x 和 x 右移一位之后的结果进行按位异或运算，并将结果存入变量 y 中\n将 y 和 y 右移两位之后的结果进行按位异或运算，并将结果存入变量 y 中\n将 y 和 y 右移四位之后的结果进行按位异或运算，并将结果存入变量 y 中\n将 y 和 y 右移八位之后的结果进行按位异或运算，并将结果存入变量 y 中\n将 y 和 y 右移十六位之后的结果进行按位异或运算，并将结果存入变量 y 中\n如果 y 的最后一位是 1，则返回 \"Odd Parity\"，否则返回 \"Even Parity\"\n"}
{"prompt": "Write a function to create the next bigger number by rearranging the digits of a given number.", "canonical_solution": "def rearrange_bigger(n):\r\n    nums = list(str(n))\r\n    for i in range(len(nums)-2,-1,-1):\r\n        if nums[i] < nums[i+1]:\r\n            z = nums[i:]\r\n            y = min(filter(lambda x: x > z[0], z))\r\n            z.remove(y)\r\n            z.sort()\r\n            nums[i:] = [y] + z\r\n            return int(\"\".join(nums))\r\n    return False", "task_id": "Python/407", "test_setup": "", "test": ["assert rearrange_bigger(12)==21", "assert rearrange_bigger(10)==False", "assert rearrange_bigger(102)==120"], "challenge_test_list": [], "func_title": "def rearrange_bigger(n):\r", "prompt_text_chinese": "写一个函数，通过重新排列一个给定的数字的数字来创建下一个更大的数字。", "code_comment": "定义一个函数 rearrange_bigger，接收一个参数 n，该参数是一个整数\n将 n 转换成字符串，然后将字符串转换成列表 nums\n使用 for 循环，从倒数第二个元素开始，向前遍历 nums 列表\n如果 nums[i] 小于 nums[i+1]，则执行以下操作\n取出 nums 中第 i 个元素及其后面的元素，并存入 z 列表中\n找到 z 中比 z[0] 大的最小值，并将其存入变量 y 中\n从 z 中删除变量 y 的值\n对 z 列表进行排序\n将列表 nums 中第 i 个元素及其后面的元素替换为 [y] + z 的值\n返回将列表 nums 转换成字符串再转换成整数的结果\n如果在 for 循环中没有找到符合要求的元素，则返回 False"}
{"prompt": "Write a function to find k number of pairs which consist of one element from the first array and one element from the second array.", "canonical_solution": "import heapq\r\ndef k_smallest_pairs(nums1, nums2, k):\r\n   queue = []\r\n   def push(i, j):\r\n       if i < len(nums1) and j < len(nums2):\r\n           heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\r\n   push(0, 0)\r\n   pairs = []\r\n   while queue and len(pairs) < k:\r\n       _, i, j = heapq.heappop(queue)\r\n       pairs.append([nums1[i], nums2[j]])\r\n       push(i, j + 1)\r\n       if j == 0:\r\n           push(i + 1, 0)\r\n   return pairs", "task_id": "Python/408", "test_setup": "", "test": ["assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]", "assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]", "assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]"], "challenge_test_list": [], "func_title": "def k_smallest_pairs(nums1, nums2, k):\r", "prompt_text_chinese": "写一个函数，找出由第一个数组中的一个元素和第二个数组中的一个元素组成的K数对。", "code_comment": "导入 heapq 模块\n定义一个函数 k_smallest_pairs，接收三个参数 nums1、nums2 和 k，其中 nums1 和 nums2 都是列表，k 是一个整数\n定义一个列表 queue，用于存储最小的 k 个数对\n定义一个函数 push，用于将 nums1 和 nums2 中的元素组合成数对，并将其存入列表 queue 中\n调用 push 函数，将 nums1 中的第一个元素和 nums2 中的第一个元素组合成数对，并存入列表 queue 中\n定义一个列表 pairs，用于存储最小的 k 个数对\n使用 while 循环，从 queue 中取出最小的元素，直到 pairs 列表的长度等于 k 或 queue 列表为空为止\n将 nums1 中的第 i 个元素和 nums2 中的第 j+1 个元素组合成数对，并将其存入列表 queue 中\n将 nums1 中的第 i+1 个元素和 nums2 中的第一个元素组合成数对，并将其存入列表 queue 中\n返回 pairs 列表"}
{"prompt": "Write a function to find the minimum product from the pairs of tuples within a given list.", "canonical_solution": "def min_product_tuple(list1):\r\n    result_min = min([abs(x * y) for x, y in list1] )\r\n    return result_min", "task_id": "Python/409", "test_setup": "", "test": ["assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==8", "assert min_product_tuple([(10,20), (15,2), (5,10)] )==30", "assert min_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==100"], "challenge_test_list": [], "func_title": "def min_product_tuple(list1):\r", "prompt_text_chinese": "写一个函数，从给定列表中的图元对中找出最小乘积。", "code_comment": "定义一个函数 min_product_tuple，接收一个参数 list1，该参数是由元组嵌套而成的列表\n使用列表解析式计算 list1 中每个元组中两个数的乘积的绝对值，并取出最小值\n返回最小值"}
{"prompt": "Write a function to find the minimum value in a given heterogeneous list.", "canonical_solution": "def min_val(listval):\r\n     min_val = min(i for i in listval if isinstance(i, int))\r\n     return min_val", "task_id": "Python/410", "test_setup": "", "test": ["assert min_val(['Python', 3, 2, 4, 5, 'version'])==2", "assert min_val(['Python', 15, 20, 25])==15", "assert min_val(['Python', 30, 20, 40, 50, 'version'])==20"], "challenge_test_list": [], "func_title": "def min_val(listval):\r", "prompt_text_chinese": "写一个函数来寻找给定异质列表中的最小值。", "code_comment": "定义一个函数 min_val，接收一个参数 listval，该参数是一个列表\n使用列表解析式和 min 函数，找到列表 listval 中类型为整数的最小值，并将其存入变量 min_val 中\n返回变量 min_val"}
{"prompt": "Write a function to convert the given snake case string to camel case string by using regex.", "canonical_solution": "import re\r\ndef snake_to_camel(word):\r\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))", "task_id": "Python/411", "test_setup": "", "test": ["assert snake_to_camel('android_tv') == 'AndroidTv'", "assert snake_to_camel('google_pixel') == 'GooglePixel'", "assert snake_to_camel('apple_watch') == 'AppleWatch'"], "challenge_test_list": [], "func_title": "def snake_to_camel(word):\r", "prompt_text_chinese": "写一个函数，通过使用regex将给定的蛇形大小写字符串转换为驼形大小写字符串。", "code_comment": "导入 re 模块\n定义一个函数 snake_to_camel，接收一个参数 word，该参数是一个下划线分割的字符串\n使用 re.split 函数将字符串 word 按下划线进行分割，然后将每个单词的首字母大写，最后将它们拼接起来，并返回结果\n"}
{"prompt": "Write a python function to remove odd numbers from a given list.", "canonical_solution": "def remove_odd(l):\r\n    for i in l:\r\n        if i % 2 != 0:\r\n            l.remove(i)\r\n    return l", "task_id": "Python/412", "test_setup": "", "test": ["assert remove_odd([1,2,3]) == [2]", "assert remove_odd([2,4,6]) == [2,4,6]", "assert remove_odd([10,20,3]) == [10,20]"], "challenge_test_list": [], "func_title": "def remove_odd(l):\r", "prompt_text_chinese": "写一个python函数，从给定的列表中删除奇数。", "code_comment": "定义一个函数 remove_odd，接收一个参数 l，该参数是一个列表\n使用 for 循环遍历列表 l 中的每个元素，如果该元素是奇数，则从列表 l 中删除该元素\n返回删除奇数后的列表 l"}
{"prompt": "Write a function to extract the nth element from a given list of tuples.", "canonical_solution": "def extract_nth_element(list1, n):\r\n    result = [x[n] for x in list1]\r\n    return result", "task_id": "Python/413", "test_setup": "", "test": ["assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,0)==['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']", "assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,2)==[99, 96, 94, 98]", "assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)],1)==[98, 97, 91, 94]"], "challenge_test_list": [], "func_title": "def extract_nth_element(list1, n):\r", "prompt_text_chinese": "写一个函数，从给定的图元列表中提取第n个元素。", "code_comment": "定义一个函数 extract_nth_element，接收两个参数 list1 和 n，其中 list1 是一个列表，n 是一个整数\n使用列表解析式，从 list1 中取出每个元素的第 n 个元素，并将它们存入列表 result 中\n返回列表 result\n"}
{"prompt": "Write a python function to check whether the value exists in a sequence or not.", "canonical_solution": "def overlapping(list1,list2):  \r\n    c=0\r\n    d=0\r\n    for i in list1: \r\n        c+=1\r\n    for i in list2: \r\n        d+=1\r\n    for i in range(0,c): \r\n        for j in range(0,d): \r\n            if(list1[i]==list2[j]): \r\n                return 1\r\n    return 0", "task_id": "Python/414", "test_setup": "", "test": ["assert overlapping([1,2,3,4,5],[6,7,8,9]) == False", "assert overlapping([1,2,3],[4,5,6]) == False", "assert overlapping([1,4,5],[1,4,5]) == True"], "challenge_test_list": [], "func_title": "def overlapping(list1,list2):  \r", "prompt_text_chinese": "写一个python函数来检查值是否存在于一个序列中。", "code_comment": "定义一个函数 overlapping，接收两个参数 list1 和 list2，这两个参数都是列表\n定义变量 c 并将其设为 0\n定义变量 d 并将其设为 0\n使用 for 循环遍历列表 list1，每遍历一个元素，就将变量 c 的值加 1\n使用 for 循环遍历列表 list2，每遍历一个元素，就将变量 d 的值加 1\n使用双重循环遍历列表 list1 和列表 list2，如果找到了相同的元素，则返回 1，否则返回 0\n"}
{"prompt": "Write a python function to find a pair with highest product from a given array of integers.", "canonical_solution": "def max_Product(arr): \r\n    arr_len = len(arr) \r\n    if (arr_len < 2): \r\n        return (\"No pairs exists\")           \r\n    x = arr[0]; y = arr[1]      \r\n    for i in range(0,arr_len): \r\n        for j in range(i + 1,arr_len): \r\n            if (arr[i] * arr[j] > x * y): \r\n                x = arr[i]; y = arr[j] \r\n    return x,y    ", "task_id": "Python/415", "test_setup": "", "test": ["assert max_Product([1,2,3,4,7,0,8,4]) == (7,8)", "assert max_Product([0,-1,-2,-4,5,0,-6]) == (-4,-6)", "assert max_Product([1,2,3]) == (2,3)"], "challenge_test_list": [], "func_title": "def max_Product(arr): \r", "prompt_text_chinese": "写一个Python函数，从给定的整数数组中找到一对具有最高乘积的数。", "code_comment": "定义一个函数 max_Product，接收一个参数 arr，该参数是一个列表\n计算列表 arr 的长度，并将其赋值给变量 arr_len\n如果列表 arr 的长度小于 2，则返回字符串 \"No pairs exists\"\n将列表 arr 中的第一个元素和第二个元素分别赋值给变量 x 和 y\n使用双重循环遍历列表 arr，并找到乘积最大的两个数，并将它们分别赋值给变量 x 和 y\n返回变量 x 和 y\n"}
{"prompt": "Write a function to find the maximum sum we can make by dividing number in three parts recursively and summing them up together for the given number.", "canonical_solution": "MAX = 1000000\r\ndef breakSum(n): \r\n\tdp = [0]*(n+1) \r\n\tdp[0] = 0\r\n\tdp[1] = 1\r\n\tfor i in range(2, n+1): \r\n\t\tdp[i] = max(dp[int(i/2)] + dp[int(i/3)] + dp[int(i/4)], i); \r\n\treturn dp[n]", "task_id": "Python/416", "test_setup": "", "test": ["assert breakSum(12) == 13", "assert breakSum(24) == 27", "assert breakSum(23) == 23"], "challenge_test_list": [], "func_title": "def breakSum(n): \r", "prompt_text_chinese": "写一个函数，找出我们将数字分成三部分递归，然后将它们加起来，对给定的数字进行求和的最大和。", "code_comment": "定义常量 MAX，并将其值设为 1000000\n定义一个函数 breakSum，接收一个参数 n，该参数是一个整数\n创建一个长度为 n+1 的列表 dp，并将列表中的所有元素都设为 0\n将 dp[0] 的值设为 0\n将 dp[1] 的值设为 1\n使用 for 循环，从 2 到 n+1 遍历列表 dp，并将 dp[i] 的值设为 dp[int(i/2)] + dp[int(i/3)] + dp[int(i/4)] 和 i 中的最大值\n返回列表 dp 的第 n 个元素的值\n"}
{"prompt": "Write a function to find common first element in given list of tuple.", "canonical_solution": "def group_tuples(Input): \r\n\tout = {} \r\n\tfor elem in Input: \r\n\t\ttry: \r\n\t\t\tout[elem[0]].extend(elem[1:]) \r\n\t\texcept KeyError: \r\n\t\t\tout[elem[0]] = list(elem) \r\n\treturn [tuple(values) for values in out.values()] ", "task_id": "Python/417", "test_setup": "", "test": ["assert group_tuples([('x', 'y'), ('x', 'z'), ('w', 't')]) == [('x', 'y', 'z'), ('w', 't')]", "assert group_tuples([('a', 'b'), ('a', 'c'), ('d', 'e')]) == [('a', 'b', 'c'), ('d', 'e')]", "assert group_tuples([('f', 'g'), ('f', 'g'), ('h', 'i')]) == [('f', 'g', 'g'), ('h', 'i')]"], "challenge_test_list": [], "func_title": "def group_tuples(Input): \r", "prompt_text_chinese": "写一个函数，在给定的元组列表中找到共同的第一个元素。", "code_comment": "定义一个函数 group_tuples，接收一个参数 Input，该参数是由元组嵌套而成的列表\n定义一个空字典 out\n使用 for 循环遍历列表 Input 中的每个元素，如果该元素的第一个值已经存在于字典 out 中，则将该元素的剩余值加入到字典 out 对应的键的值中，否则将该元素转换成列表并存入字典 out 中\n使用列表解析式，将字典 out 的值转换成元组，并将所有的元组存入到一个列表中，并将该列表返回\n"}
{"prompt": "Write a python function to find the sublist having maximum length.", "canonical_solution": "def Find_Max(lst): \r\n    maxList = max((x) for x in lst) \r\n    return maxList", "task_id": "Python/418", "test_setup": "", "test": ["assert Find_Max([['A'],['A','B'],['A','B','C']]) == ['A','B','C']", "assert Find_Max([[1],[1,2],[1,2,3]]) == [1,2,3]", "assert Find_Max([[1,1],[1,2,3],[1,5,6,1]]) == [1,5,6,1]"], "challenge_test_list": [], "func_title": "def Find_Max(lst): \r", "prompt_text_chinese": "写一个Python函数来寻找具有最大长度的子列表。", "code_comment": "定义一个函数 Find_Max，接收一个参数 lst，该参数是一个列表\n使用 max 函数，找到列表 lst 中的最大值，并将其赋值给变量 maxList\n返回变量 maxList"}
{"prompt": "Write a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.", "canonical_solution": "def round_and_sum(list1):\r\n  lenght=len(list1)\r\n  round_and_sum=sum(list(map(round,list1))* lenght)\r\n  return round_and_sum", "task_id": "Python/419", "test_setup": "", "test": ["assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243", "assert round_and_sum([5,2,9,24.3,29])==345", "assert round_and_sum([25.0,56.7,89.2])==513"], "challenge_test_list": [], "func_title": "def round_and_sum(list1):\r", "prompt_text_chinese": "编写一个函数，对给定的数字列表中的每个数字进行四舍五入，并打印总和乘以列表的长度。", "code_comment": "定义一个函数 round_and_sum，接收一个参数 list1，该参数是一个列表\n计算列表 list1 的长度，并将其赋值给变量 lenght\n将列表 list1 中的每个元素四舍五入，然后将结果转换成列表，并将该列表重复 lenght 次后，用 sum 函数求和\n返回求和的结果\n"}
{"prompt": "Write a python function to find the cube sum of first n even natural numbers.", "canonical_solution": "def cube_Sum(n): \r\n    sum = 0\r\n    for i in range(1,n + 1): \r\n        sum += (2*i)*(2*i)*(2*i) \r\n    return sum", "task_id": "Python/420", "test_setup": "", "test": ["assert cube_Sum(2) == 72", "assert cube_Sum(3) == 288", "assert cube_Sum(4) == 800"], "challenge_test_list": [], "func_title": "def cube_Sum(n): \r", "prompt_text_chinese": "写一个Python函数来寻找前n个偶数自然数的立方体之和。", "code_comment": "定义一个函数 cube_Sum，接收一个参数 n，该参数是一个整数\n定义一个变量 sum，并将其初始值设为 0\n使用 for 循环，从 1 到 n+1 遍历整数（不包括 n+1），将每个数的立方乘以 8（即 2 的 3 次方）后，累加到变量 sum 中\n返回变量 sum"}
{"prompt": "Write a function to concatenate each element of tuple by the delimiter.", "canonical_solution": "def concatenate_tuple(test_tup):\r\n    delim = \"-\"\r\n    res = ''.join([str(ele) + delim for ele in test_tup])\r\n    res = res[ : len(res) - len(delim)]\r\n    return (str(res)) ", "task_id": "Python/421", "test_setup": "", "test": ["assert concatenate_tuple((\"ID\", \"is\", 4, \"UTS\") ) == 'ID-is-4-UTS'", "assert concatenate_tuple((\"QWE\", \"is\", 4, \"RTY\") ) == 'QWE-is-4-RTY'", "assert concatenate_tuple((\"ZEN\", \"is\", 4, \"OP\") ) == 'ZEN-is-4-OP'"], "challenge_test_list": [], "func_title": "def concatenate_tuple(test_tup):\r", "prompt_text_chinese": "写一个函数，用分隔符连接元组的每个元素。", "code_comment": "定义一个函数 concatenate_tuple，接收一个参数 test_tup，该参数是一个元组\n定义一个变量 delim，并将其设为 \"-\"\n将元组 test_tup 中的每个元素转换成字符串，并用连接符 delim 进行连接，最后将连接结果中的最后一个连接符去除\n返回连接结果的字符串形式"}
{"prompt": "Write a python function to find the average of cubes of first n natural numbers.", "canonical_solution": "def find_Average_Of_Cube(n):  \r\n    sum = 0\r\n    for i in range(1, n + 1): \r\n        sum += i * i * i  \r\n    return round(sum / n, 6) ", "task_id": "Python/422", "test_setup": "", "test": ["assert find_Average_Of_Cube(2) == 4.5", "assert find_Average_Of_Cube(3) == 12", "assert find_Average_Of_Cube(1) == 1"], "challenge_test_list": [], "func_title": "def find_Average_Of_Cube(n):  \r", "prompt_text_chinese": "写一个Python函数来求前n个自然数的立方体的平均值。", "code_comment": "定义一个函数 find_Average_Of_Cube，接收一个参数 n，该参数是一个整数\n定义一个变量 sum，并将其初始值设为 0\n使用 for 循环，从 1 到 n+1 遍历整数（不包括 n+1），将每个数的立方累加到变量 sum 中\n将变量 sum 除以 n，并将结果保留 6 位小数，然后返回该结果\n"}
{"prompt": "Write a function to solve gold mine problem.", "canonical_solution": "def get_maxgold(gold, m, n): \r\n    goldTable = [[0 for i in range(n)] \r\n                        for j in range(m)]   \r\n    for col in range(n-1, -1, -1): \r\n        for row in range(m):  \r\n            if (col == n-1): \r\n                right = 0\r\n            else: \r\n                right = goldTable[row][col+1] \r\n            if (row == 0 or col == n-1): \r\n                right_up = 0\r\n            else: \r\n                right_up = goldTable[row-1][col+1] \r\n            if (row == m-1 or col == n-1): \r\n                right_down = 0\r\n            else: \r\n                right_down = goldTable[row+1][col+1] \r\n            goldTable[row][col] = gold[row][col] + max(right, right_up, right_down) \r\n    res = goldTable[0][0] \r\n    for i in range(1, m): \r\n        res = max(res, goldTable[i][0])  \r\n    return res ", "task_id": "Python/423", "test_setup": "", "test": ["assert get_maxgold([[1, 3, 1, 5],[2, 2, 4, 1],[5, 0, 2, 3],[0, 6, 1, 2]],4,4)==16", "assert get_maxgold([[10,20],[30,40]],2,2)==70", "assert get_maxgold([[4,9],[3,7]],2,2)==13"], "challenge_test_list": [], "func_title": "def get_maxgold(gold, m, n): \r", "prompt_text_chinese": "写一个函数来解决金矿问题。", "code_comment": "定义一个函数 get_maxgold，接收三个参数 gold、m 和 n，其中 gold 是一个 m 行 n 列的二维列表，m 和 n 分别表示列表的行数和列数\n创建一个 m 行 n 列的二维列表 goldTable，并将所有元素的值都设为 0\n使用双重循环遍历二维列表 goldTable 中的每个元素，将从当前位置开始，向右、右上和右下走所能得到的最大金子数记录在 goldTable 中\n如果当前列是最右边一列，则 right 的值为 0\n否则，right 的值为 goldTable[row][col+1]\n如果当前位置在第一行或者最右边一列，则 right_up 的值为 0\n否则，right_up 的值为 goldTable[row-1][col+1]\n如果当前位置在最后一行或者最右边一列，则 right_down 的值为 0\n否则，right_down 的值为 goldTable[row+1][col+1]\n计算出当前位置所能得到的最大金子数，并记录在 goldTable[row][col] 中\n取出第一列中的最大值，将其赋值给变量 res\n使用 for 循环，从第二行开始遍历 goldTable 中的每一行，取出每行的第一个元素，将其与变量 res 的值进行比较，将较大的值赋值给 res\n返回变量 res"}
{"prompt": "Write a function to extract only the rear index element of each string in the given tuple.", "canonical_solution": "def extract_rear(test_tuple):\r\n  res = list(sub[len(sub) - 1] for sub in test_tuple)\r\n  return (res) ", "task_id": "Python/424", "test_setup": "", "test": ["assert extract_rear(('Mers', 'for', 'Vers') ) == ['s', 'r', 's']", "assert extract_rear(('Avenge', 'for', 'People') ) == ['e', 'r', 'e']", "assert extract_rear(('Gotta', 'get', 'go') ) == ['a', 't', 'o']"], "challenge_test_list": [], "func_title": "def extract_rear(test_tuple):\r", "prompt_text_chinese": "写一个函数，在给定的元组中只提取每个字符串的后置索引元素。", "code_comment": "定义一个函数 extract_rear，接收一个参数 test_tuple，该参数是由元组嵌套而成的列表\n使用列表解析式，取出元组中每个子元组的最后一个元素，将这些元素组成一个列表，并将该列表返回\n返回列表 res\n"}
{"prompt": "Write a function to count the number of sublists containing a particular element.", "canonical_solution": "def count_element_in_list(list1, x): \r\n    ctr = 0\r\n    for i in range(len(list1)): \r\n        if x in list1[i]: \r\n            ctr+= 1          \r\n    return ctr", "task_id": "Python/425", "test_setup": "", "test": ["assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]],1)==3", "assert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'A')==3", "assert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'E')==1"], "challenge_test_list": [], "func_title": "def count_element_in_list(list1, x): \r", "prompt_text_chinese": "写一个函数来计算包含某一特定元素的子列表的数量。", "code_comment": "定义一个函数 count_element_in_list，接收两个参数 list1 和 x，其中 list1 是一个列表，x 是一个元素\n定义一个变量 ctr，并将其初始值设为 0\n使用 for 循环和 if 语句遍历列表 list1 中的每个元素，如果 x 存在于该元素中，则将 ctr 的值加 1\n返回变量 ctr"}
{"prompt": "Write a function to filter odd numbers using lambda function.", "canonical_solution": "def filter_oddnumbers(nums):\r\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\r\n return odd_nums", "task_id": "Python/426", "test_setup": "", "test": ["assert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1,3,5,7,9]", "assert filter_oddnumbers([10,20,45,67,84,93])==[45,67,93]", "assert filter_oddnumbers([5,7,9,8,6,4,3])==[5,7,9,3]"], "challenge_test_list": [], "func_title": "def filter_oddnumbers(nums):\r", "prompt_text_chinese": "写一个函数，用lambda函数过滤奇数。", "code_comment": "定义一个函数 filter_oddnumbers，接收一个参数 nums，该参数是一个列表\n使用 filter 函数和 lambda 表达式，选出列表 nums 中所有的奇数，并将其存入一个列表 odd_nums 中\n返回列表 odd_nums\n"}
{"prompt": "Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format by using regex.", "canonical_solution": "import re\r\ndef change_date_format(dt):\r\n        return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', dt)", "task_id": "Python/427", "test_setup": "", "test": ["assert change_date_format(\"2026-01-02\") == '02-01-2026'", "assert change_date_format(\"2020-11-13\") == '13-11-2020'", "assert change_date_format(\"2021-04-26\") == '26-04-2021'"], "challenge_test_list": [], "func_title": "def change_date_format(dt):\r", "prompt_text_chinese": "写一个函数，通过使用regex将yyyy-mm-dd格式的日期转换成dd-mm-yyyy格式。", "code_comment": "导入 re 模块\n定义一个函数 change_date_format，接收一个参数 dt，该参数是一个日期字符串\n使用 re.sub 函数，将日期字符串中的年份、月份和日份提取出来，并按照 \"日-月-年\" 的格式重新组合成一个新的字符串，然后将新字符串返回\n"}
{"prompt": "Write a function to sort the given array by using shell sort.", "canonical_solution": "def shell_sort(my_list):\r\n    gap = len(my_list) // 2\r\n    while gap > 0:\r\n        for i in range(gap, len(my_list)):\r\n            current_item = my_list[i]\r\n            j = i\r\n            while j >= gap and my_list[j - gap] > current_item:\r\n                my_list[j] = my_list[j - gap]\r\n                j -= gap\r\n            my_list[j] = current_item\r\n        gap //= 2\r\n\r\n    return my_list", "task_id": "Python/428", "test_setup": "", "test": ["assert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]", "assert shell_sort([24, 22, 39, 34, 87, 73, 68]) == [22, 24, 34, 39, 68, 73, 87]", "assert shell_sort([32, 30, 16, 96, 82, 83, 74]) == [16, 30, 32, 74, 82, 83, 96]"], "challenge_test_list": [], "func_title": "def shell_sort(my_list):\r", "prompt_text_chinese": "写一个函数，用shell sort对给定的数组进行排序。", "code_comment": "定义一个函数 shell_sort，接收一个参数 my_list，该参数是一个列表\n定义一个变量 gap，将其设为列表 my_list 的长度除以 2（整除）\n使用 while 循环，当 gap 大于 0 时执行以下操作\n使用 for 循环，从 gap 开始遍历列表 my_list 中的每个元素\n取出 my_list[i]，并将其赋值给变量 current_item\n将变量 j 的值设为 i\n使用 while 循环，当 j 大于等于 gap 且 my_list[j - gap] 大于 current_item 时执行以下操作\n将 my_list[j - gap] 赋值给 my_list[j]\n将 j 的值减去 gap\n将 current_item 赋值给 my_list[j]\n将 gap 的值除以 2（整除），并将其赋值给 gap\n返回排序后的列表 my_list"}
{"prompt": "Write a function to extract the elementwise and tuples from the given two tuples.", "canonical_solution": "def and_tuples(test_tup1, test_tup2):\r\n  res = tuple(ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res) ", "task_id": "Python/429", "test_setup": "", "test": ["assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)", "assert and_tuples((1, 2, 3, 4), (5, 6, 7, 8)) == (1, 2, 3, 0)", "assert and_tuples((8, 9, 11, 12), (7, 13, 14, 17)) == (0, 9, 10, 0)"], "challenge_test_list": [], "func_title": "def and_tuples(test_tup1, test_tup2):\r", "prompt_text_chinese": "写一个函数，从给定的两个图元中提取元素和图元。", "code_comment": "定义一个函数 and_tuples，接收两个参数 test_tup1 和 test_tup2，这两个参数都是元组\n使用 zip 函数将两个元组中的元素一一对应拿出来，并使用 & 运算符求交集\n然后使用列表解析式将结果组成一个元组，并将该元组返回\n返回元组 res"}
{"prompt": "Write a function to find the directrix of a parabola.", "canonical_solution": "def parabola_directrix(a, b, c): \r\n  directrix=((int)(c - ((b * b) + 1) * 4 * a ))\r\n  return directrix", "task_id": "Python/430", "test_setup": "", "test": ["assert parabola_directrix(5,3,2)==-198", "assert parabola_directrix(9,8,4)==-2336", "assert parabola_directrix(2,4,6)==-130"], "challenge_test_list": [], "func_title": "def parabola_directrix(a, b, c): \r", "prompt_text_chinese": "写一个函数来寻找抛物线的直角。", "code_comment": "定义一个函数 parabola_directrix，接收三个参数 a、b 和 c，这三个参数都是整数\n计算出抛物线的准线方程的常数项，并将其赋值给变量 directrix\n这里的常数项是根据准线方程的一般式 Ax + By + C = 0（其中 A = 0，B = 1，C = -4ac-b*b）计算得出的\n返回变量 directrix\n"}
{"prompt": "Write a function that takes two lists and returns true if they have at least one common element.", "canonical_solution": "def common_element(list1, list2):\r\n     result = False\r\n     for x in list1:\r\n         for y in list2:\r\n             if x == y:\r\n                 result = True\r\n                 return result", "task_id": "Python/431", "test_setup": "", "test": ["assert common_element([1,2,3,4,5], [5,6,7,8,9])==True", "assert common_element([1,2,3,4,5], [6,7,8,9])==None", "assert common_element(['a','b','c'], ['d','b','e'])==True"], "challenge_test_list": [], "func_title": "def common_element(list1, list2):\r", "prompt_text_chinese": "写一个函数，接收两个列表，如果它们至少有一个共同元素则返回真。", "code_comment": "定义一个函数 common_element，接收两个参数 list1 和 list2，这两个参数都是列表\n定义一个变量 result，并将其初始值设为 False\n使用双重循环遍历两个列表中的每个元素\n如果列表中有相同的元素，则将变量 result 的值设为 True，并将其返回\n"}
{"prompt": "Write a function to find the median of a trapezium.", "canonical_solution": "def median_trapezium(base1,base2,height):\r\n median = 0.5 * (base1+ base2)\r\n return median", "task_id": "Python/432", "test_setup": "", "test": ["assert median_trapezium(15,25,35)==20", "assert median_trapezium(10,20,30)==15", "assert median_trapezium(6,9,4)==7.5"], "challenge_test_list": [], "func_title": "def median_trapezium(base1,base2,height):\r", "prompt_text_chinese": "写一个函数来求梯形的中位数。", "code_comment": "定义一个函数 median_trapezium，接收三个参数 base1、base2 和 height，这三个参数都是数字\n计算出梯形的中位线长度（即上底和下底之和的一半），并将其赋值给变量 median\n返回变量 median"}
{"prompt": "Write a function to check whether the entered number is greater than the elements of the given array.", "canonical_solution": "def check_greater(arr, number):\r\n  arr.sort()\r\n  if number > arr[-1]:\r\n    return ('Yes, the entered number is greater than those in the array')\r\n  else:\r\n    return ('No, entered number is less than those in the array')", "task_id": "Python/433", "test_setup": "", "test": ["assert check_greater([1, 2, 3, 4, 5], 4) == 'No, entered number is less than those in the array'", "assert check_greater([2, 3, 4, 5, 6], 8) == 'Yes, the entered number is greater than those in the array'", "assert check_greater([9, 7, 4, 8, 6, 1], 11) == 'Yes, the entered number is greater than those in the array'"], "challenge_test_list": [], "func_title": "def check_greater(arr, number):\r", "prompt_text_chinese": "写一个函数来检查输入的数字是否大于给定数组中的元素。", "code_comment": "定义一个函数 check_greater，接收两个参数 arr 和 number，其中 arr 是一个列表，number 是一个数字\n将列表 arr 进行排序\n如果变量 number 大于列表 arr 中的最后一个元素，则返回字符串 'Yes, the entered number is greater than those in the array'\n否则，返回字符串 'No, entered number is less than those in the array'\n"}
{"prompt": "Write a function that matches a string that has an a followed by one or more b's.", "canonical_solution": "import re\r\ndef text_match_one(text):\r\n        patterns = 'ab+?'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')\r\n", "task_id": "Python/434", "test_setup": "", "test": ["assert text_match_one(\"ac\")==('Not matched!')", "assert text_match_one(\"dc\")==('Not matched!')", "assert text_match_one(\"abba\")==('Found a match!')"], "challenge_test_list": [], "func_title": "def text_match_one(text):\r", "prompt_text_chinese": "写一个函数，匹配一个有a后跟一个或多个b的字符串。", "code_comment": "导入 re 模块\n定义一个函数 text_match_one，接收一个参数 text，该参数是一个字符串\n定义一个模式字符串 patterns，表示匹配一个或多个 \"b\" 前面跟着一个 \"a\"\n使用 re.search 函数在字符串 text 中搜索模式串 patterns，如果找到了匹配的字符串，则返回字符串 'Found a match!'\n否则，返回字符串 'Not matched!'\n"}
{"prompt": "Write a python function to find the last digit of a given number.", "canonical_solution": "def last_Digit(n) :\r\n    return (n % 10) ", "task_id": "Python/435", "test_setup": "", "test": ["assert last_Digit(123) == 3", "assert last_Digit(25) == 5", "assert last_Digit(30) == 0"], "challenge_test_list": [], "func_title": "def last_Digit(n) :\r", "prompt_text_chinese": "写一个Python函数，找出给定数字的最后一位数。", "code_comment": "定义一个函数 last_Digit，接收一个参数 n，该参数是一个数字\n返回参数 n 除以 10 的余数，即 n 的个位数"}
{"prompt": "Write a python function to print negative numbers in a list.", "canonical_solution": "def neg_nos(list1):\r\n  for num in list1: \r\n    if num < 0: \r\n       return num ", "task_id": "Python/436", "test_setup": "", "test": ["assert neg_nos([-1,4,5,-6]) == -1,-6", "assert neg_nos([-1,-2,3,4]) == -1,-2", "assert neg_nos([-7,-6,8,9]) == -7,-6"], "challenge_test_list": [], "func_title": "def neg_nos(list1):\r", "prompt_text_chinese": "写一个Python函数来打印一个列表中的负数。", "code_comment": "定义一个函数 neg_nos，接收一个参数 list1，该参数是一个列表\n遍历列表 list1 中的每个元素\n如果元素小于 0\n则将该元素返回"}
{"prompt": "Write a function to remove odd characters in a string.", "canonical_solution": "def remove_odd(str1):\r\n str2 = ''\r\n for i in range(1, len(str1) + 1):\r\n    if(i % 2 == 0):\r\n        str2 = str2 + str1[i - 1]\r\n return str2", "task_id": "Python/437", "test_setup": "", "test": ["assert remove_odd(\"python\")==(\"yhn\")", "assert remove_odd(\"program\")==(\"rga\")", "assert remove_odd(\"language\")==(\"agae\")"], "challenge_test_list": [], "func_title": "def remove_odd(str1):\r", "prompt_text_chinese": "写一个函数来删除字符串中的奇数字符。", "code_comment": "定义一个函数 remove_odd，接收一个参数 str1，该参数是一个字符串\n定义一个空字符串 str2\n使用 for 循环，从 1 开始遍历字符串 str1 中的每个字符\n如果字符的下标为偶数\n则将该字符添加到字符串 str2 的末尾\n最后返回字符串 str2"}
{"prompt": "Write a function to count bidirectional tuple pairs.", "canonical_solution": "def count_bidirectional(test_list):\r\n  res = 0\r\n  for idx in range(0, len(test_list)):\r\n    for iidx in range(idx + 1, len(test_list)):\r\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\r\n        res += 1\r\n  return (str(res)) ", "task_id": "Python/438", "test_setup": "", "test": ["assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] ) == '3'", "assert count_bidirectional([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] ) == '2'", "assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] ) == '4'"], "challenge_test_list": [], "func_title": "def count_bidirectional(test_list):\r", "prompt_text_chinese": "写一个函数来计算双向元组对。", "code_comment": "定义一个函数 count_bidirectional，接收一个参数 test_list，该参数是一个二维列表\n定义一个变量 res，将其初始值设为 0\n使用双重循环，遍历二维列表 test_list 中的每个元素\n如果 test_list[iidx][0] 等于 test_list[idx][1]，且 test_list[idx][1] 等于 test_list[iidx][0]\n则将变量 res 的值加 1\n返回变量 res ���字符串形式\n"}
{"prompt": "Write a function to convert a list of multiple integers into a single integer.", "canonical_solution": "def multiple_to_single(L):\r\n  x = int(\"\".join(map(str, L)))\r\n  return x", "task_id": "Python/439", "test_setup": "", "test": ["assert multiple_to_single([11, 33, 50])==113350", "assert multiple_to_single([-1,2,3,4,5,6])==-123456", "assert multiple_to_single([10,15,20,25])==10152025"], "challenge_test_list": [], "func_title": "def multiple_to_single(L):\r", "prompt_text_chinese": "写一个函数，将多个整数的列表转换成一个整数。", "code_comment": "定义一个函数 multiple_to_single，接收一个参数 L，该参数是一个列表\n将列表 L 中的所有元素转化为字符串，然后使用 ''.join() 方法将它们拼接起来，最后再使用 int() 函数将其转化为整数，并将该整数赋值给变量 x\n返回变量 x"}
{"prompt": "Write a function to find all adverbs and their positions in a given sentence.", "canonical_solution": "import re\r\ndef find_adverb_position(text):\r\n for m in re.finditer(r\"\\w+ly\", text):\r\n    return (m.start(), m.end(), m.group(0))", "task_id": "Python/440", "test_setup": "", "test": ["assert find_adverb_position(\"clearly!! we can see the sky\")==(0, 7, 'clearly')", "assert find_adverb_position(\"seriously!! there are many roses\")==(0, 9, 'seriously')", "assert find_adverb_position(\"unfortunately!! sita is going to home\")==(0, 13, 'unfortunately')"], "challenge_test_list": [], "func_title": "def find_adverb_position(text):\r", "prompt_text_chinese": "写一个函数来查找所有的副词和它们在给定句子中的位置。", "code_comment": "导入 re 模块\n定义一个函数 find_adverb_position，接收一个参数 text，该参数是一个字符串\n使用 re.finditer 函数在字符串 text 中搜索以 \"ly\" 结尾的单词\n对于每个搜索到的单词，返回其起始位置、终止位置和该单词本身\n"}
{"prompt": "Write a function to find the surface area of a cube.", "canonical_solution": "def surfacearea_cube(l):\r\n  surfacearea= 6*l*l\r\n  return surfacearea", "task_id": "Python/441", "test_setup": "", "test": ["assert surfacearea_cube(5)==150", "assert surfacearea_cube(3)==54", "assert surfacearea_cube(10)==600"], "challenge_test_list": [], "func_title": "def surfacearea_cube(l):\r", "prompt_text_chinese": "写一个函数来求一个立方体的表面积。", "code_comment": "定义一个函数 surfacearea_cube，接收一个参数 l，该参数是一个数字，表示正方体的边长\n计算正方体的表面积，即 6 倍正方体的边长的平方，并将其赋值给变量 surfacearea\n返回变量 surfacearea 的值"}
{"prompt": "Write a function to find the ration of positive numbers in an array of integers.", "canonical_solution": "from array import array\r\ndef positive_count(nums):\r\n    n = len(nums)\r\n    n1 = 0\r\n    for x in nums:\r\n        if x > 0:\r\n            n1 += 1\r\n        else:\r\n          None\r\n    return round(n1/n,2)", "task_id": "Python/442", "test_setup": "", "test": ["assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.54", "assert positive_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.69", "assert positive_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.56"], "challenge_test_list": [], "func_title": "def positive_count(nums):\r", "prompt_text_chinese": "写一个函数，找出整数阵列中正数的比例。", "code_comment": "导入 array 模块\n定义一个函数 positive_count，接收一个参数 nums，该参数是一个数组\n获取数组 nums 的长度，并将其赋值给变量 n\n定义一个变量 n1，用于记录数组 nums 中大于 0 的元素的个数\n遍历数组 nums 中的每个元素\n如果元素大于 0，则变量 n1 的值加 1\n否则啥也不做\n最后计算大于 0 的元素个数在总元素个数中所占的比例，并将结果保留两位小数，并将其返回"}
{"prompt": "Write a python function to find the largest negative number from the given list.", "canonical_solution": "def largest_neg(list1): \r\n    max = list1[0] \r\n    for x in list1: \r\n        if x < max : \r\n             max = x  \r\n    return max", "task_id": "Python/443", "test_setup": "", "test": ["assert largest_neg([1,2,3,-4,-6]) == -6", "assert largest_neg([1,2,3,-8,-9]) == -9", "assert largest_neg([1,2,3,4,-1]) == -1"], "challenge_test_list": [], "func_title": "def largest_neg(list1): \r", "prompt_text_chinese": "写一个python函数，从给定的列表中找出最大的负数。", "code_comment": "定义一个函数 largest_neg，接收一个参数 list1，该参数是一个列表\n将列表中的第一个元素赋值给变量 max\n遍历列表中的每个元素\n如果元素小于变量 max\n将该元素赋值给变量 max\n最后返回变量 max"}
{"prompt": "Write a function to trim each tuple by k in the given tuple list.", "canonical_solution": "def trim_tuple(test_list, K):\r\n  res = []\r\n  for ele in test_list:\r\n    N = len(ele)\r\n    res.append(tuple(list(ele)[K: N - K]))\r\n  return (str(res)) ", "task_id": "Python/444", "test_setup": "", "test": ["assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1),(9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == '[(2,), (9,), (2,), (2,)]'", "assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 1) == '[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]'", "assert trim_tuple([(7, 8, 4, 9), (11, 8, 12, 4),(4, 1, 7, 8), (3, 6, 9, 7)], 1) == '[(8, 4), (8, 12), (1, 7), (6, 9)]'"], "challenge_test_list": [], "func_title": "def trim_tuple(test_list, K):\r", "prompt_text_chinese": "写一个函数，在给定的元组列表中对每个元组进行k的修剪。", "code_comment": "定义一个函数 trim_tuple，接收两个参数 test_list 和 K，其中 test_list 是一个元组列表，K 是一个数字\n定义一个空列表 res\n遍历元组列表 test_list 中的每个元组\n获取当前元组的长度，并将其赋值给变量 N\n将当前元组转化为列表，然后切片保留从 K 到 N-K 之间的元素，并将这些元素再转化为元组，最后将新的元组添加到 res 列表中\n最后返回变量 res 的字符串形式\n"}
{"prompt": "Write a function to perform index wise multiplication of tuple elements in the given two tuples.", "canonical_solution": "def index_multiplication(test_tup1, test_tup2):\r\n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\r\n   for tup1, tup2 in zip(test_tup1, test_tup2))\r\n  return (res) ", "task_id": "Python/445", "test_setup": "", "test": ["assert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))", "assert index_multiplication(((2, 4), (5, 6), (3, 10), (2, 11)),((7, 8), (4, 10), (2, 2), (8, 4)) ) == ((14, 32), (20, 60), (6, 20), (16, 44))", "assert index_multiplication(((3, 5), (6, 7), (4, 11), (3, 12)),((8, 9), (5, 11), (3, 3), (9, 5)) ) == ((24, 45), (30, 77), (12, 33), (27, 60))"], "challenge_test_list": [], "func_title": "def index_multiplication(test_tup1, test_tup2):\r", "prompt_text_chinese": "写一个函数，对给定的两个元组中的元组元素进行索引明智的乘法。", "code_comment": "定义一个函数 index_multiplication，接收两个参数 test_tup1 和 test_tup2，这两个参数都是元组的元组\n使用 zip 函数，将这两个元组的元组一一对应，然后对应位置的元素相乘，并将结果保存到一个新的元组中\n返回新的元组"}
{"prompt": "Write a python function to count the occurence of all elements of list in a tuple.", "canonical_solution": "from collections import Counter \r\ndef count_Occurrence(tup, lst): \r\n    count = 0\r\n    for item in tup: \r\n        if item in lst: \r\n            count+= 1 \r\n    return count  ", "task_id": "Python/446", "test_setup": "", "test": ["assert count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b'] ) == 3", "assert count_Occurrence((1, 2, 3, 1, 4, 6, 7, 1, 4),[1, 4, 7]) == 6", "assert count_Occurrence((1,2,3,4,5,6),[1,2]) == 2"], "challenge_test_list": [], "func_title": "def count_Occurrence(tup, lst): \r", "prompt_text_chinese": "写一个python函数来计算一个元组中所有元素的出现次数。", "code_comment": "导入 collections 模块中的 Counter 类\n定义一个函数 count_Occurrence，接收两个参数 tup 和 lst，其中 tup 是一个元组，lst 是一个列表\n定义一个变量 count，用于计数元组 tup 中的元素在列表 lst 中出现的次数\n遍历元组 tup 中的每个元素\n如果该元素也在列表 lst 中出现\n则将变量 count 的值加 1\n最后返回变量 count 的值"}
{"prompt": "Write a function to find cubes of individual elements in a list using lambda function.", "canonical_solution": "def cube_nums(nums):\r\n cube_nums = list(map(lambda x: x ** 3, nums))\r\n return cube_nums", "task_id": "Python/447", "test_setup": "", "test": ["assert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]", "assert cube_nums([10,20,30])==([1000, 8000, 27000])", "assert cube_nums([12,15])==([1728, 3375])"], "challenge_test_list": [], "func_title": "def cube_nums(nums):\r", "prompt_text_chinese": "用lambda函数写一个函数来查找列表中各个元素的立方体。", "code_comment": "定义一个函数 cube_nums，接收一个参数 nums，该参数是一个数字列表\n将 nums 列表中的每个元素分别进行立方运算，并将结果保存到一个新的列表中，并将该列表赋值给变量 cube_nums\n返回变量 cube_nums 的值"}
{"prompt": "Write a function to calculate the sum of perrin numbers.", "canonical_solution": "def cal_sum(n): \r\n\ta = 3\r\n\tb = 0\r\n\tc = 2\r\n\tif (n == 0): \r\n\t\treturn 3\r\n\tif (n == 1): \r\n\t\treturn 3\r\n\tif (n == 2): \r\n\t\treturn 5\r\n\tsum = 5\r\n\twhile (n > 2): \r\n\t\td = a + b \r\n\t\tsum = sum + d \r\n\t\ta = b \r\n\t\tb = c \r\n\t\tc = d \r\n\t\tn = n-1\r\n\treturn sum", "task_id": "Python/448", "test_setup": "", "test": ["assert cal_sum(9) == 49", "assert cal_sum(10) == 66", "assert cal_sum(11) == 88"], "challenge_test_list": [], "func_title": "def cal_sum(n): \r", "prompt_text_chinese": "写一个函数来计算perrin数的总和。", "code_comment": "定义一个函数 cal_sum，接收一个参数 n，该参数是一个数字\n将 a 赋值为 3\n将 b 赋值为 0\n将 c 赋值为 2\n如果参数 n 的值等于 0，则返回 3\n如果参数 n 的值等于 1，则返回 3\n如果参数 n 的值等于 2，则返回 5\n将变量 sum 的初始值设为 5\n当参数 n 大于 2 时，执行以下操作\n将变量 d 的值设为变量 a 与 b 的和\n将变量 d 的值加到变量 sum 上\n将变量 a 的值更新为变量 b 的值\n将变量 b 的值更新为变量 c 的值\n将变量 c 的值更新为变量 d 的值\n将参数 n 的值减 1\n返回变量 sum 的值"}
{"prompt": "Write a python function to check whether the triangle is valid or not if 3 points are given.", "canonical_solution": "def check_Triangle(x1,y1,x2,y2,x3,y3): \r\n    a = (x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))   \r\n    if a == 0: \r\n        return ('No') \r\n    else: \r\n        return ('Yes') ", "task_id": "Python/449", "test_setup": "", "test": ["assert check_Triangle(1,5,2,5,4,6) == 'Yes'", "assert check_Triangle(1,1,1,4,1,5) == 'No'", "assert check_Triangle(1,1,1,1,1,1) == 'No'"], "challenge_test_list": [], "func_title": "def check_Triangle(x1,y1,x2,y2,x3,y3): \r", "prompt_text_chinese": "写一个python函数，在给出3个点的情况下，检查三角形是否有效。", "code_comment": "定义一个函数 check_Triangle，接收六个参数 x1、y1、x2、y2、x3、y3，这些参数都是数字\n计算三个点的坐标值，判断是否能组成三角形\n如果三个点不能组成三角形，则返回字符串 'No'\n否则返回字符串 'Yes'\n"}
{"prompt": "Write a function to extract specified size of strings from a give list of string values.", "canonical_solution": "def extract_string(str, l):\r\n    result = [e for e in str if len(e) == l] \r\n    return result", "task_id": "Python/450", "test_setup": "", "test": ["assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,8)==['practice', 'solution']", "assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,6)==['Python']", "assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,9)==['exercises']"], "challenge_test_list": [], "func_title": "def extract_string(str, l):\r", "prompt_text_chinese": "写一个函数，从一个给定的字符串列表中提取指定大小的字符串。", "code_comment": "定义一个函数 extract_string，接收两个参数 str 和 l，其中 str 是一个字符串，l 是一个数字\n使用列表生成式，获取字符串 str 中长度为 l 的子串，并将它们保存在一个新的列表中\n返回新的列表\n"}
{"prompt": "Write a function to remove all whitespaces from the given string using regex.", "canonical_solution": "import re\r\ndef remove_whitespaces(text1):\r\n  return (re.sub(r'\\s+', '',text1))", "task_id": "Python/451", "test_setup": "", "test": ["assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'", "assert remove_whitespaces(' Google    Dart ') == 'GoogleDart'", "assert remove_whitespaces(' iOS    Swift ') == 'iOSSwift'"], "challenge_test_list": [], "func_title": "def remove_whitespaces(text1):\r", "prompt_text_chinese": "写一个函数，使用regex从给定的字符串中删除所有的空白。", "code_comment": "导入 re 模块\n定义一个函数 remove_whitespaces，接收一个参数 text1，该参数是一个字符串\n使用 re.sub 函数，将 text1 中的所有空白字符（包括空格、制表符、换行符等）替换为空字符串，生成一个新的字符串，并将其返回\n"}
{"prompt": "Write a function that gives loss amount if the given amount has loss else return none.", "canonical_solution": "def loss_amount(actual_cost,sale_amount): \r\n  if(sale_amount > actual_cost):\r\n    amount = sale_amount - actual_cost\r\n    return amount\r\n  else:\r\n    return None", "task_id": "Python/452", "test_setup": "", "test": ["assert loss_amount(1500,1200)==None", "assert loss_amount(100,200)==100", "assert loss_amount(2000,5000)==3000"], "challenge_test_list": [], "func_title": "def loss_amount(actual_cost,sale_amount): \r", "prompt_text_chinese": "写一个函数，如果给定的金额有损失，则给出损失金额，否则返回无。", "code_comment": "定义一个函数 loss_amount，接收两个参数 actual_cost 和 sale_amount，这两个参数都是数字\n如果 sale_amount 大于 actual_cost，表示存在损失\n将 sale_amount 减去 actual_cost，得到损失的金额，并将其保存到变量 amount 中\n返回变量 amount 的值\n否则表示没有损失\n返回 None"}
{"prompt": "Write a python function to find the sum of even factors of a number.", "canonical_solution": "import math \r\ndef sumofFactors(n) : \r\n    if (n % 2 != 0) : \r\n        return 0\r\n    res = 1\r\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \r\n        count = 0\r\n        curr_sum = 1\r\n        curr_term = 1\r\n        while (n % i == 0) : \r\n            count= count + 1\r\n            n = n // i \r\n            if (i == 2 and count == 1) : \r\n                curr_sum = 0\r\n            curr_term = curr_term * i \r\n            curr_sum = curr_sum + curr_term \r\n        res = res * curr_sum  \r\n    if (n >= 2) : \r\n        res = res * (1 + n) \r\n    return res ", "task_id": "Python/453", "test_setup": "", "test": ["assert sumofFactors(18) == 26", "assert sumofFactors(30) == 48", "assert sumofFactors(6) == 8"], "challenge_test_list": [], "func_title": "def sumofFactors(n) : \r", "prompt_text_chinese": "写一个Python函数来寻找一个数字的偶数因子之和。", "code_comment": "导入 math 模块\n定义一个函数 sumofFactors，接收一个参数 n，该参数是一个数字\n如果参数 n 是奇数，则返回 0\n定义变量 res，初始值为 1\n遍历 2 到 sqrt(n) 之间的所有整数\n定义变量 count，用于计数 i 在 n 的因数中出现的次数\n定义变量 curr_sum，初始值为 1\n定义变量 curr_term，初始值为 1\n当 i 是 n 的因数时，执行以下操作\n将变量 count 的值加 1\n将 n 除以 i，并将结果赋值给 n\n如果 i 等于 2，并且 count 等于 1\n则将变量 curr_sum 的值设为 0\n将变量 curr_term 与 i 相乘，并将结果赋值给 curr_term\n将 curr_term 加到 curr_sum 上\n将 curr_sum 乘到 res 上\n如果 n 大于等于 2\n将 n + 1 乘到 res 上\n返回变量 res 的值"}
{"prompt": "Write a function that matches a word containing 'z'.", "canonical_solution": "import re\r\ndef text_match_wordz(text):\r\n        patterns = '\\w*z.\\w*'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')", "task_id": "Python/454", "test_setup": "", "test": ["assert text_match_wordz(\"pythonz.\")==('Found a match!')", "assert text_match_wordz(\"xyz.\")==('Found a match!')", "assert text_match_wordz(\"  lang  .\")==('Not matched!')"], "challenge_test_list": [], "func_title": "def text_match_wordz(text):\r", "prompt_text_chinese": "写一个函数来匹配一个包含 \"z \"的词。", "code_comment": "导入 re 模块\n定义一个函数 text_match_wordz，接收一个参数 text，该参数是一个字符串\n定义一个正则表达式模式，用于匹配所有包含字母 z 的单词\n如果 text 中存在符合模式的字符串\n返回字符串 'Found a match!'\n否则返回字符串 'Not matched!'\n"}
{"prompt": "Write a function to check whether the given month number contains 31 days or not.", "canonical_solution": "def check_monthnumb_number(monthnum2):\r\n  if(monthnum2==1 or monthnum2==3 or monthnum2==5 or monthnum2==7 or monthnum2==8 or monthnum2==10 or monthnum2==12):\r\n    return True\r\n  else:\r\n    return False", "task_id": "Python/455", "test_setup": "", "test": ["assert check_monthnumb_number(5)==True", "assert check_monthnumb_number(2)==False", "assert check_monthnumb_number(6)==False"], "challenge_test_list": [], "func_title": "def check_monthnumb_number(monthnum2):\r", "prompt_text_chinese": "写一个函数来检查给定的月号是否包含31天。", "code_comment": "定义一个函数 check_monthnumb_number，接收一个参数 monthnum2，该参数是一个数字\n如果参数 monthnum2 的值等于 1、3、5、7、8、10、12 中的任意一个，则返回 True\n否则返回 False"}
{"prompt": "Write a function to reverse strings in a given list of string values.", "canonical_solution": "def reverse_string_list(stringlist):\r\n    result = [x[::-1] for x in stringlist]\r\n    return result", "task_id": "Python/456", "test_setup": "", "test": ["assert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])==['deR', 'neerG', 'eulB', 'etihW', 'kcalB']", "assert reverse_string_list(['john','amal','joel','george'])==['nhoj','lama','leoj','egroeg']", "assert reverse_string_list(['jack','john','mary'])==['kcaj','nhoj','yram']"], "challenge_test_list": [], "func_title": "def reverse_string_list(stringlist):\r", "prompt_text_chinese": "写一个函数来反转给定的字符串列表中的字符串值。", "code_comment": "定义一个函数 reverse_string_list，接收一个参数 stringlist，该参数是一个字符串列表\n使用列表生成式，将字符串列表中的每个字符串反转，并将结果保存到一个新的列表中\n返回新的列表"}
{"prompt": "Write a python function to find the sublist having minimum length.", "canonical_solution": "def Find_Min(lst): \r\n    minList = min((x) for x in lst) \r\n    return minList", "task_id": "Python/457", "test_setup": "", "test": ["assert Find_Min([[1],[1,2],[1,2,3]]) == [1]", "assert Find_Min([[1,1],[1,1,1],[1,2,7,8]]) == [1,1]", "assert Find_Min([['x'],['x','y'],['x','y','z']]) == ['x']"], "challenge_test_list": [], "func_title": "def Find_Min(lst): \r", "prompt_text_chinese": "写一个Python函数，找出长度最小的子列表。", "code_comment": "定义一个函数 Find_Min，接收一个参数 lst，该参数是一个列表\n使用 min 函数，找到列表 lst 中的最小值，并将其赋值给变量 minList\n返回变量 minList 的值"}
{"prompt": "Write a function to find the area of a rectangle.", "canonical_solution": "def rectangle_area(l,b):\r\n  area=l*b\r\n  return area", "task_id": "Python/458", "test_setup": "", "test": ["assert rectangle_area(10,20)==200", "assert rectangle_area(10,5)==50", "assert rectangle_area(4,2)==8"], "challenge_test_list": [], "func_title": "def rectangle_area(l,b):\r", "prompt_text_chinese": "写一个函数来寻找一个矩形的面积。", "code_comment": "定义一个函数 rectangle_area，接收两个参数 l 和 b，这两个参数都是数字，分别表示长和宽\n计算矩形的面积，即长和宽的乘积，并将结果保存到变量 area 中\n返回变量 area 的值"}
{"prompt": "Write a function to remove uppercase substrings from a given string by using regex.", "canonical_solution": "import re\r\ndef remove_uppercase(str1):\r\n  remove_upper = lambda text: re.sub('[A-Z]', '', text)\r\n  result =  remove_upper(str1)\r\n  return (result)", "task_id": "Python/459", "test_setup": "", "test": ["assert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'", "assert remove_uppercase('wAtchTheinTernEtrAdIo') == 'wtchheinerntrdo'", "assert remove_uppercase('VoicESeaRchAndreComMendaTionS') == 'oiceachndreomendaion'"], "challenge_test_list": [], "func_title": "def remove_uppercase(str1):\r", "prompt_text_chinese": "写一个函数，通过使用regex从给定的字符串中删除大写字母子串。", "code_comment": "导入 re 模块\n定义一个函数 remove_uppercase，接收一个参数 str1，该参数是一个字符串\n定义一个匿名函数 remove_upper，使用 re.sub 函数，将字符串中的所有大写字母替换为空字符串\n调用匿名函数 remove_upper，将参数 str1 传给它，将返回结果保存到变量 result 中\n返回变量 result 的值\n"}
{"prompt": "Write a python function to get the first element of each sublist.", "canonical_solution": "def Extract(lst): \r\n    return [item[0] for item in lst] ", "task_id": "Python/460", "test_setup": "", "test": ["assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]", "assert Extract([[1,2,3],[4, 5]]) == [1,4]", "assert Extract([[9,8,1],[1,2]]) == [9,1]"], "challenge_test_list": [], "func_title": "def Extract(lst): \r", "prompt_text_chinese": "写一个python函数来获取每个子列表的第一个元素。", "code_comment": "定义一个函数 Extract，接收一个参数 lst，该参数是一个列表，列表的元素是元素为字符串的列表\n使用列表生成式，遍历列表 lst 中的每个元素，取出元素的第一个字符，将其保存到一个新的列表中，并将新的列表作为返回值返回\n"}
{"prompt": "Write a python function to count the upper case characters in a given string.", "canonical_solution": "def upper_ctr(str):\r\n    upper_ctr = 0\r\n    for i in range(len(str)):\r\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\r\n          return upper_ctr", "task_id": "Python/461", "test_setup": "", "test": ["assert upper_ctr('PYthon') == 1", "assert upper_ctr('BigData') == 1", "assert upper_ctr('program') == 0"], "challenge_test_list": [], "func_title": "def upper_ctr(str):\r", "prompt_text_chinese": "写一个python函数来计算给定字符串中的大写字符。", "code_comment": "定义一个函数 upper_ctr，接收一个参数 str，该参数是一个字符串\n定义变量 upper_ctr，用于计数大写字母的数量，初始值为 0\n如果字符串中的字符是大写字母，则将变量 upper_ctr 的值加 1\n返回变量 upper_ctr 的值？\n"}
{"prompt": "Write a function to find all possible combinations of the elements of a given list.", "canonical_solution": "def combinations_list(list1):\r\n    if len(list1) == 0:\r\n        return [[]]\r\n    result = []\r\n    for el in combinations_list(list1[1:]):\r\n        result += [el, el+[list1[0]]]\r\n    return result", "task_id": "Python/462", "test_setup": "", "test": ["assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]", "assert combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]", "assert combinations_list(['red', 'green', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]"], "challenge_test_list": [], "func_title": "def combinations_list(list1):\r", "prompt_text_chinese": "写一个函数来查找给定列表中所有元素的可能组合。", "code_comment": "定义一个函数 combinations_list，接收一个参数 list1，该参数是一个列表\n如果参数 list1 的长度为 0，则返回一个包含一个空列表的列表\n定义一个空列表 result，用于保存结果\n遍历调用函数 combinations_list(list1[1:]) 的返回结果（也就是 list1 中除去第一个元素后的子列表）中的每个元素\n将当前元素和当前元素加上 list1 的第一个元素的结果添加到列表 result 中\n返回列表 result"}
{"prompt": "Write a function to find the maximum product subarray of the given array.", "canonical_solution": "def max_subarray_product(arr):\r\n\tn = len(arr)\r\n\tmax_ending_here = 1\r\n\tmin_ending_here = 1\r\n\tmax_so_far = 0\r\n\tflag = 0\r\n\tfor i in range(0, n):\r\n\t\tif arr[i] > 0:\r\n\t\t\tmax_ending_here = max_ending_here * arr[i]\r\n\t\t\tmin_ending_here = min (min_ending_here * arr[i], 1)\r\n\t\t\tflag = 1\r\n\t\telif arr[i] == 0:\r\n\t\t\tmax_ending_here = 1\r\n\t\t\tmin_ending_here = 1\r\n\t\telse:\r\n\t\t\ttemp = max_ending_here\r\n\t\t\tmax_ending_here = max (min_ending_here * arr[i], 1)\r\n\t\t\tmin_ending_here = temp * arr[i]\r\n\t\tif (max_so_far < max_ending_here):\r\n\t\t\tmax_so_far = max_ending_here\r\n\tif flag == 0 and max_so_far == 0:\r\n\t\treturn 0\r\n\treturn max_so_far", "task_id": "Python/463", "test_setup": "", "test": ["assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112", "assert max_subarray_product([6, -3, -10, 0, 2]) == 180 ", "assert max_subarray_product([-2, -40, 0, -2, -3]) == 80"], "challenge_test_list": [], "func_title": "def max_subarray_product(arr):\r", "prompt_text_chinese": "写一个函数来寻找给定数组的最大乘积子数。", "code_comment": "定义一个函数 max_subarray_product，接收一个参数 arr，该参数是一个整数列表\n获取参数 arr 的长度\n定义变量 max_ending_here，表示以当前元素为结尾的最大子数组乘积，初始值为 1\n定义变量 min_ending_here，表示以当前元素为结尾的最小子数组乘积，初始值为 1\n定义变量 max_so_far，表示到目前为止最大的子数组乘积，初始值为 0\n定义变量 flag，初始值为 0\n遍历整个列表 arr\n如果当前元素大于 0\n将当前元素乘到 max_ending_here 上\n将当前元素乘到 min_ending_here 上，并和 1 取最小值\n将变量 flag 的值设为 1\n如果当前元素等于 0\n将 max_ending_here 的值设为 1\n将 min_ending_here 的值设为 1\n如果当前元素小于 0\n将当前元素乘到 min_ending_here 上，并将结果和 1 取最大值，将结果保存到 max_ending_here 中\n将当前元素乘到 temp 上，将结果保存到 min_ending_here 中\n如果 max_so_far 小于 max_ending_here\n将 max_ending_here 的值赋给 max_so_far\n如果 flag 的值为 0 且 max_so_far 的值为 0\n则返回 0\n返回 max_so_far 的值"}
{"prompt": "Write a function to check if all values are same in a dictionary.", "canonical_solution": "def check_value(dict, n):\r\n    result = all(x == n for x in dict.values()) \r\n    return result", "task_id": "Python/464", "test_setup": "", "test": ["assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},10)==False", "assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},12)==True", "assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},5)==False"], "challenge_test_list": [], "func_title": "def check_value(dict, n):\r", "prompt_text_chinese": "写一个函数来检查一个字典中的所有值是否相同。", "code_comment": "定义一个函数 check_value，接收两个参数 dict 和 n，其中 dict 是一个字典，n 是一个数字\n使用 all 函数，判断字典 dict 的所有值是否都等于 n，将结果保存到变量 result 中\n返回变量 result 的值？"}
{"prompt": "Write a function to drop empty items from a given dictionary.", "canonical_solution": "def drop_empty(dict1):\r\n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\r\n  return dict1", "task_id": "Python/465", "test_setup": "", "test": ["assert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3':None})=={'c1': 'Red', 'c2': 'Green'}", "assert drop_empty({'c1': 'Red', 'c2': None, 'c3':None})=={'c1': 'Red'}", "assert drop_empty({'c1': None, 'c2': 'Green', 'c3':None})=={ 'c2': 'Green'}"], "challenge_test_list": [], "func_title": "def drop_empty(dict1):\r", "prompt_text_chinese": "写一个函数，从给定的字典中删除空项。", "code_comment": "定义一个函数 drop_empty，接收一个参数 dict1，该参数是一个字典\n使用字典推导式，遍历字典 dict1 的所有键值对，如果值不为 None，则将该键值对添加到新的字典中\n返回新的字典\n"}
{"prompt": "Write a function to find the peak element in the given array.", "canonical_solution": "def find_peak_util(arr, low, high, n): \r\n\tmid = low + (high - low)/2\r\n\tmid = int(mid) \r\n\tif ((mid == 0 or arr[mid - 1] <= arr[mid]) and\r\n\t\t(mid == n - 1 or arr[mid + 1] <= arr[mid])): \r\n\t\treturn mid \r\n\telif (mid > 0 and arr[mid - 1] > arr[mid]): \r\n\t\treturn find_peak_util(arr, low, (mid - 1), n) \r\n\telse: \r\n\t\treturn find_peak_util(arr, (mid + 1), high, n) \r\ndef find_peak(arr, n): \r\n\treturn find_peak_util(arr, 0, n - 1, n) ", "task_id": "Python/466", "test_setup": "", "test": ["assert find_peak([1, 3, 20, 4, 1, 0], 6) == 2", "assert find_peak([2, 3, 4, 5, 6], 5) == 4", "assert find_peak([8, 9, 11, 12, 14, 15], 6) == 5 "], "challenge_test_list": [], "func_title": "def find_peak_util(arr, low, high, n): \r", "prompt_text_chinese": "写一个函数来寻找给定数组中的峰值元素。", "code_comment": "定义一个辅助函数 find_peak_util，接收四个参数 arr、low、high 和 n，其中 arr 是一个整数列表，low 和 high 分别表示要搜索区间的左右边界，n 表示列表 arr 的长度\n将区间的中间位置赋给 mid，注意要使用浮点数的除法\n将 mid 强制转换为整数类型\n如果 arr[mid] 是一个峰值，则返回 mid\n如果 arr[mid-1] 大于 arr[mid]，则说明左边存在一个峰值，将搜索区间缩小到左半边\n否则，说明右边存在一个峰值，将搜索区间缩小到右半边\n定义一个函数 find_peak，接收两个参数 arr 和 n，其中 arr 是一个整数列表，n 是列表 arr 的长度\n调用辅助函数 find_peak_util，将搜索区间的左右边界分别设为 0 和 n - 1，将列表 arr 的长度 n 作为第四个参数传入"}
{"prompt": "Write a python function to convert decimal number to octal number.", "canonical_solution": "def decimal_to_Octal(deciNum):\r\n    octalNum = 0\r\n    countval = 1;\r\n    dNo = deciNum;\r\n    while (deciNum!= 0):\r\n        remainder= deciNum % 8;\r\n        octalNum+= remainder*countval;\r\n        countval= countval*10;\r\n        deciNum //= 8; \r\n    return (octalNum)", "task_id": "Python/467", "test_setup": "", "test": ["assert decimal_to_Octal(10) == 12", "assert decimal_to_Octal(2) == 2", "assert decimal_to_Octal(33) == 41"], "challenge_test_list": [], "func_title": "def decimal_to_Octal(deciNum):\r", "prompt_text_chinese": "写一个将十进制数转换为八进制数的Python函数。", "code_comment": "定义一个函数 decimal_to_Octal，接收一个参数 deciNum，该参数是一个十进制整数\n定义变量 octalNum，用于保存转换后的八进制数，初始值为 0\n定义变量 countval，表示当前位数的权值，初始值为 1\n将要转换的十进制整数赋值给变量 dNo\n当十进制整数 deciNum 不为 0 时，执行下面的循环体\n取 deciNum 除以 8 的余数，将结果保存到变量 remainder 中\n将 remainder 乘以 countval，加到 octalNum 上\n将 countval 的值乘以 10，更新下一位数的权值\n将 deciNum 除以 8，更新 deciNum 的值\n返回转换后的八进制数"}
{"prompt": "Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.", "canonical_solution": "def max_product(arr, n ): \r\n\tmpis =[0] * (n) \r\n\tfor i in range(n): \r\n\t\tmpis[i] = arr[i] \r\n\tfor i in range(1, n): \r\n\t\tfor j in range(i): \r\n\t\t\tif (arr[i] > arr[j] and\r\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \r\n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \r\n\treturn max(mpis)", "task_id": "Python/468", "test_setup": "", "test": ["assert max_product([3, 100, 4, 5, 150, 6], 6) == 45000 ", "assert max_product([4, 42, 55, 68, 80], 5) == 50265600", "assert max_product([10, 22, 9, 33, 21, 50, 41, 60], 8) == 21780000 "], "challenge_test_list": [], "func_title": "def max_product(arr, n ): \r", "prompt_text_chinese": "写一个函数，找出由该数组的一个递增子序列的数字相乘形成的最大乘积。", "code_comment": "定义一个函数 max_product，接收两个参数 arr 和 n，其中 arr 是一个整数列表，n 是列表 arr 的长度\n创建一个长度为 n、元素都为 0 的列表 mpis，用于保存以每个元素为结尾的最大子数组乘积\n遍历整个列表 arr\n将列表 arr 中的每个元素的值赋给 mpis 中对应的项\n遍历整个列表 arr，从第二个元素开始\n将当前元素 arr[i] 和其左边的所有元素 arr[j] 一一比较\n如果 arr[i] 大于 arr[j] 且 mpis[j] * arr[i] 大于 mpis[i]\n将 mpis[j] * arr[i] 赋值给 mpis[i]\n返回列表 mpis 中的最大值\n"}
{"prompt": "Write a function to find the maximum profit earned from a maximum of k stock transactions", "canonical_solution": "def max_profit(price, k):\r\n    n = len(price)\r\n    final_profit = [[None for x in range(n)] for y in range(k + 1)]\r\n    for i in range(k + 1):\r\n        for j in range(n):\r\n            if i == 0 or j == 0:\r\n                final_profit[i][j] = 0\r\n            else:\r\n                max_so_far = 0\r\n                for x in range(j):\r\n                    curr_price = price[j] - price[x] + final_profit[i-1][x]\r\n                    if max_so_far < curr_price:\r\n                        max_so_far = curr_price\r\n                final_profit[i][j] = max(final_profit[i][j-1], max_so_far)\r\n    return final_profit[k][n-1]", "task_id": "Python/469", "test_setup": "", "test": ["assert max_profit([1, 5, 2, 3, 7, 6, 4, 5], 3) == 10", "assert max_profit([2, 4, 7, 5, 4, 3, 5], 2) == 7", "assert max_profit([10, 6, 8, 4, 2], 2) == 2"], "challenge_test_list": [], "func_title": "def max_profit(price, k):\r", "prompt_text_chinese": "写一个函数，找出从最大的k个股票交易中获得的最大利润。", "code_comment": "定义一个函数 max_profit，接收两个参数 price 和 k，其中 price 是一个整数列表，k 是一个整数\n获取列表 price 的长度，赋值给变量 n\n创建一个大小为 (k + 1) x n 的二维列表 final_profit，用于保存最终的利润\n遍历 0 到 k 这 k + 1 个整数\n遍历整个列表 price\n如果 i 或 j 的值为 0\n则 final_profit[i][j] 的值为 0\n定义变量 max_so_far，表示当前的最大利润，初始值为 0\n遍历 0 到 j-1 这 j 个整数\n计算当前的利润，将其保存到 curr_price 中\n如果当前的利润大于 max_so_far\n则将当前的利润赋值给 max_so_far\n将 final_profit[i][j-1] 和 max_so_far 中的较大值赋值给 final_profit[i][j]\n返回 final_profit[k][n-1] 的值"}
{"prompt": "Write a function to find the pairwise addition of the elements of the given tuples.", "canonical_solution": "def add_pairwise(test_tup):\r\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\r\n  return (res) ", "task_id": "Python/470", "test_setup": "", "test": ["assert add_pairwise((1, 5, 7, 8, 10)) == (6, 12, 15, 18)", "assert add_pairwise((2, 6, 8, 9, 11)) == (8, 14, 17, 20)", "assert add_pairwise((3, 7, 9, 10, 12)) == (10, 16, 19, 22)"], "challenge_test_list": [], "func_title": "def add_pairwise(test_tup):\r", "prompt_text_chinese": "写一个函数，找出给定图元的成对加数。", "code_comment": "定义一个函数 add_pairwise，接收一个参数 test_tup，该参数是一个元组\n使用 zip 函数，将 test_tup 中相邻的两个元素组成一个二元组，然后计算其对应位置上的元素之和，将结果保存到 res 中\n返回结果 res 作为一个元组"}
{"prompt": "Write a python function to find remainder of array multiplication divided by n.", "canonical_solution": "def find_remainder(arr, lens, n): \r\n    mul = 1\r\n    for i in range(lens):  \r\n        mul = (mul * (arr[i] % n)) % n \r\n    return mul % n ", "task_id": "Python/471", "test_setup": "", "test": ["assert find_remainder([ 100, 10, 5, 25, 35, 14 ],6,11) ==9", "assert find_remainder([1,1,1],3,1) == 0", "assert find_remainder([1,2,1],3,2) == 0"], "challenge_test_list": [], "func_title": "def find_remainder(arr, lens, n): \r", "prompt_text_chinese": "写一个python函数，求数组乘法除以n的余数。", "code_comment": "定义一个函数 find_remainder，接收三个参数 arr、lens 和 n，其中 arr 是一个整数列表，lens 是列表 arr 的长度，n 是一个整数\n定义变量 mul，表示列表 arr 中所有元素的余数的乘积，初始值为 1\n遍历整个列表 arr\n将 arr[i] 对 n 取余的结果乘到 mul 上，注意要每次都对 mul 取模\n返回 mul 对 n 取模的结果\n"}
{"prompt": "Write a python function to check whether the given list contains consecutive numbers or not.", "canonical_solution": "def check_Consecutive(l): \r\n    return sorted(l) == list(range(min(l),max(l)+1)) ", "task_id": "Python/472", "test_setup": "", "test": ["assert check_Consecutive([1,2,3,4,5]) == True", "assert check_Consecutive([1,2,3,5,6]) == False", "assert check_Consecutive([1,2,1]) == False"], "challenge_test_list": [], "func_title": "def check_Consecutive(l): \r", "prompt_text_chinese": "写一个python函数来检查给定的列表是否包含连续的数字。", "code_comment": "定义一个函数 check_Consecutive，接收一个参数 l，该参数是一个整数列表\n判断对列表 l 进行排序后是否等于从列表 l 中的最小值到最大值的连续整数序列，若相等则返回 True，否则返回 False\n"}
{"prompt": "Write a function to find the tuple intersection of elements in the given tuple list irrespective of their order.", "canonical_solution": "def tuple_intersection(test_list1, test_list2):\r\n  res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])\r\n  return (res)", "task_id": "Python/473", "test_setup": "", "test": ["assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)] , [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}", "assert tuple_intersection([(4, 1), (7, 4), (11, 13), (17, 14)] , [(1, 4), (7, 4), (16, 12), (10, 13)]) == {(4, 7), (1, 4)}", "assert tuple_intersection([(2, 1), (3, 2), (1, 3), (1, 4)] , [(11, 2), (2, 3), (6, 2), (1, 3)]) == {(1, 3), (2, 3)}"], "challenge_test_list": [], "func_title": "def tuple_intersection(test_list1, test_list2):\r", "prompt_text_chinese": "写一个函数来查找给定元组列表中元素的元组交集，而不考虑它们的顺序。", "code_comment": "定义一个函数 tuple_intersection，接收两个参数 test_list1 和 test_list2，这两个参数都是列表\n使用列表推导式，将两个列表中的元素进行排序后组成一个元组，并将所有元组存入集合中，取两个集合的交集，将结果保存到 res 中\n返回结果 res 作为一个集合\n"}
{"prompt": "Write a function to replace characters in a string.", "canonical_solution": "def replace_char(str1,ch,newch):\r\n str2 = str1.replace(ch, newch)\r\n return str2", "task_id": "Python/474", "test_setup": "", "test": ["assert replace_char(\"polygon\",'y','l')==(\"pollgon\")", "assert replace_char(\"character\",'c','a')==(\"aharaater\")", "assert replace_char(\"python\",'l','a')==(\"python\")"], "challenge_test_list": [], "func_title": "def replace_char(str1,ch,newch):\r", "prompt_text_chinese": "写一个函数来替换一个字符串中的字符。", "code_comment": "定义一个函数 replace_char，接收三个参数 str1、ch 和 newch，其中 str1 是一个字符串，ch 和 newch 均为单个字符\n将字符串 str1 中所有的字符 ch 替换为 newch，将结果保存到 str2 中\n返回结果 str2"}
{"prompt": "Write a function to sort counter by value.", "canonical_solution": "from collections import Counter\r\ndef sort_counter(dict1):\r\n x = Counter(dict1)\r\n sort_counter=x.most_common()\r\n return sort_counter", "task_id": "Python/475", "test_setup": "", "test": ["assert sort_counter({'Math':81, 'Physics':83, 'Chemistry':87})==[('Chemistry', 87), ('Physics', 83), ('Math', 81)]", "assert sort_counter({'Math':400, 'Physics':300, 'Chemistry':250})==[('Math', 400), ('Physics', 300), ('Chemistry', 250)]", "assert sort_counter({'Math':900, 'Physics':1000, 'Chemistry':1250})==[('Chemistry', 1250), ('Physics', 1000), ('Math', 900)]"], "challenge_test_list": [], "func_title": "def sort_counter(dict1):\r", "prompt_text_chinese": "写一个函数，按值对计数器进行排序。", "code_comment": "导入模块 collections 中的 Counter 类\n定义一个函数 sort_counter，接收一个参数 dict1，该参数是一个字典\n使用 Counter 类，将字典 dict1 转换为一个计数器，将结果保存到 x 中\n使用 most_common 方法，按照计数器中元素的出现次数从大到小排序，将结果保存到 sort_counter 中\n返回排序后的结果 sort_counter"}
{"prompt": "Write a python function to find the sum of the largest and smallest value in a given array.", "canonical_solution": "def big_sum(nums):\r\n      sum= max(nums)+min(nums)\r\n      return sum", "task_id": "Python/476", "test_setup": "", "test": ["assert big_sum([1,2,3]) == 4", "assert big_sum([-1,2,3,4]) == 3", "assert big_sum([2,3,6]) == 8"], "challenge_test_list": [], "func_title": "def big_sum(nums):\r", "prompt_text_chinese": "写一个python函数，找出给定数组中最大和最小的数值之和。", "code_comment": "定义一个函数 big_sum，接收一个参数 nums，该参数是一个整数列表\n计算列表 nums 中的最大值加上最小值，将结果保存到变量 sum 中\n返回计算结果 sum"}
{"prompt": "Write a python function to convert the given string to lower case.", "canonical_solution": "def is_lower(string):\r\n  return (string.lower())", "task_id": "Python/477", "test_setup": "", "test": ["assert is_lower(\"InValid\") == \"invalid\"", "assert is_lower(\"TruE\") == \"true\"", "assert is_lower(\"SenTenCE\") == \"sentence\""], "challenge_test_list": [], "func_title": "def is_lower(string):\r", "prompt_text_chinese": "编写一个Python函数，将给定的字符串转换为小写。", "code_comment": "定义一个函数 is_lower，接收一个参数 string，该参数是一个字符串\n将参数 string 转换为小写字母，并返回结果"}
{"prompt": "Write a function to remove lowercase substrings from a given string.", "canonical_solution": "import re\r\ndef remove_lowercase(str1):\r\n remove_lower = lambda text: re.sub('[a-z]', '', text)\r\n result =  remove_lower(str1)\r\n return result", "task_id": "Python/478", "test_setup": "", "test": ["assert remove_lowercase(\"PYTHon\")==('PYTH')", "assert remove_lowercase(\"FInD\")==('FID')", "assert remove_lowercase(\"STRinG\")==('STRG')"], "challenge_test_list": [], "func_title": "def remove_lowercase(str1):\r", "prompt_text_chinese": "写一个函数，从给定的字符串中删除小写的子串。", "code_comment": "导入模块 re，用于操作正则表达式\n定义一个函数 remove_lowercase，接收一个参数 str1，该参数是一个字符串\n使用 lambda 函数，定义一个匿名函数 remove_lower，用于移除字符串中所有的小写字符\n调用匿名函数 remove_lower，将字符串 str1 作为参数传入，将结果保存到 result 中\n返回结果 result\n"}
{"prompt": "Write a python function to find the first digit of a given number.", "canonical_solution": "def first_Digit(n) :  \r\n    while n >= 10:  \r\n        n = n / 10; \r\n    return int(n) ", "task_id": "Python/479", "test_setup": "", "test": ["assert first_Digit(123) == 1", "assert first_Digit(456) == 4", "assert first_Digit(12) == 1"], "challenge_test_list": [], "func_title": "def first_Digit(n) :  \r", "prompt_text_chinese": "写一个Python函数来寻找一个给定数字的第一个数字。", "code_comment": "定义一个函数 first_Digit，接收一个参数 n，该参数是一个整数\n当 n 大于等于 10 时，执行以下循环体\n将 n 除以 10，将得到的商作为新的 n\n返回 n 的整数部分"}
{"prompt": "Write a python function to find the maximum occurring character in a given string.", "canonical_solution": "def get_max_occuring_char(str1):\r\n  ASCII_SIZE = 256\r\n  ctr = [0] * ASCII_SIZE\r\n  max = -1\r\n  ch = ''\r\n  for i in str1:\r\n    ctr[ord(i)]+=1;\r\n  for i in str1:\r\n    if max < ctr[ord(i)]:\r\n      max = ctr[ord(i)]\r\n      ch = i\r\n  return ch", "task_id": "Python/480", "test_setup": "", "test": ["assert get_max_occuring_char(\"data\") == \"a\"", "assert get_max_occuring_char(\"create\") == \"e\"", "assert get_max_occuring_char(\"brilliant girl\") == \"i\""], "challenge_test_list": [], "func_title": "def get_max_occuring_char(str1):\r", "prompt_text_chinese": "写一个python函数，找出给定字符串中出现的最大字符。", "code_comment": "定义一个函数 get_max_occuring_char，接收一个参数 str1，该参数是一个字符串\nASCII 码的大小，即 ASCII 码表中字符的个数\n定义一个长度为 ASCII_SIZE 的列表 ctr，初始值为 0\n定义变量 max，表示字符串 str1 中出现次数最多的字符的出现次数，初始值为 -1\n定义变量 ch，表示字符串 str1 中出现次数最多的字符，初始值为空\n遍历字符串 str1 的所有字符\n将字符 i 转换成 ASCII 码后，将对应位置上的元素加 1\n遍历字符串 str1 的所有字符\n如果字符 i 出现的次数大于 max\n将 max 更新为字符 i 出现的次数\n将 ch 更新为字符 i\n返回 ch，即出现次数最多的字符"}
{"prompt": "Write a function to determine if there is a subset of the given set with sum equal to the given sum.", "canonical_solution": "def is_subset_sum(set, n, sum):\r\n\tif (sum == 0):\r\n\t\treturn True\r\n\tif (n == 0):\r\n\t\treturn False\r\n\tif (set[n - 1] > sum):\r\n\t\treturn is_subset_sum(set, n - 1, sum)\r\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "task_id": "Python/481", "test_setup": "", "test": ["assert is_subset_sum([3, 34, 4, 12, 5, 2], 6, 9) == True", "assert is_subset_sum([3, 34, 4, 12, 5, 2], 6, 30) == False", "assert is_subset_sum([3, 34, 4, 12, 5, 2], 6, 15) == True"], "challenge_test_list": [], "func_title": "def is_subset_sum(set, n, sum):\r", "prompt_text_chinese": "写一个函数来确定在给定的集合中是否有一个子集，其总和等于给定的总和。", "code_comment": "定义一个函数 is_subset_sum，接收三个参数 set、n 和 sum，其中 set 是一个整数列表，n 是列表 set 的长度，sum 是一个整数\n如果 sum 等于 0，说明找到了一个子集使得子集中所有元素的和等于 sum，返回 True\n如果 n 等于 0，说明没有找到任何子集使得子集中所有元素的和等于 sum，返回 False\n如果列表 set 中的第 n - 1 个元素大于 sum，说明该元素不能被包含在子集中，递归查找子集，排除该元素\n递归查找子集，分别包含和不包含列表 set 中的第 n - 1 个元素，如果两种情况中任意一种情况中找到了一个子集满足子集中所有元素的和等于 sum，返回 True，否则返回 False"}
{"prompt": "Write a function to find sequences of one upper case letter followed by lower case letters in the given string by using regex.", "canonical_solution": "import re \r\ndef match(text): \r\n\t\tpattern = '[A-Z]+[a-z]+$'\r\n\t\tif re.search(pattern, text): \r\n\t\t\t\treturn('Yes') \r\n\t\telse: \r\n\t\t\t\treturn('No') ", "task_id": "Python/482", "test_setup": "", "test": ["assert match(\"Geeks\") == 'Yes'", "assert match(\"geeksforGeeks\") == 'Yes'", "assert match(\"geeks\") == 'No'"], "challenge_test_list": [], "func_title": "def match(text): \r", "prompt_text_chinese": "写一个函数，通过使用regex在给定的字符串中找到一个大写字母和一个小写字母的序列。", "code_comment": "导入模块 re，用于操作正则表达式\n定义一个函数 match，接收一个参数 text，该参数是一个字符串\n定义一个正则表达式模式，该模式用于匹配仅包含一个大写字母和若干个小写字母的字符串\n如果参数 text 中含有符合模式 pattern 的子串，返回 'Yes'\n否则返回 'No'\n"}
{"prompt": "Write a python function to find the first natural number whose factorial is divisible by x.", "canonical_solution": "def first_Factorial_Divisible_Number(x): \r\n    i = 1;\r\n    fact = 1; \r\n    for i in range(1,x): \r\n        fact = fact * i \r\n        if (fact % x == 0): \r\n            break\r\n    return i ", "task_id": "Python/483", "test_setup": "", "test": ["assert first_Factorial_Divisible_Number(10) == 5", "assert first_Factorial_Divisible_Number(15) == 5", "assert first_Factorial_Divisible_Number(5) == 4"], "challenge_test_list": [], "func_title": "def first_Factorial_Divisible_Number(x): \r", "prompt_text_chinese": "写一个Python函数来寻找第一个阶乘能被x整除的自然数。", "code_comment": "定义一个函数 first_Factorial_Divisible_Number，接收一个参数 x，该参数是一个整数\n定义变量 i，初始值为 1\n定义变量 fact，初始值为 1\n遍历 1 到 x - 1 之间的所有整数\n计算 1 到 i 之间所有整数的乘积，将结果保存到 fact 中\n如果 fact 能被 x 整除\n结束循环\n返回变量 i"}
{"prompt": "Write a function to remove the matching tuples from the given two tuples.", "canonical_solution": "def remove_matching_tuple(test_list1, test_list2):\r\n  res = [sub for sub in test_list1 if sub not in test_list2]\r\n  return (res) ", "task_id": "Python/484", "test_setup": "", "test": ["assert remove_matching_tuple([('Hello', 'dude'), ('How', 'are'), ('you', '?')], [('Hello', 'dude'), ('How', 'are')]) == [('you', '?')]", "assert remove_matching_tuple([('Part', 'of'), ('the', 'journey'), ('is ', 'end')], [('Journey', 'the'), ('is', 'end')]) == [('Part', 'of'), ('the', 'journey'), ('is ', 'end')]", "assert remove_matching_tuple([('Its', 'been'), ('a', 'long'), ('day', 'without')], [('a', 'long'), ('my', 'friend')]) == [('Its', 'been'), ('day', 'without')]"], "challenge_test_list": [], "func_title": "def remove_matching_tuple(test_list1, test_list2):\r", "prompt_text_chinese": "写一个函数，从给定的两个图元中删除匹配的图元。", "code_comment": "定义一个函数 remove_matching_tuple，接收两个参数 test_list1 和 test_list2，均为元组列表\n通过列表解析，遍历 test_list1 中的所有元素，如果元素不在 test_list2 中，则将其添加到结果列表 res 中\n返回结果列表 res"}
{"prompt": "Write a function to find the largest palindromic number in the given array.", "canonical_solution": "def is_palindrome(n) : \r\n\tdivisor = 1\r\n\twhile (n / divisor >= 10) : \r\n\t\tdivisor *= 10\r\n\twhile (n != 0) : \r\n\t\tleading = n // divisor \r\n\t\ttrailing = n % 10\r\n\t\tif (leading != trailing) : \r\n\t\t\treturn False\r\n\t\tn = (n % divisor) // 10\r\n\t\tdivisor = divisor // 100\r\n\treturn True\r\ndef largest_palindrome(A, n) : \r\n\tA.sort() \r\n\tfor i in range(n - 1, -1, -1) : \r\n\t\tif (is_palindrome(A[i])) : \r\n\t\t\treturn A[i] \r\n\treturn -1", "task_id": "Python/485", "test_setup": "", "test": ["assert largest_palindrome([1, 232, 54545, 999991], 4) == 54545", "assert largest_palindrome([1, 2, 3, 4, 5, 50], 6) == 5", "assert largest_palindrome([1, 3, 7, 9, 45], 5)  == 9"], "challenge_test_list": [], "func_title": "def is_palindrome(n) : \r", "prompt_text_chinese": "写一个函数，找出给定数组中最大的宫格数。", "code_comment": "定义一个函数 is_palindrome，接收一个参数 n，该参数是一个整数\n定义变量 divisor，初始值为 1\n循环计算 divisor，使得 divisor 是 n 的最高位数字所在的位数\n当 n 不等于 0 时，执行以下循环体\n计算 n 的最高位数字\n计算 n 的个位数字\n如果最高位数字与个位数字不相等，返回 False\n去掉 n 的最高位数字和个位数字，将结果保存到 n 中\n将 divisor 除以 100，保留整数部分，即去掉原来的两位数字，更新 divisor 的值\n如果没有返回 False，说明 n 是回文数，返回 True\n定义一个函数 largest_palindrome，接收两个参数 A 和 n，其中 A 是一个整数列表，n 是列表 A 的长度\n将列表 A 中的元素按升序排序\n倒序遍历列表 A 的所有元素\n如果 A[i] 是回文数，返回 A[i]\n如果没有找到回文数，返回 -1"}
{"prompt": "Write a function to compute binomial probability for the given number.", "canonical_solution": "def nCr(n, r): \r\n\tif (r > n / 2): \r\n\t\tr = n - r \r\n\tanswer = 1 \r\n\tfor i in range(1, r + 1): \r\n\t\tanswer *= (n - r + i) \r\n\t\tanswer /= i \r\n\treturn answer \r\ndef binomial_probability(n, k, p): \r\n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "task_id": "Python/486", "test_setup": "", "test": ["assert binomial_probability(10, 5, 1.0/3) == 0.13656454808718185", "assert binomial_probability(11, 6, 2.0/4) == 0.2255859375", "assert binomial_probability(12, 7, 3.0/5) == 0.227030335488"], "challenge_test_list": [], "func_title": "def nCr(n, r): \r", "prompt_text_chinese": "写一个函数来计算给定数字的二项式概率。", "code_comment": "定义一个函数 nCr，接收两个参数 n 和 r，均为整数\n如果 r 大于 n 的一半，将 r 更新为 n - r，因为 C(n, r) = C(n, n - r)\n定义变量 answer，初始值为 1\n遍历 1 到 r 之间的所有整数\n计算 n - r + i 的乘积，将结果保存到变量 answer 中\n将 answer 除以 i\n返回 answer，即组合数 C(n, r)\n定义一个函数 binomial_probability，接收三个参数 n、k 和 p，均为实数\n返回二项分布概率密度函数的值\n"}
{"prompt": "Write a function to sort a list of tuples in increasing order by the last element in each tuple.", "canonical_solution": "def sort_tuple(tup): \r\n\tlst = len(tup) \r\n\tfor i in range(0, lst): \r\n\t\tfor j in range(0, lst-i-1): \r\n\t\t\tif (tup[j][-1] > tup[j + 1][-1]): \r\n\t\t\t\ttemp = tup[j] \r\n\t\t\t\ttup[j]= tup[j + 1] \r\n\t\t\t\ttup[j + 1]= temp \r\n\treturn tup", "task_id": "Python/487", "test_setup": "", "test": ["assert sort_tuple([(1, 3), (3, 2), (2, 1)] ) == [(2, 1), (3, 2), (1, 3)]", "assert sort_tuple([(2, 4), (3, 3), (1, 1)] ) == [(1, 1), (3, 3), (2, 4)]", "assert sort_tuple([(3, 9), (6, 7), (4, 3)] ) == [(4, 3), (6, 7), (3, 9)]"], "challenge_test_list": [], "func_title": "def sort_tuple(tup): \r", "prompt_text_chinese": "写一个函数，按照每个元组中的最后一个元素，将一个元组列表按递增顺序排序。", "code_comment": "定义一个函数 sort_tuple，接收一个参数 tup，该参数是一个元组\n获取元组 tup 的长度，保存到变量 lst 中\n外层循环，遍历元组 tup 中的所有元素\n内层循环，遍历元组 tup 中除最后 i 个元素之外的所有元素\n如果元组 tup 中第 j 个元素的最后一个元素大于第 j + 1 个元素的最后一个元素\n交换元组 tup 中第 j 个元素和第 j + 1 个元素的位置\n返回排序后的元组 tup"}
{"prompt": "Write a function to find the area of a pentagon.", "canonical_solution": "import math\r\ndef area_pentagon(a):\r\n  area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))/4.0\r\n  return area", "task_id": "Python/488", "test_setup": "", "test": ["assert area_pentagon(5)==43.01193501472417", "assert area_pentagon(10)==172.0477400588967", "assert area_pentagon(15)==387.10741513251753"], "challenge_test_list": [], "func_title": "def area_pentagon(a):\r", "prompt_text_chinese": "写一个函数来求五边形的面积。", "code_comment": "导入模块 math，用于进行数学计算\n定义一个函数 area_pentagon，接收一个参数 a，该参数是一个浮点数，表示五边形的边长\n根据五边形的边长计算五边形的面积，将结果保存到变量 area 中\n返回五边形的面积"}
{"prompt": "Write a python function to find the frequency of the largest value in a given array.", "canonical_solution": "def frequency_Of_Largest(n,arr): \r\n    mn = arr[0] \r\n    freq = 1\r\n    for i in range(1,n): \r\n        if (arr[i] >mn): \r\n            mn = arr[i] \r\n            freq = 1\r\n        elif (arr[i] == mn): \r\n            freq += 1\r\n    return freq ", "task_id": "Python/489", "test_setup": "", "test": ["assert frequency_Of_Largest(5,[1,2,3,4,4]) == 2", "assert frequency_Of_Largest(3,[5,6,5]) == 1", "assert frequency_Of_Largest(4,[2,7,7,7]) == 3"], "challenge_test_list": [], "func_title": "def frequency_Of_Largest(n,arr): \r", "prompt_text_chinese": "写一个Python函数，找出一个给定数组中最大值的频率。", "code_comment": "定义一个函数 frequency_Of_Largest，接收两个参数 n 和 arr，其中 n 是一个整数，arr 是一个整数列表\n定义变量 mn，保存列表 arr 中第一个元素的值\n定义变量 freq，表示最大值在列表 arr 中出现的次数，初始值为 1\n遍历列表 arr 中除第一个元素之外的所有元素\n如果第 i 个元素大于变量 mn 的值\n更新变量 mn 的值为第 i 个元素的值\n将变量 freq 的值更新为 1\n如果第 i 个元素等于变量 mn 的值\n将变量 freq 的值加 1\n返回变量 freq，即最大值在列表 arr 中出现的次数"}
{"prompt": "Write a function to extract all the pairs which are symmetric in the given tuple list.", "canonical_solution": "def extract_symmetric(test_list):\r\n  temp = set(test_list) & {(b, a) for a, b in test_list}\r\n  res = {(a, b) for a, b in temp if a < b}\r\n  return (res) ", "task_id": "Python/490", "test_setup": "", "test": ["assert extract_symmetric([(6, 7), (2, 3), (7, 6), (9, 8), (10, 2), (8, 9)] ) == {(8, 9), (6, 7)}", "assert extract_symmetric([(7, 8), (3, 4), (8, 7), (10, 9), (11, 3), (9, 10)] ) == {(9, 10), (7, 8)}", "assert extract_symmetric([(8, 9), (4, 5), (9, 8), (11, 10), (12, 4), (10, 11)] ) == {(8, 9), (10, 11)}"], "challenge_test_list": [], "func_title": "def extract_symmetric(test_list):\r", "prompt_text_chinese": "写一个函数，提取给定元组列表中所有对称的对。", "code_comment": "定义一个函数 extract_symmetric，接收一个参数 test_list，该参数是由元组组成的列表\n通过集合运算，找出列表 test_list 中所有对称的元素，并将其保存到集合 temp 中\n从集合 temp 中找出所有第一个元素小于第二个元素的元素，将其保存到集合 res 中\n返回集合 res"}
{"prompt": "Write a function to find the sum of geometric progression series.", "canonical_solution": "import math\r\ndef sum_gp(a,n,r):\r\n total = (a * (1 - math.pow(r, n ))) / (1- r)\r\n return total", "task_id": "Python/491", "test_setup": "", "test": ["assert sum_gp(1,5,2)==31", "assert sum_gp(1,5,4)==341", "assert sum_gp(2,6,3)==728"], "challenge_test_list": [], "func_title": "def sum_gp(a,n,r):\r", "prompt_text_chinese": "写一个函数来寻找几何级数系列的总和。", "code_comment": "导入模块 math，用于进行数学计算\n定义一个函数 sum_gp，接收三个参数 a、n 和 r，其中 a 和 r 是实数，n 是一个整数\n根据首项 a、项数 n 和公比 r 计算等比数列的和，将结果保存到变量 total 中\n返回等比数列的和"}
{"prompt": "Write a function to search an element in the given array by using binary search.", "canonical_solution": "def binary_search(item_list,item):\r\n\tfirst = 0\r\n\tlast = len(item_list)-1\r\n\tfound = False\r\n\twhile( first<=last and not found):\r\n\t\tmid = (first + last)//2\r\n\t\tif item_list[mid] == item :\r\n\t\t\tfound = True\r\n\t\telse:\r\n\t\t\tif item < item_list[mid]:\r\n\t\t\t\tlast = mid - 1\r\n\t\t\telse:\r\n\t\t\t\tfirst = mid + 1\t\r\n\treturn found", "task_id": "Python/492", "test_setup": "", "test": ["assert binary_search([1,2,3,5,8], 6) == False", "assert binary_search([7, 8, 9, 10, 13], 10) == True", "assert binary_search([11, 13, 14, 19, 22, 36], 23) == False"], "challenge_test_list": [], "func_title": "def binary_search(item_list,item):\r", "prompt_text_chinese": "写一个函数，通过使用二进制搜索在给定的数组中搜索一个元素。", "code_comment": "定义一个函数 binary_search，接收两个参数 item_list 和 item，其中 item_list 是一个列表，item 是一个元素\n定义变量 first，初始值为 0\n定义变量 last，初始值为 item_list 的长度减 1\n定义变量 found，表示是否在 item_list 中找到元素 item，初始值为 False\n当 first 小于等于 last 且没有找到元素 item 时，执行以下循环体\n计算变量 mid，该变量表示 item_list 的中间元素的下标\n如果 item_list 的中间元素等于元素 item\n将变量 found 的值更新为 True，表示找到了元素 item\n如果元素 item 小于 item_list 的中间元素\n更新变量 last 的值为 mid - 1，表示在左侧区间继续查找\n否则，即元素 item 大于 item_list 的中间元素\n更新变量 first 的值为 mid + 1，表示在右侧区间继续查找\n返回变量 found 的值，表示是否在 item_list 中找到元素 item"}
{"prompt": "Write a function to calculate a grid of hexagon coordinates where function returns a list of lists containing 6 tuples of x, y point coordinates.", "canonical_solution": "import math\r\ndef calculate_polygons(startx, starty, endx, endy, radius):\r\n    sl = (2 * radius) * math.tan(math.pi / 6)\r\n    p = sl * 0.5\r\n    b = sl * math.cos(math.radians(30))\r\n    w = b * 2\r\n    h = 2 * sl   \r\n    startx = startx - w\r\n    starty = starty - h\r\n    endx = endx + w\r\n    endy = endy + h\r\n    origx = startx\r\n    origy = starty\r\n    xoffset = b\r\n    yoffset = 3 * p\r\n    polygons = []\r\n    row = 1\r\n    counter = 0\r\n    while starty < endy:\r\n        if row % 2 == 0:\r\n            startx = origx + xoffset\r\n        else:\r\n            startx = origx\r\n        while startx < endx:\r\n            p1x = startx\r\n            p1y = starty + p\r\n            p2x = startx\r\n            p2y = starty + (3 * p)\r\n            p3x = startx + b\r\n            p3y = starty + h\r\n            p4x = startx + w\r\n            p4y = starty + (3 * p)\r\n            p5x = startx + w\r\n            p5y = starty + p\r\n            p6x = startx + b\r\n            p6y = starty\r\n            poly = [\r\n                (p1x, p1y),\r\n                (p2x, p2y),\r\n                (p3x, p3y),\r\n                (p4x, p4y),\r\n                (p5x, p5y),\r\n                (p6x, p6y),\r\n                (p1x, p1y)]\r\n            polygons.append(poly)\r\n            counter += 1\r\n            startx += w\r\n        starty += yoffset\r\n        row += 1\r\n    return polygons", "task_id": "Python/493", "test_setup": "", "test": ["assert calculate_polygons(1,1, 4, 4, 3)==[[(-5.0, -4.196152422706632), (-5.0, -0.7320508075688767), (-2.0, 1.0), (1.0, -0.7320508075688767), (1.0, -4.196152422706632), (-2.0, -5.928203230275509), (-5.0, -4.196152422706632)], [(1.0, -4.196152422706632), (1.0, -0.7320508075688767), (4.0, 1.0), (7.0, -0.7320508075688767), (7.0, -4.196152422706632), (4.0, -5.928203230275509), (1.0, -4.196152422706632)], [(7.0, -4.196152422706632), (7.0, -0.7320508075688767), (10.0, 1.0), (13.0, -0.7320508075688767), (13.0, -4.196152422706632), (10.0, -5.928203230275509), (7.0, -4.196152422706632)], [(-2.0, 1.0000000000000004), (-2.0, 4.464101615137755), (1.0, 6.196152422706632), (4.0, 4.464101615137755), (4.0, 1.0000000000000004), (1.0, -0.7320508075688767), (-2.0, 1.0000000000000004)], [(4.0, 1.0000000000000004), (4.0, 4.464101615137755), (7.0, 6.196152422706632), (10.0, 4.464101615137755), (10.0, 1.0000000000000004), (7.0, -0.7320508075688767), (4.0, 1.0000000000000004)], [(-5.0, 6.196152422706632), (-5.0, 9.660254037844387), (-2.0, 11.392304845413264), (1.0, 9.660254037844387), (1.0, 6.196152422706632), (-2.0, 4.464101615137755), (-5.0, 6.196152422706632)], [(1.0, 6.196152422706632), (1.0, 9.660254037844387), (4.0, 11.392304845413264), (7.0, 9.660254037844387), (7.0, 6.196152422706632), (4.0, 4.464101615137755), (1.0, 6.196152422706632)], [(7.0, 6.196152422706632), (7.0, 9.660254037844387), (10.0, 11.392304845413264), (13.0, 9.660254037844387), (13.0, 6.196152422706632), (10.0, 4.464101615137755), (7.0, 6.196152422706632)], [(-2.0, 11.392304845413264), (-2.0, 14.85640646055102), (1.0, 16.588457268119896), (4.0, 14.85640646055102), (4.0, 11.392304845413264), (1.0, 9.660254037844387), (-2.0, 11.392304845413264)], [(4.0, 11.392304845413264), (4.0, 14.85640646055102), (7.0, 16.588457268119896), (10.0, 14.85640646055102), (10.0, 11.392304845413264), (7.0, 9.660254037844387), (4.0, 11.392304845413264)]]", "assert calculate_polygons(5,4,7,9,8)==[[(-11.0, -9.856406460551018), (-11.0, -0.6188021535170058), (-3.0, 4.0), (5.0, -0.6188021535170058), (5.0, -9.856406460551018), (-3.0, -14.475208614068023), (-11.0, -9.856406460551018)], [(5.0, -9.856406460551018), (5.0, -0.6188021535170058), (13.0, 4.0), (21.0, -0.6188021535170058), (21.0, -9.856406460551018), (13.0, -14.475208614068023), (5.0, -9.856406460551018)], [(21.0, -9.856406460551018), (21.0, -0.6188021535170058), (29.0, 4.0), (37.0, -0.6188021535170058), (37.0, -9.856406460551018), (29.0, -14.475208614068023), (21.0, -9.856406460551018)], [(-3.0, 4.0), (-3.0, 13.237604307034012), (5.0, 17.856406460551018), (13.0, 13.237604307034012), (13.0, 4.0), (5.0, -0.6188021535170058), (-3.0, 4.0)], [(13.0, 4.0), (13.0, 13.237604307034012), (21.0, 17.856406460551018), (29.0, 13.237604307034012), (29.0, 4.0), (21.0, -0.6188021535170058), (13.0, 4.0)], [(-11.0, 17.856406460551018), (-11.0, 27.09401076758503), (-3.0, 31.712812921102035), (5.0, 27.09401076758503), (5.0, 17.856406460551018), (-3.0, 13.237604307034012), (-11.0, 17.856406460551018)], [(5.0, 17.856406460551018), (5.0, 27.09401076758503), (13.0, 31.712812921102035), (21.0, 27.09401076758503), (21.0, 17.856406460551018), (13.0, 13.237604307034012), (5.0, 17.856406460551018)], [(21.0, 17.856406460551018), (21.0, 27.09401076758503), (29.0, 31.712812921102035), (37.0, 27.09401076758503), (37.0, 17.856406460551018), (29.0, 13.237604307034012), (21.0, 17.856406460551018)], [(-3.0, 31.712812921102035), (-3.0, 40.95041722813605), (5.0, 45.569219381653056), (13.0, 40.95041722813605), (13.0, 31.712812921102035), (5.0, 27.09401076758503), (-3.0, 31.712812921102035)], [(13.0, 31.712812921102035), (13.0, 40.95041722813605), (21.0, 45.569219381653056), (29.0, 40.95041722813605), (29.0, 31.712812921102035), (21.0, 27.09401076758503), (13.0, 31.712812921102035)]]", "assert calculate_polygons(9,6,4,3,2)==[[(5.0, 2.5358983848622456), (5.0, 4.8452994616207485), (7.0, 6.0), (9.0, 4.8452994616207485), (9.0, 2.5358983848622456), (7.0, 1.3811978464829942), (5.0, 2.5358983848622456)], [(7.0, 6.0), (7.0, 8.309401076758503), (9.0, 9.464101615137753), (11.0, 8.309401076758503), (11.0, 6.0), (9.0, 4.8452994616207485), (7.0, 6.0)]]"], "challenge_test_list": [], "func_title": "def calculate_polygons(startx, starty, endx, endy, radius):\r", "prompt_text_chinese": "写一个函数来计算六边形坐标的网格，其中函数返回一个包含6个x，y点坐标图元组的列表。", "code_comment": "导入模块 math，用于进行数学计算\n定义一个函数 calculate_polygons，接收五个参数 startx、starty、endx、endy 和 radius，均为实数\n计算正六边形的边长，将结果保存到变量 sl 中\n计算正六边形的高，将结果保存到变量 p 中\n计算正六边形短边的长度，将结果保存到变量 b 中\n计算正六边形宽的长度，将结果保存到变量 w 中\n计算正六边形高的长度，将结果保存到变量 h 中\n更新变量 startx 的值，表示正六边形所在的最左侧的 x 坐标\n更新变量 starty 的值，表示正六边形所在的最上方的 y 坐标\n更新变量 endx 的值，表示正六边形所在的最右侧的 x 坐标\n更新变量 endy 的值，表示正六边形所在的最下方的 y 坐标\n保存变量 startx 的值到变量 origx 中\n保存变量 starty 的值到变量 origy 中\n保存变量 b 的值到变量 xoffset 中\n保存变量 p 的值乘以 3 到变量 yoffset 中\n定义一个空列表 polygons，用于保存所有的正六边形\n定义变量 row，表示正六边形所在的行数，初始值为 1\n定义变量 counter，表示正六边形的编号，初始值为 0\n当变量 starty 的值小于变量 endy 的值时，执行以下循环体\n如果变量 row 的值是偶数\n更新变量 startx 的值，表示正六边形所在的 x 坐标需要向右偏移一个 b 的长度\n如果变量 row 的值是奇数\n更新变量 startx 的值，表示正六边形所在的 x 坐标不需要偏移\n当变量 startx 的值小于变量 endx 的值时，执行以下循环体\n计算正六边形的六个顶点的 x 坐标和 y 坐标\n创建一个列表 poly，保存正六边形的六个顶点的坐标\n将列表 poly 添加到列表 polygons 中"}
{"prompt": "Write a function to convert the given binary tuple to integer.", "canonical_solution": "def binary_to_integer(test_tup):\r\n  res = int(\"\".join(str(ele) for ele in test_tup), 2)\r\n  return (str(res)) ", "task_id": "Python/494", "test_setup": "", "test": ["assert binary_to_integer((1, 1, 0, 1, 0, 0, 1)) == '105'", "assert binary_to_integer((0, 1, 1, 0, 0, 1, 0, 1)) == '101'", "assert binary_to_integer((1, 1, 0, 1, 0, 1)) == '53'"], "challenge_test_list": [], "func_title": "def binary_to_integer(test_tup):\r", "prompt_text_chinese": "写一个函数，将给定的二进制元组转换为整数。", "code_comment": "定义一个函数 binary_to_integer，接收一个参数 test_tup，该参数是一个由 0 和 1 组成的元组\n将元组转换为二进制字符串，再将二进制字符串转换为十进制整数，将结果保存到变量 res 中\n返回变量 res 的字符串形式\n"}
{"prompt": "Write a function to remove lowercase substrings from a given string by using regex.", "canonical_solution": "import re\r\ndef remove_lowercase(str1):\r\n  remove_lower = lambda text: re.sub('[a-z]', '', text)\r\n  result =  remove_lower(str1)\r\n  return (result)", "task_id": "Python/495", "test_setup": "", "test": ["assert remove_lowercase('KDeoALOklOOHserfLoAJSIskdsf') == 'KDALOOOHLAJSI'", "assert remove_lowercase('ProducTnamEstreAmIngMediAplAYer') == 'PTEAIMAAY'", "assert remove_lowercase('maNufacTuredbYSheZenTechNolOGIes') == 'NTYSZTNOGI'"], "challenge_test_list": [], "func_title": "def remove_lowercase(str1):\r", "prompt_text_chinese": "写一个函数，通过使用regex从给定的字符串中删除小写字母子串。", "code_comment": "导入模块 re，用于进行正则表达式操作\n定义一个函数 remove_lowercase，接收一个参数 str1，该参数是一个字符串\n定义一个匿名函数 remove_lower，用于将字符串中所有小写字母替换为空字符串\n将参数 str1 传递给匿名函数 remove_lower，将结果保存到变量 result 中\n返回变量 result"}
{"prompt": "Write a function to find the smallest integers from a given list of numbers using heap queue algorithm.", "canonical_solution": "import heapq as hq\r\ndef heap_queue_smallest(nums,n):\r\n  smallest_nums = hq.nsmallest(n, nums)\r\n  return smallest_nums", "task_id": "Python/496", "test_setup": "", "test": ["assert heap_queue_smallest( [25, 35, 22, 85, 14, 65, 75, 25, 58],3)==[14, 22, 25] ", "assert heap_queue_smallest( [25, 35, 22, 85, 14, 65, 75, 25, 58],2)==[14, 22]", "assert heap_queue_smallest( [25, 35, 22, 85, 14, 65, 75, 22, 58],5)==[14, 22, 22, 25, 35]"], "challenge_test_list": [], "func_title": "def heap_queue_smallest(nums,n):\r", "prompt_text_chinese": "写一个函数，用堆队列算法从给定的数字列表中找出最小的整数。", "code_comment": "导入模块 heapq，并将其重命名为 hq，用于实现堆排序算法\n定义一个函数 heap_queue_smallest，接收两个参数 nums 和 n，其中 nums 是一个列表，n 是一个整数\n使用 hq.nsmallest 函数，找出列表 nums 中最小的 n 个元素，将结果保存到变量 smallest_nums 中\n返回变量 smallest_nums，表示最小的 n 个元素"}
{"prompt": "Write a function to find the surface area of a cone.", "canonical_solution": "import math\r\ndef surfacearea_cone(r,h):\r\n  l = math.sqrt(r * r + h * h)\r\n  SA = math.pi * r * (r + l)\r\n  return SA", "task_id": "Python/497", "test_setup": "", "test": ["assert surfacearea_cone(5,12)==282.7433388230814", "assert surfacearea_cone(10,15)==880.5179353159282", "assert surfacearea_cone(19,17)==2655.923961165254"], "challenge_test_list": [], "func_title": "def surfacearea_cone(r,h):\r", "prompt_text_chinese": "写一个函数来寻找一个圆锥体的表面积。", "code_comment": "导入模块 math，用于进行数学计算\n定义一个函数 surfacearea_cone，接收两个参数 r 和 h，均为实数\n计算锥的母线长度，将结果保存到变量 l 中\n计算锥的表面积，将结果保存到变量 SA 中\n返回变量 SA，表示锥的表面积"}
{"prompt": "Write a python function to find gcd of two positive integers.", "canonical_solution": "def gcd(x, y):\r\n    gcd = 1\r\n    if x % y == 0:\r\n        return y\r\n    for k in range(int(y / 2), 0, -1):\r\n        if x % k == 0 and y % k == 0:\r\n            gcd = k\r\n            break  \r\n    return gcd", "task_id": "Python/498", "test_setup": "", "test": ["assert gcd(12, 17) == 1", "assert gcd(4,6) == 2", "assert gcd(2,9) == 1"], "challenge_test_list": [], "func_title": "def gcd(x, y):\r", "prompt_text_chinese": "写一个Python函数来寻找两个正整数的gcd。", "code_comment": "定义一个函数 gcd，接收两个参数 x 和 y，均为整数\n定义变量 gcd，初始值为 1\n如果变量 x 对变量 y 取模等于 0\n返回变量 y，表示变量 y 是变量 x 和 y 的最大公约数\n否则，从 y 的一半开始倒序遍历到 1，每次遍历的步长为 -1\n如果 k 是 x 和 y 的公约数\n将变量 gcd 的值更新为 k，表示找到了 x 和 y 的最大公约数\n跳出循环\n返回变量 gcd，表示 x 和 y 的最大公约数"}
{"prompt": "Write a function to find the diameter of a circle.", "canonical_solution": "def diameter_circle(r):\r\n  diameter=2*r\r\n  return diameter", "task_id": "Python/499", "test_setup": "", "test": ["assert diameter_circle(10)==20", "assert diameter_circle(40)==80", "assert diameter_circle(15)==30"], "challenge_test_list": [], "func_title": "def diameter_circle(r):\r", "prompt_text_chinese": "写一个函数来寻找圆的直径。", "code_comment": "定义一个函数 diameter_circle，接收一个参数 r，该参数是一个实数，表示圆的半径\n计算圆的直径，将结果保存到变量 diameter 中\n返回变量 diameter，表示圆的直径"}
{"prompt": "Write a function to concatenate all elements of the given list into a string.", "canonical_solution": "def concatenate_elements(list):\r\n  ans = ' '\r\n  for i in list:\r\n    ans = ans+ ' '+i\r\n  return (ans) ", "task_id": "Python/500", "test_setup": "", "test": ["assert concatenate_elements(['hello','there','have','a','rocky','day'] ) == '  hello there have a rocky day'", "assert concatenate_elements([ 'Hi', 'there', 'How','are', 'you'] ) == '  Hi there How are you'", "assert concatenate_elements([ 'Part', 'of', 'the','journey', 'is', 'end'] ) == '  Part of the journey is end'"], "challenge_test_list": [], "func_title": "def concatenate_elements(list):\r", "prompt_text_chinese": "写一个函数，将给定列表中的所有元素串联成一个字符串。", "code_comment": "定义一个函数 concatenate_elements，接收一个参数 list，该参数是一个字符串列表\n定义变量 ans，初始值为空格\n遍历列表 list 中的所有元素\n将变量 i 添加到变量 ans 后面，并在它们中间添加一个空格\n返回变量 ans，表示将列表 list 中的所有元素连接起来的新字符串"}
{"prompt": "Write a python function to find common divisor between two numbers in a given pair.", "canonical_solution": "def ngcd(x,y):\r\n    i=1\r\n    while(i<=x and i<=y):\r\n        if(x%i==0 and y%i == 0):\r\n            gcd=i;\r\n        i+=1\r\n    return gcd;\r\ndef num_comm_div(x,y):\r\n  n = ngcd(x,y)\r\n  result = 0\r\n  z = int(n**0.5)\r\n  i = 1\r\n  while(i <= z):\r\n    if(n % i == 0):\r\n      result += 2 \r\n      if(i == n/i):\r\n        result-=1\r\n    i+=1\r\n  return result", "task_id": "Python/501", "test_setup": "", "test": ["assert num_comm_div(2,4) == 2", "assert num_comm_div(2,8) == 2", "assert num_comm_div(12,24) == 6"], "challenge_test_list": [], "func_title": "def ngcd(x,y):\r", "prompt_text_chinese": "写一个python函数，在给定的一对数字中找到两个数字的共同除数。", "code_comment": "定义一个函数 ngcd，接收两个参数 x 和 y，均为整数\n定义变量 i，初始值为 1\n当 i 小于等于 x 和 y 时，执行以下循环体\n如果 i 是 x 和 y 的公约数\n将变量 gcd 的值更新为 i，表示找到了 x 和 y 的最大公约数\ni 自增 1\n返回变量 gcd，表示 x 和 y 的最大公约数\n定义一个函数 num_comm_div，接收两个参数 x 和 y，均为整数\n调用函数 ngcd，求出 x 和 y 的最大公约数，将结果保存到变量 n 中\n定义变量 result，初始值为 0\n将变量 n 开平方，将结果保存到变量 z 中\n定义变量 i，初始值为 1\n当 i 小于等于 z 时，执行以下循环体\n如果 i 是 n 的因子\n将变量 result 的值加 2，因为 i 和 n/i 都是 n 的因子\n如果 i 等于 n/i，表示 i 是 n 的平方因子，只能算一次\ni 自增 1\n返回变量 result，表示 x 和 y 的公因数个数"}
{"prompt": "Write a python function to find remainder of two numbers.", "canonical_solution": "def find(n,m):\r\n  r = n%m\r\n  return (r)", "task_id": "Python/502", "test_setup": "", "test": ["assert find(3,3) == 0", "assert find(10,3) == 1", "assert find(16,5) == 1"], "challenge_test_list": [], "func_title": "def find(n,m):\r", "prompt_text_chinese": "写一个Python函数来寻找两个数字的余数。", "code_comment": "定义一个函数 find，接收两个参数 n 和 m，均为整数\n计算 n 对 m 取模的结果，将结果保存到变量 r 中\n返回变量 r，表示 n 对 m 取模的结果\n"}
{"prompt": "Write a function to add consecutive numbers of a given list.", "canonical_solution": "def add_consecutive_nums(nums):\r\n    result = [b+a for a, b in zip(nums[:-1], nums[1:])]\r\n    return result", "task_id": "Python/503", "test_setup": "", "test": ["assert add_consecutive_nums([1, 1, 3, 4, 4, 5, 6, 7])==[2, 4, 7, 8, 9, 11, 13]", "assert add_consecutive_nums([4, 5, 8, 9, 6, 10])==[9, 13, 17, 15, 16]", "assert add_consecutive_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[3, 5, 7, 9, 11, 13, 15, 17, 19]"], "challenge_test_list": [], "func_title": "def add_consecutive_nums(nums):\r", "prompt_text_chinese": "编写一个函数，将给定列表中的连续数字相加。", "code_comment": "定义一个函数 add_consecutive_nums，接收一个参数 nums，该参数是一个整数列表\n计算相邻两个元素的和，并将结果保存到列表 result 中\n返回列表 result，表示相邻两个元素的和\n"}
{"prompt": "Write a python function to find the cube sum of first n natural numbers.", "canonical_solution": "def sum_Of_Series(n): \r\n    sum = 0\r\n    for i in range(1,n + 1): \r\n        sum += i * i*i       \r\n    return sum", "task_id": "Python/504", "test_setup": "", "test": ["assert sum_Of_Series(5) == 225", "assert sum_Of_Series(2) == 9", "assert sum_Of_Series(3) == 36"], "challenge_test_list": [], "func_title": "def sum_Of_Series(n): \r", "prompt_text_chinese": "写一个Python函数来寻找前n个自然数的立方和。", "code_comment": "定义一个函数 sum_Of_Series，接收一个参数 n，该参数是一个正整数\n定义变量 sum，初始值为 0\n遍历从 1 到 n 的所有整数\n将 i 的三次方加到变量 sum 中\n返回变量 sum，表示 1 到 n 所有整数的三次方之和"}
{"prompt": "Write a function to move all zeroes to the end of the given array.", "canonical_solution": "def re_order(A):\r\n    k = 0\r\n    for i in A:\r\n        if i:\r\n            A[k] = i\r\n            k = k + 1\r\n    for i in range(k, len(A)):\r\n        A[i] = 0\r\n    return A", "task_id": "Python/505", "test_setup": "", "test": ["assert re_order([6, 0, 8, 2, 3, 0, 4, 0, 1]) == [6, 8, 2, 3, 4, 1, 0, 0, 0]", "assert re_order([4, 0, 2, 7, 0, 9, 0, 12, 0]) == [4, 2, 7, 9, 12, 0, 0, 0, 0]", "assert re_order([3, 11, 0, 74, 14, 0, 1, 0, 2]) == [3, 11, 74, 14, 1, 2, 0, 0, 0]"], "challenge_test_list": [], "func_title": "def re_order(A):\r", "prompt_text_chinese": "写一个函数，将所有的零移到给定数组的末尾。", "code_comment": "定义一个函数 re_order，接收一个参数 A，该参数是一个整数列表\n定义变量 k，初始值为 0\n遍历列表 A 中的所有元素\n如果 i 不为 0\n将 i 赋值给列表 A 的第 k 个元素\nk 自增 1\n遍历从 k 到列表 A 的长度减 1 的所有整数\n将列表 A 的第 i 个元素赋值为 0\n返回列表 A，表示经过重新排序后的列表"}
{"prompt": "Write a function to calculate the permutation coefficient of given p(n, k).", "canonical_solution": "def permutation_coefficient(n, k): \r\n\tP = [[0 for i in range(k + 1)] \r\n\t\t\tfor j in range(n + 1)] \r\n\tfor i in range(n + 1): \r\n\t\tfor j in range(min(i, k) + 1): \r\n\t\t\tif (j == 0): \r\n\t\t\t\tP[i][j] = 1\r\n\t\t\telse: \r\n\t\t\t\tP[i][j] = P[i - 1][j] + ( \r\n\t\t\t\t\t\tj * P[i - 1][j - 1]) \r\n\t\t\tif (j < k): \r\n\t\t\t\tP[i][j + 1] = 0\r\n\treturn P[n][k] ", "task_id": "Python/506", "test_setup": "", "test": ["assert permutation_coefficient(10, 2) == 90", "assert permutation_coefficient(10, 3) == 720", "assert permutation_coefficient(10, 1) == 10"], "challenge_test_list": [], "func_title": "def permutation_coefficient(n, k): \r", "prompt_text_chinese": "写一个函数来计算给定的p(n, k)的互换系数。", "code_comment": "定义一个函数 permutation_coefficient，接收两个参数 n 和 k，均为正整数\n定义一个二维列表 P，初始化所有元素为 0\n遍历从 0 到 n 的所有整数\n遍历从 0 到 min(i, k) 的所有整数\n如果 j 等于 0，将列表 P 的第 i 行第 j 列的元素赋值为 1\n否则，计算 P[i][j] 的值，并将结果赋给列表 P 的第 i 行第 j 列的元素\n如果 j 小于 k，将列表 P 的第 i 行第 j+1 列的元素赋值为 0\n返回列表 P 的第 n 行第 k 列的元素"}
{"prompt": "Write a function to remove specific words from a given list.", "canonical_solution": "def remove_words(list1, removewords):\r\n    for word in list(list1):\r\n        if word in removewords:\r\n            list1.remove(word)\r\n    return list1  ", "task_id": "Python/507", "test_setup": "", "test": ["assert remove_words(['red', 'green', 'blue', 'white', 'black', 'orange'],['white', 'orange'])==['red', 'green', 'blue', 'black']", "assert remove_words(['red', 'green', 'blue', 'white', 'black', 'orange'],['black', 'orange'])==['red', 'green', 'blue', 'white']", "assert remove_words(['red', 'green', 'blue', 'white', 'black', 'orange'],['blue', 'white'])==['red', 'green', 'black', 'orange']"], "challenge_test_list": [], "func_title": "def remove_words(list1, removewords):\r", "prompt_text_chinese": "写一个函数，从给定的列表中删除特定的字。", "code_comment": "定义一个函数 remove_words，接收两个参数 list1 和 removewords，均为字符串列表\n遍历列表 list1 中的所有元素\n如果元素 word 在列表 removewords 中\n将元素 word 从列表 list1 中删除\n返回列表 list1，表示删除后的新列表"}
{"prompt": "Write a function to check if the common elements between two given lists are in the same order or not.", "canonical_solution": "def same_order(l1, l2):\r\n    common_elements = set(l1) & set(l2)\r\n    l1 = [e for e in l1 if e in common_elements]\r\n    l2 = [e for e in l2 if e in common_elements]\r\n    return l1 == l2", "task_id": "Python/508", "test_setup": "", "test": ["assert same_order([\"red\",\"green\",\"black\",\"orange\"],[\"red\",\"pink\",\"green\",\"white\",\"black\"])==True", "assert same_order([\"red\",\"pink\",\"green\",\"white\",\"black\"],[\"white\",\"orange\",\"pink\",\"black\"])==False", "assert same_order([\"red\",\"green\",\"black\",\"orange\"],[\"red\",\"pink\",\"green\",\"white\",\"black\"])==True"], "challenge_test_list": [], "func_title": "def same_order(l1, l2):\r", "prompt_text_chinese": "写一个函数来检查两个给定列表之间的共同元素是否处于相同的顺序。", "code_comment": "定义一个函数 same_order，接收两个参数 l1 和 l2，均为列表\n将列表 l1 和列表 l2 中的相同元素存储到集合 common_elements 中\n从列表 l1 中筛选出与列表 l2 中相同的元素，将结果重新赋值给 l1\n从列表 l2 中筛选出与列表 l1 中相同的元素，将结果重新赋值给 l2\n判断列表 l1 和列表 l2 是否相同，如果相同，返回 True，否则返回 False"}
{"prompt": "Write a python function to find the average of odd numbers till a given odd number.", "canonical_solution": "def average_Odd(n) : \r\n    if (n%2==0) : \r\n        return (\"Invalid Input\") \r\n        return -1 \r\n    sm =0\r\n    count =0\r\n    while (n>=1) : \r\n        count=count+1\r\n        sm = sm + n \r\n        n = n-2\r\n    return sm//count ", "task_id": "Python/509", "test_setup": "", "test": ["assert average_Odd(9) == 5", "assert average_Odd(5) == 3", "assert average_Odd(11) == 6"], "challenge_test_list": [], "func_title": "def average_Odd(n) : \r", "prompt_text_chinese": "写一个Python函数，找出直到给定奇数的平均数。", "code_comment": "定义一个函数 average_Odd，接收一个参数 n，表示一个正奇数\n如果 n 是偶数，则返回 \"Invalid Input\"，表示输入无效\n定义变量 sm，表示前 n 个正奇数的和，初始值为 0\n定义变量 count，表示前 n 个正奇数的个数，初始值为 0\n当 n 大于等于 1 时，执行以下循环体\n将变量 count 的值自增 1\n将 n 加到变量 sm 中\n将 n 减 2，并将结果重新赋值给变量 n\n返回变量 sm 除以变量 count 的商，表示前 n 个正奇数的平均数\n"}
{"prompt": "Write a function to find the number of subsequences having product smaller than k for the given non negative array.", "canonical_solution": "def no_of_subsequences(arr, k): \r\n\tn = len(arr) \r\n\tdp = [[0 for i in range(n + 1)] \r\n\t\t\tfor j in range(k + 1)] \r\n\tfor i in range(1, k + 1): \r\n\t\tfor j in range(1, n + 1): \r\n\t\t\tdp[i][j] = dp[i][j - 1] \r\n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \r\n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\r\n\treturn dp[k][n]", "task_id": "Python/510", "test_setup": "", "test": ["assert no_of_subsequences([1,2,3,4], 10) == 11", "assert no_of_subsequences([4,8,7,2], 50) == 9", "assert no_of_subsequences([5,6,7,8], 15) == 4"], "challenge_test_list": [], "func_title": "def no_of_subsequences(arr, k): \r", "prompt_text_chinese": "写一个函数，找出给定的非负数组中积小于k的子序列的数量。", "code_comment": "定义一个函数 no_of_subsequences，接收两个参数 arr 和 k，其中 arr 为正整数列表，k 为正整数\n获取列表 arr 的长度，将结果保存到变量 n 中\n定义一个二维列表 dp，初始化所有元素为 0\n遍历从 1 到 k 的所有整数\n遍历从 1 到 n 的所有整数\n将列表 dp 的第 i 行第 j 列的值更新为 dp[i][j-1]\n如果 arr[j-1] 小于等于 i 且大于 0\n将列表 dp 的第 i 行第 j 列的值加上 dp[i//arr[j-1]][j-1]+1\n返回列表 dp 的第 k 行第 n 列的元素\n"}